(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('monaco')) :
	typeof define === 'function' && define.amd ? define(['exports', 'monaco'], factory) :
	(factory((global.thegamma = global.thegamma || {}),global.na));
}(this, (function (exports,monaco$1) { 'use strict';

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



function unwrapExports (x) {
	return x && x.__esModule ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

// 7.1.13 ToObject(argument)
var defined = _defined;
var _toObject = function(it){
  return Object(defined(it));
};

var hasOwnProperty = {}.hasOwnProperty;
var _has = function(it, key){
  return hasOwnProperty.call(it, key);
};

var toString = {}.toString;

var _cof = function(it){
  return toString.call(it).slice(8, -1);
};

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = _cof;
var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = _iobject;
var defined$1 = _defined;
var _toIobject = function(it){
  return IObject(defined$1(it));
};

// 7.1.4 ToInteger
var ceil  = Math.ceil;
var floor = Math.floor;
var _toInteger = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

// 7.1.15 ToLength
var toInteger = _toInteger;
var min       = Math.min;
var _toLength = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

var toInteger$1 = _toInteger;
var max       = Math.max;
var min$1       = Math.min;
var _toIndex = function(index, length){
  index = toInteger$1(index);
  return index < 0 ? max(index + length, 0) : min$1(index, length);
};

// false -> Array#indexOf
// true  -> Array#includes
var toIObject$1 = _toIobject;
var toLength  = _toLength;
var toIndex   = _toIndex;
var _arrayIncludes = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject$1($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

var _global = createCommonjsModule(function (module) {
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
});

var global$1 = _global;
var SHARED = '__core-js_shared__';
var store  = global$1[SHARED] || (global$1[SHARED] = {});
var _shared = function(key){
  return store[key] || (store[key] = {});
};

var id = 0;
var px = Math.random();
var _uid = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var shared = _shared('keys');
var uid    = _uid;
var _sharedKey = function(key){
  return shared[key] || (shared[key] = uid(key));
};

var has          = _has;
var toIObject    = _toIobject;
var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO     = _sharedKey('IE_PROTO');

var _objectKeysInternal = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

// IE 8- don't enum bug keys
var _enumBugKeys = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys$1       = _objectKeysInternal;
var enumBugKeys = _enumBugKeys;

var _objectKeys = Object.keys || function keys(O){
  return $keys$1(O, enumBugKeys);
};

var _core = createCommonjsModule(function (module) {
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
});

var _aFunction = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding
var aFunction = _aFunction;
var _ctx = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

var _isObject = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var isObject = _isObject;
var _anObject = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

var isObject$1 = _isObject;
var document$1 = _global.document;
var is = isObject$1(document$1) && isObject$1(document$1.createElement);
var _domCreate = function(it){
  return is ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function(){
  return Object.defineProperty(_domCreate('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject$2 = _isObject;
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function(it, S){
  if(!isObject$2(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject$2(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject$2(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject$2(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

var anObject       = _anObject;
var IE8_DOM_DEFINE = _ie8DomDefine;
var toPrimitive    = _toPrimitive;
var dP$1             = Object.defineProperty;

var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP$1(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

var _objectDp = {
	f: f
};

var _propertyDesc = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

var dP         = _objectDp;
var createDesc = _propertyDesc;
var _hide = _descriptors ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

var global$2    = _global;
var core$1      = _core;
var ctx       = _ctx;
var hide      = _hide;
var PROTOTYPE = 'prototype';

var $export$1 = function(type, name, source){
  var IS_FORCED = type & $export$1.F
    , IS_GLOBAL = type & $export$1.G
    , IS_STATIC = type & $export$1.S
    , IS_PROTO  = type & $export$1.P
    , IS_BIND   = type & $export$1.B
    , IS_WRAP   = type & $export$1.W
    , exports   = IS_GLOBAL ? core$1 : core$1[name] || (core$1[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global$2 : IS_STATIC ? global$2[name] : (global$2[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global$2)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export$1.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export$1.F = 1;   // forced
$export$1.G = 2;   // global
$export$1.S = 4;   // static
$export$1.P = 8;   // proto
$export$1.B = 16;  // bind
$export$1.W = 32;  // wrap
$export$1.U = 64;  // safe
$export$1.R = 128; // real proto method for `library` 
var _export = $export$1;

// most Object methods by ES6 should accept primitives
var $export = _export;
var core    = _core;
var fails   = _fails;
var _objectSap = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};

// 19.1.2.14 Object.keys(O)
var toObject = _toObject;
var $keys    = _objectKeys;

_objectSap('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});

var keys$1 = _core.Object.keys;

var keys = createCommonjsModule(function (module) {
module.exports = { "default": keys$1, __esModule: true };
});

var _Object$keys = unwrapExports(keys);

var toInteger$2 = _toInteger;
var defined$2   = _defined;
// true  -> String#at
// false -> String#codePointAt
var _stringAt = function(TO_STRING){
  return function(that, pos){
    var s = String(defined$2(that))
      , i = toInteger$2(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

var _library = true;

var _redefine = _hide;

var _iterators = {};

var dP$2       = _objectDp;
var anObject$2 = _anObject;
var getKeys  = _objectKeys;

var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties){
  anObject$2(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP$2.f(O, P = keys[i++], Properties[P]);
  return O;
};

var _html = _global.document && document.documentElement;

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject$1    = _anObject;
var dPs         = _objectDps;
var enumBugKeys$1 = _enumBugKeys;
var IE_PROTO$1    = _sharedKey('IE_PROTO');
var Empty       = function(){ /* empty */ };
var PROTOTYPE$1   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _domCreate('iframe')
    , i      = enumBugKeys$1.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  _html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE$1][enumBugKeys$1[i]];
  return createDict();
};

var _objectCreate = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE$1] = anObject$1(O);
    result = new Empty;
    Empty[PROTOTYPE$1] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

var _wks = createCommonjsModule(function (module) {
var store      = _shared('wks')
  , uid        = _uid
  , Symbol     = _global.Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
});

var def = _objectDp.f;
var has$2 = _has;
var TAG = _wks('toStringTag');

var _setToStringTag = function(it, tag, stat){
  if(it && !has$2(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

var create         = _objectCreate;
var descriptor     = _propertyDesc;
var setToStringTag$1 = _setToStringTag;
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_hide(IteratorPrototype, _wks('iterator'), function(){ return this; });

var _iterCreate = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag$1(Constructor, NAME + ' Iterator');
};

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has$3         = _has;
var toObject$1    = _toObject;
var IE_PROTO$2    = _sharedKey('IE_PROTO');
var ObjectProto = Object.prototype;

var _objectGpo = Object.getPrototypeOf || function(O){
  O = toObject$1(O);
  if(has$3(O, IE_PROTO$2))return O[IE_PROTO$2];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

var LIBRARY        = _library;
var $export$2        = _export;
var redefine       = _redefine;
var hide$1           = _hide;
var has$1            = _has;
var Iterators      = _iterators;
var $iterCreate    = _iterCreate;
var setToStringTag = _setToStringTag;
var getPrototypeOf = _objectGpo;
var ITERATOR       = _wks('iterator');
var BUGGY          = !([].keys && 'next' in [].keys());
var FF_ITERATOR    = '@@iterator';
var KEYS           = 'keys';
var VALUES         = 'values';

var returnThis = function(){ return this; };

var _iterDefine = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has$1(IteratorPrototype, ITERATOR))hide$1(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide$1(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export$2($export$2.P + $export$2.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

var $at  = _stringAt(true);

// 21.1.3.27 String.prototype[@@iterator]()
_iterDefine(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});

// call something on iterator step with safe closing on error
var anObject$3 = _anObject;
var _iterCall = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject$3(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject$3(ret.call(iterator));
    throw e;
  }
};

// check on default Array iterator
var Iterators$1  = _iterators;
var ITERATOR$1   = _wks('iterator');
var ArrayProto = Array.prototype;

var _isArrayIter = function(it){
  return it !== undefined && (Iterators$1.Array === it || ArrayProto[ITERATOR$1] === it);
};

var $defineProperty = _objectDp;
var createDesc$1      = _propertyDesc;

var _createProperty = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc$1(0, value));
  else object[index] = value;
};

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof$1 = _cof;
var TAG$1 = _wks('toStringTag');
var ARG = cof$1(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

var _classof = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
    // builtinTag case
    : ARG ? cof$1(O)
    // ES3 arguments fallback
    : (B = cof$1(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

var classof   = _classof;
var ITERATOR$2  = _wks('iterator');
var Iterators$2 = _iterators;
var core_getIteratorMethod = _core.getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR$2]
    || it['@@iterator']
    || Iterators$2[classof(it)];
};

var ITERATOR$3     = _wks('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR$3]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

var _iterDetect = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR$3]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR$3] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};

var ctx$1            = _ctx;
var $export$3        = _export;
var toObject$2       = _toObject;
var call           = _iterCall;
var isArrayIter    = _isArrayIter;
var toLength$1       = _toLength;
var createProperty = _createProperty;
var getIterFn      = core_getIteratorMethod;

$export$3($export$3.S + $export$3.F * !_iterDetect(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject$2(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx$1(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength$1(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

var from$1 = _core.Array.from;

var from = createCommonjsModule(function (module) {
module.exports = { "default": from$1, __esModule: true };
});

var _Array$from = unwrapExports(from);

var _meta = createCommonjsModule(function (module) {
var META     = _uid('meta')
  , isObject = _isObject
  , has      = _has
  , setDesc  = _objectDp.f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !_fails(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};
});

var f$1 = _wks;

var _wksExt = {
	f: f$1
};

var global$4         = _global;
var core$2           = _core;
var LIBRARY$1        = _library;
var wksExt$1         = _wksExt;
var defineProperty = _objectDp.f;
var _wksDefine = function(name){
  var $Symbol = core$2.Symbol || (core$2.Symbol = LIBRARY$1 ? {} : global$4.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt$1.f(name)});
};

var getKeys$1   = _objectKeys;
var toIObject$3 = _toIobject;
var _keyof = function(object, el){
  var O      = toIObject$3(object)
    , keys   = getKeys$1(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

var f$2 = Object.getOwnPropertySymbols;

var _objectGops = {
	f: f$2
};

var f$3 = {}.propertyIsEnumerable;

var _objectPie = {
	f: f$3
};

// all enumerable object keys, includes symbols
var getKeys$2 = _objectKeys;
var gOPS    = _objectGops;
var pIE     = _objectPie;
var _enumKeys = function(it){
  var result     = getKeys$2(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

// 7.2.2 IsArray(argument)
var cof$2 = _cof;
var _isArray = Array.isArray || function isArray(arg){
  return cof$2(arg) == 'Array';
};

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys$3      = _objectKeysInternal;
var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

var f$5 = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys$3(O, hiddenKeys);
};

var _objectGopn = {
	f: f$5
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject$4 = _toIobject;
var gOPN$1      = _objectGopn.f;
var toString$1  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN$1(it);
  } catch(e){
    return windowNames.slice();
  }
};

var f$4 = function getOwnPropertyNames(it){
  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN$1(toIObject$4(it));
};

var _objectGopnExt = {
	f: f$4
};

var pIE$1            = _objectPie;
var createDesc$3     = _propertyDesc;
var toIObject$5      = _toIobject;
var toPrimitive$2    = _toPrimitive;
var has$5            = _has;
var IE8_DOM_DEFINE$1 = _ie8DomDefine;
var gOPD$1           = Object.getOwnPropertyDescriptor;

var f$6 = _descriptors ? gOPD$1 : function getOwnPropertyDescriptor(O, P){
  O = toIObject$5(O);
  P = toPrimitive$2(P, true);
  if(IE8_DOM_DEFINE$1)try {
    return gOPD$1(O, P);
  } catch(e){ /* empty */ }
  if(has$5(O, P))return createDesc$3(!pIE$1.f.call(O, P), O[P]);
};

var _objectGopd = {
	f: f$6
};

// ECMAScript 6 symbols shim
var global$3         = _global;
var has$4            = _has;
var DESCRIPTORS    = _descriptors;
var $export$4        = _export;
var redefine$1       = _redefine;
var META           = _meta.KEY;
var $fails         = _fails;
var shared$1         = _shared;
var setToStringTag$2 = _setToStringTag;
var uid$1            = _uid;
var wks            = _wks;
var wksExt         = _wksExt;
var wksDefine      = _wksDefine;
var keyOf          = _keyof;
var enumKeys       = _enumKeys;
var isArray        = _isArray;
var anObject$4       = _anObject;
var toIObject$2      = _toIobject;
var toPrimitive$1    = _toPrimitive;
var createDesc$2     = _propertyDesc;
var _create        = _objectCreate;
var gOPNExt        = _objectGopnExt;
var $GOPD          = _objectGopd;
var $DP            = _objectDp;
var $keys$2          = _objectKeys;
var gOPD           = $GOPD.f;
var dP$3             = $DP.f;
var gOPN           = gOPNExt.f;
var $Symbol        = global$3.Symbol;
var $JSON          = global$3.JSON;
var _stringify     = $JSON && $JSON.stringify;
var PROTOTYPE$2      = 'prototype';
var HIDDEN         = wks('_hidden');
var TO_PRIMITIVE   = wks('toPrimitive');
var isEnum         = {}.propertyIsEnumerable;
var SymbolRegistry = shared$1('symbol-registry');
var AllSymbols     = shared$1('symbols');
var OPSymbols      = shared$1('op-symbols');
var ObjectProto$1    = Object[PROTOTYPE$2];
var USE_NATIVE     = typeof $Symbol == 'function';
var QObject        = global$3.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP$3({}, 'a', {
    get: function(){ return dP$3(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto$1, key);
  if(protoDesc)delete ObjectProto$1[key];
  dP$3(it, key, D);
  if(protoDesc && it !== ObjectProto$1)dP$3(ObjectProto$1, key, protoDesc);
} : dP$3;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE$2]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty$1 = function defineProperty(it, key, D){
  if(it === ObjectProto$1)$defineProperty$1(OPSymbols, key, D);
  anObject$4(it);
  key = toPrimitive$1(key, true);
  anObject$4(D);
  if(has$4(AllSymbols, key)){
    if(!D.enumerable){
      if(!has$4(it, HIDDEN))dP$3(it, HIDDEN, createDesc$2(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has$4(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc$2(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP$3(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject$4(it);
  var keys = enumKeys(P = toIObject$2(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty$1(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive$1(key, true));
  if(this === ObjectProto$1 && has$4(AllSymbols, key) && !has$4(OPSymbols, key))return false;
  return E || !has$4(this, key) || !has$4(AllSymbols, key) || has$4(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject$2(it);
  key = toPrimitive$1(key, true);
  if(it === ObjectProto$1 && has$4(AllSymbols, key) && !has$4(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has$4(AllSymbols, key) && !(has$4(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject$2(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has$4(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto$1
    , names  = gOPN(IS_OP ? OPSymbols : toIObject$2(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has$4(AllSymbols, key = names[i++]) && (IS_OP ? has$4(ObjectProto$1, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid$1(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto$1)$set.call(OPSymbols, value);
      if(has$4(this, HIDDEN) && has$4(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc$2(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto$1, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine$1($Symbol[PROTOTYPE$2], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty$1;
  _objectGopn.f = gOPNExt.f = $getOwnPropertyNames;
  _objectPie.f  = $propertyIsEnumerable;
  _objectGops.f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !_library){
    redefine$1(ObjectProto$1, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  };
}

$export$4($export$4.G + $export$4.W + $export$4.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys$2(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export$4($export$4.S + $export$4.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has$4(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export$4($export$4.S + $export$4.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty$1,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export$4($export$4.S + $export$4.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag$2($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag$2(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag$2(global$3.JSON, 'JSON', true);

_wksDefine('asyncIterator');

_wksDefine('observable');

var index = _core.Symbol;

var symbol = createCommonjsModule(function (module) {
module.exports = { "default": index, __esModule: true };
});

var _Symbol2 = unwrapExports(symbol);

var classCallCheck = createCommonjsModule(function (module, exports) {
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
});

var _classCallCheck = unwrapExports(classCallCheck);

var $export$5 = _export;
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export$5($export$5.S + $export$5.F * !_descriptors, 'Object', {defineProperty: _objectDp.f});

var $Object = _core.Object;
var defineProperty$3 = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};

var defineProperty$1 = createCommonjsModule(function (module) {
module.exports = { "default": defineProperty$3, __esModule: true };
});

var createClass = createCommonjsModule(function (module, exports) {
"use strict";

exports.__esModule = true;

var _defineProperty = defineProperty$1;

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
});

var _createClass = unwrapExports(createClass);

var _addToUnscopables = function(){ /* empty */ };

var _iterStep = function(done, value){
  return {value: value, done: !!done};
};

var addToUnscopables = _addToUnscopables;
var step             = _iterStep;
var Iterators$4        = _iterators;
var toIObject$6        = _toIobject;

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
var es6_array_iterator = _iterDefine(Array, 'Array', function(iterated, kind){
  this._t = toIObject$6(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators$4.Arguments = Iterators$4.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

var global$5        = _global;
var hide$2          = _hide;
var Iterators$3     = _iterators;
var TO_STRING_TAG = _wks('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i$1 = 0; i$1 < 5; i$1++){
  var NAME       = collections[i$1]
    , Collection = global$5[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide$2(proto, TO_STRING_TAG, NAME);
  Iterators$3[NAME] = Iterators$3.Array;
}

var iterator$2 = _wksExt.f('iterator');

var iterator = createCommonjsModule(function (module) {
module.exports = { "default": iterator$2, __esModule: true };
});

var _typeof_1 = createCommonjsModule(function (module, exports) {
"use strict";

exports.__esModule = true;

var _iterator = iterator;

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = symbol;

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
});

var _typeof = unwrapExports(_typeof_1);

var hide$3 = _hide;
var _redefineAll = function(target, src, safe){
  for(var key in src){
    if(safe && target[key])target[key] = src[key];
    else hide$3(target, key, src[key]);
  } return target;
};

var _anInstance = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

var _forOf = createCommonjsModule(function (module) {
var ctx         = _ctx
  , call        = _iterCall
  , isArrayIter = _isArrayIter
  , anObject    = _anObject
  , toLength    = _toLength
  , getIterFn   = core_getIteratorMethod
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;
});

var global$6      = _global;
var core$3        = _core;
var dP$5          = _objectDp;
var DESCRIPTORS$2 = _descriptors;
var SPECIES     = _wks('species');

var _setSpecies = function(KEY){
  var C = typeof core$3[KEY] == 'function' ? core$3[KEY] : global$6[KEY];
  if(DESCRIPTORS$2 && C && !C[SPECIES])dP$5.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};

var dP$4          = _objectDp.f;
var create$1      = _objectCreate;
var redefineAll = _redefineAll;
var ctx$2         = _ctx;
var anInstance  = _anInstance;
var defined$3     = _defined;
var forOf       = _forOf;
var $iterDefine = _iterDefine;
var step$1        = _iterStep;
var setSpecies  = _setSpecies;
var DESCRIPTORS$1 = _descriptors;
var fastKey$1     = _meta.fastKey;
var SIZE        = DESCRIPTORS$1 ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey$1(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

var _collectionStrong = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create$1(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx$2(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS$1)dP$4(C.prototype, 'size', {
      get: function(){
        return defined$3(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey$1(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step$1(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step$1(0, entry.k);
      if(kind == 'values')return step$1(0, entry.v);
      return step$1(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

var isObject$4 = _isObject;
var isArray$1  = _isArray;
var SPECIES$1  = _wks('species');

var _arraySpeciesConstructor = function(original){
  var C;
  if(isArray$1(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray$1(C.prototype)))C = undefined;
    if(isObject$4(C)){
      C = C[SPECIES$1];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = _arraySpeciesConstructor;

var _arraySpeciesCreate = function(original, length){
  return new (speciesConstructor(original))(length);
};

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx$3      = _ctx;
var IObject$1  = _iobject;
var toObject$3 = _toObject;
var toLength$2 = _toLength;
var asc      = _arraySpeciesCreate;
var _arrayMethods = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject$3($this)
      , self   = IObject$1(O)
      , f      = ctx$3(callbackfn, that, 3)
      , length = toLength$2(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

var global$7         = _global;
var $export$6        = _export;
var meta           = _meta;
var fails$1          = _fails;
var hide$4           = _hide;
var redefineAll$1    = _redefineAll;
var forOf$1          = _forOf;
var anInstance$1     = _anInstance;
var isObject$3       = _isObject;
var setToStringTag$3 = _setToStringTag;
var dP$6             = _objectDp.f;
var each           = _arrayMethods(0);
var DESCRIPTORS$3    = _descriptors;

var _collection = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global$7[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS$3 || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails$1(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll$1(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function(target, iterable){
      anInstance$1(target, C, NAME, '_c');
      target._c = new Base;
      if(iterable != undefined)forOf$1(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide$4(C.prototype, KEY, function(a, b){
        anInstance$1(this, C, KEY);
        if(!IS_ADDER && IS_WEAK && !isObject$3(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)dP$6(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag$3(C, NAME);

  O[NAME] = C;
  $export$6($export$6.G + $export$6.W + $export$6.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};

var strong = _collectionStrong;

// 23.1 Map Objects
var es6_map = _collection('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);

var forOf$2 = _forOf;

var _arrayFromIterable = function(iter, ITERATOR){
  var result = [];
  forOf$2(iter, false, result.push, result, ITERATOR);
  return result;
};

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof$1 = _classof;
var from$3    = _arrayFromIterable;
var _collectionToJson = function(NAME){
  return function toJSON(){
    if(classof$1(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from$3(this);
  };
};

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export$7  = _export;

$export$7($export$7.P + $export$7.R, 'Map', {toJSON: _collectionToJson('Map')});

var map$1 = _core.Map;

var map = createCommonjsModule(function (module) {
module.exports = { "default": map$1, __esModule: true };
});

var _Map = unwrapExports(map);

var defineProperty$5 = createCommonjsModule(function (module, exports) {
"use strict";

exports.__esModule = true;

var _defineProperty = defineProperty$1;

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};
});

var _defineProperty = unwrapExports(defineProperty$5);

var anObject$5 = _anObject;
var get      = core_getIteratorMethod;
var core_getIterator = _core.getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject$5(iterFn.call(it));
};

var getIterator$1 = core_getIterator;

var getIterator = createCommonjsModule(function (module) {
module.exports = { "default": getIterator$1, __esModule: true };
});

var _getIterator = unwrapExports(getIterator);

var fableGlobal = function () {
    var globalObj = typeof window !== "undefined" ? window
        : (typeof global !== "undefined" ? global
            : (typeof self !== "undefined" ? self : {}));
    if (typeof globalObj.__FABLE_CORE__ === "undefined") {
        globalObj.__FABLE_CORE__ = {
            types: new Map(),
            symbols: {
                reflection: Symbol("reflection"),
            }
        };
    }
    return globalObj.__FABLE_CORE__;
}();
function setType(fullName, cons) {
    fableGlobal.types.set(fullName, cons);
}

var _Symbol = (fableGlobal.symbols);

var NonDeclaredType = (function () {
    function NonDeclaredType(kind, definition, generics) {
        this.kind = kind;
        this.definition = definition;
        this.generics = generics;
    }
    NonDeclaredType.prototype.Equals = function (other) {
        if (this.kind === other.kind && this.definition === other.definition) {
            return typeof this.generics === "object"
                ? equalsRecords(this.generics, other.generics)
                : this.generics === other.generics;
        }
        return false;
    };
    return NonDeclaredType;
}());
var Any = new NonDeclaredType("Any");
var Unit = new NonDeclaredType("Unit");
function Option(t) {
    return new NonDeclaredType("Option", null, t);
}
function FableArray(t, isTypedArray) {
    if (isTypedArray === void 0) { isTypedArray = false; }
    var def = null, genArg = null;
    if (isTypedArray) {
        def = t;
    }
    else {
        genArg = t;
    }
    return new NonDeclaredType("Array", def, genArg);
}
function Tuple(ts) {
    return new NonDeclaredType("Tuple", null, ts);
}
function GenericParam(definition) {
    return new NonDeclaredType("GenericParam", definition);
}
function Interface(definition) {
    return new NonDeclaredType("Interface", definition);
}
function makeGeneric(typeDef, genArgs) {
    return new NonDeclaredType("GenericType", typeDef, genArgs);
}



function hasInterface(obj, interfaceName) {
    if (interfaceName === "System.Collections.Generic.IEnumerable") {
        return typeof obj[Symbol.iterator] === "function";
    }
    else if (typeof obj[_Symbol.reflection] === "function") {
        var interfaces = obj[_Symbol.reflection]().interfaces;
        return Array.isArray(interfaces) && interfaces.indexOf(interfaceName) > -1;
    }
    return false;
}
function getPropertyNames(obj) {
    if (obj == null) {
        return [];
    }
    var propertyMap = typeof obj[_Symbol.reflection] === "function" ? obj[_Symbol.reflection]().properties : obj;
    return Object.getOwnPropertyNames(propertyMap);
}

function getRestParams(args, idx) {
    for (var _len = args.length, restArgs = Array(_len > idx ? _len - idx : 0), _key = idx; _key < _len; _key++)
        restArgs[_key - idx] = args[_key];
    return restArgs;
}
function toString$2(o) {
    return o != null && typeof o.ToString == "function" ? o.ToString() : String(o);
}

function equals(x, y) {
    if (x === y)
        return true;
    else if (x == null)
        return y == null;
    else if (y == null)
        return false;
    else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y))
        return false;
    else if (typeof x.Equals === "function")
        return x.Equals(y);
    else if (Array.isArray(x)) {
        if (x.length != y.length)
            return false;
        for (var i = 0; i < x.length; i++)
            if (!equals(x[i], y[i]))
                return false;
        return true;
    }
    else if (ArrayBuffer.isView(x)) {
        if (x.byteLength !== y.byteLength)
            return false;
        var dv1 = new DataView(x.buffer), dv2 = new DataView(y.buffer);
        for (var i = 0; i < x.byteLength; i++)
            if (dv1.getUint8(i) !== dv2.getUint8(i))
                return false;
        return true;
    }
    else if (x instanceof Date)
        return x.getTime() == y.getTime();
    else
        return false;
}
function compare(x, y) {
    if (x === y)
        return 0;
    if (x == null)
        return y == null ? 0 : -1;
    else if (y == null)
        return 1;
    else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y))
        return -1;
    else if (typeof x.CompareTo === "function")
        return x.CompareTo(y);
    else if (Array.isArray(x)) {
        if (x.length != y.length)
            return x.length < y.length ? -1 : 1;
        for (var i = 0, j = 0; i < x.length; i++)
            if ((j = compare(x[i], y[i])) !== 0)
                return j;
        return 0;
    }
    else if (ArrayBuffer.isView(x)) {
        if (x.byteLength != y.byteLength)
            return x.byteLength < y.byteLength ? -1 : 1;
        var dv1 = new DataView(x.buffer), dv2 = new DataView(y.buffer);
        for (var i = 0, b1 = 0, b2 = 0; i < x.byteLength; i++) {
            b1 = dv1.getUint8(i), b2 = dv2.getUint8(i);
            if (b1 < b2)
                return -1;
            if (b1 > b2)
                return 1;
        }
        return 0;
    }
    else if (x instanceof Date)
        return compare(x.getTime(), y.getTime());
    else
        return x < y ? -1 : 1;
}
function equalsRecords(x, y) {
    if (x === y) {
        return true;
    }
    else {
        var keys = getPropertyNames(x);
        for (var i = 0; i < keys.length; i++) {
            if (!equals(x[keys[i]], y[keys[i]]))
                return false;
        }
        return true;
    }
}
function compareRecords(x, y) {
    if (x === y) {
        return 0;
    }
    else {
        var keys = getPropertyNames(x);
        for (var i = 0; i < keys.length; i++) {
            var res = compare(x[keys[i]], y[keys[i]]);
            if (res !== 0)
                return res;
        }
        return 0;
    }
}
function equalsUnions(x, y) {
    if (x === y) {
        return true;
    }
    else if (x.Case !== y.Case) {
        return false;
    }
    else {
        for (var i = 0; i < x.Fields.length; i++) {
            if (!equals(x.Fields[i], y.Fields[i]))
                return false;
        }
        return true;
    }
}
function compareUnions(x, y) {
    if (x === y) {
        return 0;
    }
    else {
        var res = compare(x.Case, y.Case);
        if (res !== 0)
            return res;
        for (var i = 0; i < x.Fields.length; i++) {
            res = compare(x.Fields[i], y.Fields[i]);
            if (res !== 0)
                return res;
        }
        return 0;
    }
}
function createDisposable(f) {
    return _a = {
            Dispose: f
        },
        _a[_Symbol.reflection] = function () { return { interfaces: ["System.IDisposable"] }; },
        _a;
    var _a;
}
function createObj(fields) {
    var iter = fields[Symbol.iterator]();
    var cur = iter.next(), o = {};
    while (!cur.done) {
        o[cur.value[0]] = cur.value[1];
        cur = iter.next();
    }
    return o;
}

function round(value, digits) {
    if (digits === void 0) { digits = 0; }
    var m = Math.pow(10, digits);
    var n = +(digits ? value * m : value).toFixed(8);
    var i = Math.floor(n), f = n - i;
    var e = 1e-8;
    var r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 == 0) ? i : i + 1) : Math.round(n);
    return digits ? r / m : r;
}
function randomNext(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
}
function defaultArg(arg, defaultValue, f) {
    return arg == null ? defaultValue : (f != null ? f(arg) : arg);
}

function addRangeInPlace(range, xs) {
    var iter = range[Symbol.iterator]();
    var cur = iter.next();
    while (!cur.done) {
        xs.push(cur.value);
        cur = iter.next();
    }
}






function unzip(xs) {
    var bs = new Array(xs.length), cs = new Array(xs.length);
    for (var i = 0; i < xs.length; i++) {
        bs[i] = xs[i][0];
        cs[i] = xs[i][1];
    }
    return [bs, cs];
}

function ofArray$1(args, base) {
    var acc = base || new List$1();
    for (var i = args.length - 1; i >= 0; i--) {
        acc = new List$1(args[i], acc);
    }
    return acc;
}
var List$1 = (function () {
    function List(head, tail) {
        this.head = head;
        this.tail = tail;
    }
    List.prototype.ToString = function () {
        return "[" + Array.from(this).map(toString$2).join("; ") + "]";
    };
    List.prototype.Equals = function (x) {
        if (this === x) {
            return true;
        }
        else {
            var iter1 = this[Symbol.iterator](), iter2 = x[Symbol.iterator]();
            for (;;) {
                var cur1 = iter1.next(), cur2 = iter2.next();
                if (cur1.done)
                    return cur2.done ? true : false;
                else if (cur2.done)
                    return false;
                else if (!equals(cur1.value, cur2.value))
                    return false;
            }
        }
    };
    List.prototype.CompareTo = function (x) {
        if (this === x) {
            return 0;
        }
        else {
            var acc = 0;
            var iter1 = this[Symbol.iterator](), iter2 = x[Symbol.iterator]();
            for (;;) {
                var cur1 = iter1.next(), cur2 = iter2.next();
                if (cur1.done)
                    return cur2.done ? acc : -1;
                else if (cur2.done)
                    return 1;
                else {
                    acc = compare(cur1.value, cur2.value);
                    if (acc != 0)
                        return acc;
                }
            }
        }
    };
    Object.defineProperty(List.prototype, "length", {
        get: function () {
            var cur = this, acc = 0;
            while (cur.tail != null) {
                cur = cur.tail;
                acc++;
            }
            return acc;
        },
        enumerable: true,
        configurable: true
    });
    List.prototype[Symbol.iterator] = function () {
        var cur = this;
        return {
            next: function () {
                var tmp = cur;
                cur = cur.tail;
                return { done: tmp.tail == null, value: tmp.head };
            }
        };
    };
    List.prototype[_Symbol.reflection] = function () {
        return {
            type: "Microsoft.FSharp.Collections.FSharpList",
            interfaces: ["System.IEquatable", "System.IComparable"]
        };
    };
    return List;
}());

var Enumerator = (function () {
    function Enumerator(iter) {
        this.iter = iter;
    }
    Enumerator.prototype.MoveNext = function () {
        var cur = this.iter.next();
        this.current = cur.value;
        return !cur.done;
    };
    Object.defineProperty(Enumerator.prototype, "Current", {
        get: function () {
            return this.current;
        },
        enumerable: true,
        configurable: true
    });
    Enumerator.prototype.Reset = function () {
        throw new Error("JS iterators cannot be reset");
    };
    Enumerator.prototype.Dispose = function () { };
    return Enumerator;
}());


function __failIfNone(res) {
    if (res == null)
        throw new Error("Seq did not contain any matching element");
    return res;
}
function toList(xs) {
    return foldBack(function (x, acc) {
        return new List$1(x, acc);
    }, xs, new List$1());
}

function ofArray$$1(xs) {
    return delay(function () { return unfold(function (i) { return i < xs.length ? [xs[i], i + 1] : null; }, 0); });
}
function append(xs, ys) {
    return delay(function () {
        var firstDone = false;
        var i = xs[Symbol.iterator]();
        var iters = [i, null];
        return unfold(function () {
            var cur;
            if (!firstDone) {
                cur = iters[0].next();
                if (!cur.done) {
                    return [cur.value, iters];
                }
                else {
                    firstDone = true;
                    iters = [null, ys[Symbol.iterator]()];
                }
            }
            cur = iters[1].next();
            return !cur.done ? [cur.value, iters] : null;
        }, iters);
    });
}

function averageBy(f, xs) {
    var count = 1;
    var sum = reduce(function (acc, x) {
        count++;
        return (count === 2 ? f(acc) : acc) + f(x);
    }, xs);
    return sum / count;
}
function concat(xs) {
    return delay(function () {
        var iter = xs[Symbol.iterator]();
        var output = null;
        return unfold(function (innerIter) {
            var hasFinished = false;
            while (!hasFinished) {
                if (innerIter == null) {
                    var cur = iter.next();
                    if (!cur.done) {
                        innerIter = cur.value[Symbol.iterator]();
                    }
                    else {
                        hasFinished = true;
                    }
                }
                else {
                    var cur = innerIter.next();
                    if (!cur.done) {
                        output = cur.value;
                        hasFinished = true;
                    }
                    else {
                        innerIter = null;
                    }
                }
            }
            return innerIter != null && output != null ? [output, innerIter] : null;
        }, null);
    });
}
function collect(f, xs) {
    return concat(map$3(f, xs));
}
function choose(f, xs) {
    var trySkipToNext = function (iter) {
        var cur = iter.next();
        if (!cur.done) {
            var y = f(cur.value);
            return y != null ? [y, iter] : trySkipToNext(iter);
        }
        return void 0;
    };
    return delay(function () {
        return unfold(function (iter) {
            return trySkipToNext(iter);
        }, xs[Symbol.iterator]());
    });
}
function compareWith(f, xs, ys) {
    var nonZero = tryFind(function (i) { return i != 0; }, map2(function (x, y) { return f(x, y); }, xs, ys));
    return nonZero != null ? nonZero : count(xs) - count(ys);
}
function delay(f) {
    return _a = {},
        _a[Symbol.iterator] = function () { return f()[Symbol.iterator](); },
        _a;
    var _a;
}
function empty() {
    return unfold(function () { return void 0; });
}
function enumerateWhile(cond, xs) {
    return concat(unfold(function () { return cond() ? [xs, true] : null; }));
}




function exists(f, xs) {
    function aux(iter) {
        var cur = iter.next();
        return !cur.done && (f(cur.value) || aux(iter));
    }
    return aux(xs[Symbol.iterator]());
}

function filter(f, xs) {
    function trySkipToNext(iter) {
        var cur = iter.next();
        while (!cur.done) {
            if (f(cur.value)) {
                return [cur.value, iter];
            }
            cur = iter.next();
        }
        return void 0;
    }
    return delay(function () { return unfold(trySkipToNext, xs[Symbol.iterator]()); });
}

function fold(f, acc, xs) {
    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {
        return xs.reduce(f, acc);
    }
    else {
        var cur = void 0;
        for (var i = 0, iter = xs[Symbol.iterator]();; i++) {
            cur = iter.next();
            if (cur.done)
                break;
            acc = f(acc, cur.value, i);
        }
        return acc;
    }
}
function foldBack(f, xs, acc) {
    var arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);
    for (var i = arr.length - 1; i >= 0; i--) {
        acc = f(arr[i], acc, i);
    }
    return acc;
}


function forAll(f, xs) {
    return fold(function (acc, x) { return acc && f(x); }, true, xs);
}

function tryHead(xs) {
    var iter = xs[Symbol.iterator]();
    var cur = iter.next();
    return cur.done ? null : cur.value;
}
function head(xs) {
    return __failIfNone(tryHead(xs));
}
function initialize(n, f) {
    return delay(function () {
        return unfold(function (i) { return i < n ? [f(i), i + 1] : null; }, 0);
    });
}

function tryItem(i, xs) {
    if (i < 0)
        return null;
    if (Array.isArray(xs) || ArrayBuffer.isView(xs))
        return i < xs.length ? xs[i] : null;
    for (var j = 0, iter = xs[Symbol.iterator]();; j++) {
        var cur = iter.next();
        if (cur.done)
            return null;
        if (j === i)
            return cur.value;
    }
}

function iterate(f, xs) {
    fold(function (_, x) { return f(x); }, null, xs);
}

function iterateIndexed(f, xs) {
    fold(function (_, x, i) { return f(i, x); }, null, xs);
}

function isEmpty(xs) {
    var i = xs[Symbol.iterator]();
    return i.next().done;
}
function tryLast(xs) {
    try {
        return reduce(function (_, x) { return x; }, xs);
    }
    catch (err) {
        return null;
    }
}
function last(xs) {
    return __failIfNone(tryLast(xs));
}
function count(xs) {
    return Array.isArray(xs) || ArrayBuffer.isView(xs)
        ? xs.length
        : fold(function (acc, x) { return acc + 1; }, 0, xs);
}
function map$3(f, xs) {
    return delay(function () { return unfold(function (iter) {
        var cur = iter.next();
        return !cur.done ? [f(cur.value), iter] : null;
    }, xs[Symbol.iterator]()); });
}
function mapIndexed(f, xs) {
    return delay(function () {
        var i = 0;
        return unfold(function (iter) {
            var cur = iter.next();
            return !cur.done ? [f(i++, cur.value), iter] : null;
        }, xs[Symbol.iterator]());
    });
}
function map2(f, xs, ys) {
    return delay(function () {
        var iter1 = xs[Symbol.iterator]();
        var iter2 = ys[Symbol.iterator]();
        return unfold(function () {
            var cur1 = iter1.next(), cur2 = iter2.next();
            return !cur1.done && !cur2.done ? [f(cur1.value, cur2.value), null] : null;
        });
    });
}










function rangeStep(first, step, last) {
    if (step === 0)
        throw new Error("Step cannot be 0");
    return delay(function () { return unfold(function (x) { return step > 0 && x <= last || step < 0 && x >= last ? [x, x + step] : null; }, first); });
}

function range(first, last) {
    return rangeStep(first, 1, last);
}

function reduce(f, xs) {
    if (Array.isArray(xs) || ArrayBuffer.isView(xs))
        return xs.reduce(f);
    var iter = xs[Symbol.iterator]();
    var cur = iter.next();
    if (cur.done)
        throw new Error("Seq was empty");
    var acc = cur.value;
    for (;;) {
        cur = iter.next();
        if (cur.done)
            break;
        acc = f(acc, cur.value);
    }
    return acc;
}


function reverse(xs) {
    var ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);
    return ofArray$$1(ar.reverse());
}
function scan(f, seed, xs) {
    return delay(function () {
        var iter = xs[Symbol.iterator]();
        return unfold(function (acc) {
            if (acc == null)
                return [seed, seed];
            var cur = iter.next();
            if (!cur.done) {
                acc = f(acc, cur.value);
                return [acc, acc];
            }
            return void 0;
        }, null);
    });
}

function singleton(x) {
    return unfold(function (x) { return x != null ? [x, null] : null; }, x);
}
function skip(n, xs) {
    return _a = {},
        _a[Symbol.iterator] = function () {
            var iter = xs[Symbol.iterator]();
            for (var i = 1; i <= n; i++)
                if (iter.next().done)
                    throw new Error("Seq has not enough elements");
            return iter;
        },
        _a;
    var _a;
}
function skipWhile(f, xs) {
    return delay(function () {
        var hasPassed = false;
        return filter(function (x) { return hasPassed || (hasPassed = !f(x)); }, xs);
    });
}
function sortWith(f, xs) {
    var ys = Array.from(xs);
    return ofArray$$1(ys.sort(f));
}

function sumBy(f, xs) {
    return fold(function (acc, x) { return acc + f(x); }, 0, xs);
}

function take(n, xs, truncate) {
    if (truncate === void 0) { truncate = false; }
    return delay(function () {
        var iter = xs[Symbol.iterator]();
        return unfold(function (i) {
            if (i < n) {
                var cur = iter.next();
                if (!cur.done)
                    return [cur.value, i + 1];
                if (!truncate)
                    throw new Error("Seq has not enough elements");
            }
            return void 0;
        }, 0);
    });
}
function truncate(n, xs) {
    return take(n, xs, true);
}
function takeWhile(f, xs) {
    return delay(function () {
        var iter = xs[Symbol.iterator]();
        return unfold(function (i) {
            var cur = iter.next();
            if (!cur.done && f(cur.value))
                return [cur.value, null];
            return void 0;
        }, 0);
    });
}
function tryFind(f, xs, defaultValue) {
    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {
        var cur = iter.next();
        if (cur.done)
            return defaultValue === void 0 ? null : defaultValue;
        if (f(cur.value, i))
            return cur.value;
    }
}
function find(f, xs) {
    return __failIfNone(tryFind(f, xs));
}


function tryFindIndex(f, xs) {
    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {
        var cur = iter.next();
        if (cur.done)
            return null;
        if (f(cur.value, i))
            return i;
    }
}
function findIndex(f, xs) {
    return __failIfNone(tryFindIndex(f, xs));
}


function tryPick(f, xs) {
    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {
        var cur = iter.next();
        if (cur.done)
            break;
        var y = f(cur.value, i);
        if (y != null)
            return y;
    }
    return void 0;
}

function unfold(f, acc) {
    return _a = {},
        _a[Symbol.iterator] = function () {
            return {
                next: function () {
                    var res = f(acc);
                    if (res != null) {
                        acc = res[1];
                        return { done: false, value: res[0] };
                    }
                    return { done: true };
                }
            };
        },
        _a;
    var _a;
}
function zip(xs, ys) {
    return map2(function (x, y) { return [x, y]; }, xs, ys);
}

function escape(str) {
    return str.replace(/[\-\[\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}

var Long = (function () {
    function Long(low, high, unsigned) {
        this.eq = this.equals;
        this.neq = this.notEquals;
        this.lt = this.lessThan;
        this.lte = this.lessThanOrEqual;
        this.gt = this.greaterThan;
        this.gte = this.greaterThanOrEqual;
        this.comp = this.compare;
        this.neg = this.negate;
        this.abs = this.absolute;
        this.sub = this.subtract;
        this.mul = this.multiply;
        this.div = this.divide;
        this.mod = this.modulo;
        this.shl = this.shiftLeft;
        this.shr = this.shiftRight;
        this.shru = this.shiftRightUnsigned;
        this.Equals = this.equals;
        this.CompareTo = this.compare;
        this.ToString = this.toString;
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
    }
    Long.prototype.toInt = function () {
        return this.unsigned ? this.low >>> 0 : this.low;
    };
    Long.prototype.toNumber = function () {
        if (this.unsigned)
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    Long.prototype.toString = function (radix) {
        if (radix === void 0) { radix = 10; }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');
        if (this.isZero())
            return '0';
        if (this.isNegative()) {
            if (this.eq(MIN_VALUE)) {
                var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            }
            else
                return '-' + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
                return digits + result;
            else {
                while (digits.length < 6)
                    digits = '0' + digits;
                result = '' + digits + result;
            }
        }
    };
    Long.prototype.getHighBits = function () {
        return this.high;
    };
    Long.prototype.getHighBitsUnsigned = function () {
        return this.high >>> 0;
    };
    Long.prototype.getLowBits = function () {
        return this.low;
    };
    Long.prototype.getLowBitsUnsigned = function () {
        return this.low >>> 0;
    };
    Long.prototype.getNumBitsAbs = function () {
        if (this.isNegative())
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
            if ((val & (1 << bit)) != 0)
                break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };
    Long.prototype.isZero = function () {
        return this.high === 0 && this.low === 0;
    };
    Long.prototype.isNegative = function () {
        return !this.unsigned && this.high < 0;
    };
    Long.prototype.isPositive = function () {
        return this.unsigned || this.high >= 0;
    };
    Long.prototype.isOdd = function () {
        return (this.low & 1) === 1;
    };
    Long.prototype.isEven = function () {
        return (this.low & 1) === 0;
    };
    Long.prototype.equals = function (other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };
    Long.prototype.notEquals = function (other) {
        return !this.eq(other);
    };
    Long.prototype.lessThan = function (other) {
        return this.comp(other) < 0;
    };
    Long.prototype.lessThanOrEqual = function (other) {
        return this.comp(other) <= 0;
    };
    Long.prototype.greaterThan = function (other) {
        return this.comp(other) > 0;
    };
    Long.prototype.greaterThanOrEqual = function (other) {
        return this.comp(other) >= 0;
    };
    Long.prototype.compare = function (other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.eq(other))
            return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
    };
    Long.prototype.negate = function () {
        if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
        return this.not().add(ONE);
    };
    Long.prototype.absolute = function () {
        if (!this.unsigned && this.isNegative())
            return this.negate();
        else
            return this;
    };
    Long.prototype.add = function (addend) {
        if (!isLong(addend))
            addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };
    Long.prototype.subtract = function (subtrahend) {
        if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };
    Long.prototype.multiply = function (multiplier) {
        if (this.isZero())
            return ZERO;
        if (!isLong(multiplier))
            multiplier = fromValue(multiplier);
        if (multiplier.isZero())
            return ZERO;
        if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
            if (multiplier.isNegative())
                return this.neg().mul(multiplier.neg());
            else
                return this.neg().mul(multiplier).neg();
        }
        else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };
    Long.prototype.divide = function (divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        if (divisor.isZero())
            throw Error('division by zero');
        if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
        var approx = 0, rem = ZERO, res = ZERO;
        if (!this.unsigned) {
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                    return MIN_VALUE;
                else if (divisor.eq(MIN_VALUE))
                    return ONE;
                else {
                    var halfThis = this.shr(1);
                    var approx_1 = halfThis.div(divisor).shl(1);
                    if (approx_1.eq(ZERO)) {
                        return divisor.isNegative() ? ONE : NEG_ONE;
                    }
                    else {
                        rem = this.sub(divisor.mul(approx_1));
                        res = approx_1.add(rem.div(divisor));
                        return res;
                    }
                }
            }
            else if (divisor.eq(MIN_VALUE))
                return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative())
                    return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            }
            else if (divisor.isNegative())
                return this.div(divisor.neg()).neg();
            res = ZERO;
        }
        else {
            if (!divisor.unsigned)
                divisor = divisor.toUnsigned();
            if (divisor.gt(this))
                return UZERO;
            if (divisor.gt(this.shru(1)))
                return UONE;
            res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }
            if (approxRes.isZero())
                approxRes = ONE;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };
    Long.prototype.modulo = function (divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };
    
    Long.prototype.not = function () {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };
    
    Long.prototype.and = function (other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    Long.prototype.or = function (other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    Long.prototype.xor = function (other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    Long.prototype.shiftLeft = function (numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits = numBits & 63;
        if (numBits === 0)
            return this;
        else if (numBits < 32)
            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
        else
            return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };
    Long.prototype.shiftRight = function (numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits = numBits & 63;
        if (numBits === 0)
            return this;
        else if (numBits < 32)
            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
        else
            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
    };
    Long.prototype.shiftRightUnsigned = function (numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits = numBits & 63;
        if (numBits === 0)
            return this;
        else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            }
            else if (numBits === 32)
                return fromBits(high, 0, this.unsigned);
            else
                return fromBits(high >>> (numBits - 32), 0, this.unsigned);
        }
    };
    Long.prototype.toSigned = function () {
        if (!this.unsigned)
            return this;
        return fromBits(this.low, this.high, false);
    };
    Long.prototype.toUnsigned = function () {
        if (this.unsigned)
            return this;
        return fromBits(this.low, this.high, true);
    };
    Long.prototype.toBytes = function (le) {
        return le ? this.toBytesLE() : this.toBytesBE();
    };
    Long.prototype.toBytesLE = function () {
        var hi = this.high, lo = this.low;
        return [
            lo & 0xff,
            (lo >>> 8) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>> 24) & 0xff,
            hi & 0xff,
            (hi >>> 8) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>> 24) & 0xff
        ];
    };
    Long.prototype.toBytesBE = function () {
        var hi = this.high, lo = this.low;
        return [
            (hi >>> 24) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>> 8) & 0xff,
            hi & 0xff,
            (lo >>> 24) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>> 8) & 0xff,
            lo & 0xff
        ];
    };
    Long.prototype[_Symbol.reflection] = function () {
        return {
            type: "System.Int64",
            interfaces: ["FSharpRecord", "System.IComparable"],
            properties: {
                low: "number",
                high: "number",
                unsigned: "boolean"
            }
        };
    };
    return Long;
}());
var INT_CACHE = {};
var UINT_CACHE = {};
function isLong(obj) {
    return (obj && obj instanceof Long);
}
function fromInt(value, unsigned) {
    if (unsigned === void 0) { unsigned = false; }
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    }
    else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}
function fromNumber(value, unsigned) {
    if (unsigned === void 0) { unsigned = false; }
    if (isNaN(value) || !isFinite(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    }
    else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}
var pow_dbl = Math.pow;
function fromString(str, unsigned, radix) {
    if (unsigned === void 0) { unsigned = false; }
    if (radix === void 0) { radix = 10; }
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        radix = unsigned,
            unsigned = false;
    }
    else {
        unsigned = !!unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    var p = str.indexOf('-');
    if (p > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        }
        else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}
function fromValue(val) {
    if (val instanceof Long)
        return val;
    if (typeof val === 'number')
        return fromNumber(val);
    if (typeof val === 'string')
        return fromString(val);
    return fromBits(val.low, val.high, val.unsigned);
}
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
var UZERO = fromInt(0, true);
var ONE = fromInt(1);
var UONE = fromInt(1, true);
var NEG_ONE = fromInt(-1);
var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

function totalDays(ts) {
    return ts / 86400000;
}

function parse(v, kind) {
    if (kind == null) {
        kind = typeof v == "string" && v.slice(-1) == "Z" ? 1 : 2;
    }
    var date = (v == null) ? new Date() : new Date(v);
    if (kind === 2) {
        date.kind = kind;
    }
    if (isNaN(date.getTime())) {
        throw new Error("The string is not a valid Date.");
    }
    return date;
}

function create$3(year, month, day, h, m, s, ms, kind) {
    if (h === void 0) { h = 0; }
    if (m === void 0) { m = 0; }
    if (s === void 0) { s = 0; }
    if (ms === void 0) { ms = 0; }
    if (kind === void 0) { kind = 2; }
    var date;
    if (kind === 2) {
        date = new Date(year, month - 1, day, h, m, s, ms);
        date.kind = kind;
    }
    else {
        date = new Date(Date.UTC(year, month - 1, day, h, m, s, ms));
    }
    if (isNaN(date.getTime())) {
        throw new Error("The parameters describe an unrepresentable Date.");
    }
    return date;
}
function now() {
    return parse();
}










function hour(d) {
    return d.kind === 2 ? d.getHours() : d.getUTCHours();
}
function millisecond(d) {
    return d.kind === 2 ? d.getMilliseconds() : d.getUTCMilliseconds();
}
function minute(d) {
    return d.kind === 2 ? d.getMinutes() : d.getUTCMinutes();
}

function second(d) {
    return d.kind === 2 ? d.getSeconds() : d.getUTCSeconds();
}














function subtract$$1(d, that) {
    return typeof that == "number"
        ? parse(d.getTime() - that, d.kind || 1)
        : d.getTime() - that.getTime();
}








function op_Subtraction(x, y) {
    return subtract$$1(x, y);
}

var fsFormatRegExp = /(^|[^%])%([0+ ]*)(-?\d+)?(?:\.(\d+))?(\w)/;



function toHex(value) {
    return value < 0
        ? "ff" + (16777215 - (Math.abs(value) - 1)).toString(16)
        : value.toString(16);
}
function fsFormat(str) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var _cont;
    function isObject(x) {
        return x !== null && typeof x === "object" && !(x instanceof Number) && !(x instanceof String) && !(x instanceof Boolean);
    }
    function formatOnce(str, rep) {
        return str.replace(fsFormatRegExp, function (_, prefix, flags, pad, precision, format) {
            switch (format) {
                case "f":
                case "F":
                    rep = rep.toFixed(precision || 6);
                    break;
                case "g":
                case "G":
                    rep = rep.toPrecision(precision);
                    break;
                case "e":
                case "E":
                    rep = rep.toExponential(precision);
                    break;
                case "O":
                    rep = toString$2(rep);
                    break;
                case "A":
                    try {
                        rep = JSON.stringify(rep, function (k, v) {
                            return v && v[Symbol.iterator] && !Array.isArray(v) && isObject(v) ? Array.from(v)
                                : v && typeof v.ToString === "function" ? toString$2(v) : v;
                        });
                    }
                    catch (err) {
                        rep = "{" + Object.getOwnPropertyNames(rep).map(function (k) { return k + ": " + String(rep[k]); }).join(", ") + "}";
                    }
                    break;
                case "x":
                    rep = toHex(Number(rep));
                    break;
                case "X":
                    rep = toHex(Number(rep)).toUpperCase();
                    break;
            }
            var plusPrefix = flags.indexOf("+") >= 0 && parseInt(rep) >= 0;
            if (!isNaN(pad = parseInt(pad))) {
                var ch = pad >= 0 && flags.indexOf("0") >= 0 ? "0" : " ";
                rep = padLeft(rep, Math.abs(pad) - (plusPrefix ? 1 : 0), ch, pad < 0);
            }
            var once = prefix + (plusPrefix ? "+" + rep : rep);
            return once.replace(/%/g, "%%");
        });
    }
    function makeFn(str) {
        return function (rep) {
            var str2 = formatOnce(str, rep);
            return fsFormatRegExp.test(str2)
                ? makeFn(str2) : _cont(str2.replace(/%%/g, "%"));
        };
    }
    if (args.length === 0) {
        return function (cont) {
            _cont = cont;
            return fsFormatRegExp.test(str) ? makeFn(str) : _cont(str);
        };
    }
    else {
        for (var i = 0; i < args.length; i++) {
            str = formatOnce(str, args[i]);
        }
        return str.replace(/%%/g, "%");
    }
}

function endsWith(str, search) {
    var idx = str.lastIndexOf(search);
    return idx >= 0 && idx == str.length - search.length;
}

function insert(str, startIndex, value) {
    if (startIndex < 0 || startIndex > str.length) {
        throw new Error("startIndex is negative or greater than the length of this instance.");
    }
    return str.substring(0, startIndex) + value + str.substring(startIndex);
}
function isNullOrEmpty(str) {
    return typeof str !== "string" || str.length == 0;
}
function isNullOrWhiteSpace(str) {
    return typeof str !== "string" || /^\s*$/.test(str);
}
function join(delimiter, xs) {
    xs = typeof xs == "string" ? getRestParams(arguments, 1) : xs;
    return (Array.isArray(xs) ? xs : Array.from(xs)).join(delimiter);
}
function newGuid() {
    var uuid = "";
    for (var i = 0; i < 32; i++) {
        var random = Math.random() * 16 | 0;
        if (i === 8 || i === 12 || i === 16 || i === 20)
            uuid += "-";
        uuid += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);
    }
    return uuid;
}
function padLeft(str, len, ch, isRight) {
    ch = ch || " ";
    str = String(str);
    len = len - str.length;
    for (var i = -1; ++i < len;)
        str = isRight ? str + ch : ch + str;
    return str;
}


function replace$$1(str, search, replace$$1) {
    return str.replace(new RegExp(escape(search), "g"), replace$$1);
}

function split$$1(str, splitters, count, removeEmpty) {
    count = typeof count == "number" ? count : null;
    removeEmpty = typeof removeEmpty == "number" ? removeEmpty : null;
    if (count < 0)
        throw new Error("Count cannot be less than zero");
    if (count === 0)
        return [];
    splitters = Array.isArray(splitters) ? splitters : getRestParams(arguments, 1);
    splitters = splitters.map(function (x) { return escape(x); });
    splitters = splitters.length > 0 ? splitters : [" "];
    var m;
    var i = 0;
    var splits = [];
    var reg = new RegExp(splitters.join("|"), "g");
    while ((count == null || count > 1) && (m = reg.exec(str)) !== null) {
        if (!removeEmpty || (m.index - i) > 0) {
            count = count != null ? count - 1 : count;
            splits.push(str.substring(i, m.index));
        }
        i = reg.lastIndex;
    }
    if (!removeEmpty || (str.length - i) > 0)
        splits.push(str.substring(i));
    return splits;
}
function trim(str, side) {
    var chars = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        chars[_i - 2] = arguments[_i];
    }
    if (side == "both" && chars.length == 0)
        return str.trim();
    if (side == "start" || side == "both") {
        var reg = chars.length == 0 ? /^\s+/ : new RegExp("^[" + escape(chars.join("")) + "]+");
        str = str.replace(reg, "");
    }
    if (side == "end" || side == "both") {
        var reg = chars.length == 0 ? /\s+$/ : new RegExp("[" + escape(chars.join("")) + "]+$");
        str = str.replace(reg, "");
    }
    return str;
}

var GenericComparer = (function () {
    function GenericComparer(f) {
        this.Compare = f || compare;
    }
    GenericComparer.prototype[_Symbol.reflection] = function () {
        return { interfaces: ["System.IComparer"] };
    };
    return GenericComparer;
}());

function groupBy$1(f, xs) {
    var keys = [], iter = xs[Symbol.iterator]();
    var acc = create$6(), cur = iter.next();
    while (!cur.done) {
        var k = f(cur.value), vs = tryFind$1(k, acc);
        if (vs == null) {
            keys.push(k);
            acc = add$3(k, [cur.value], acc);
        }
        else {
            vs.push(cur.value);
        }
        cur = iter.next();
    }
    return keys.map(function (k) { return [k, acc.get(k)]; });
}
function countBy(f, xs) {
    return groupBy$1(f, xs).map(function (kv) { return [kv[0], kv[1].length]; });
}
var MapTree = (function () {
    function MapTree(caseName, fields) {
        this.Case = caseName;
        this.Fields = fields;
    }
    return MapTree;
}());
function tree_sizeAux(acc, m) {
    return m.Case === "MapOne"
        ? acc + 1
        : m.Case === "MapNode"
            ? tree_sizeAux(tree_sizeAux(acc + 1, m.Fields[2]), m.Fields[3])
            : acc;
}
function tree_size(x) {
    return tree_sizeAux(0, x);
}
function tree_empty() {
    return new MapTree("MapEmpty", []);
}
function tree_height$1(_arg1) {
    return _arg1.Case === "MapOne" ? 1 : _arg1.Case === "MapNode" ? _arg1.Fields[4] : 0;
}
function tree_mk$1(l, k, v, r) {
    var matchValue = [l, r];
    var $target1 = function () {
        var hl = tree_height$1(l);
        var hr = tree_height$1(r);
        var m = hl < hr ? hr : hl;
        return new MapTree("MapNode", [k, v, l, r, m + 1]);
    };
    if (matchValue[0].Case === "MapEmpty") {
        if (matchValue[1].Case === "MapEmpty") {
            return new MapTree("MapOne", [k, v]);
        }
        else {
            return $target1();
        }
    }
    else {
        return $target1();
    }
}

function tree_rebalance$1(t1, k, v, t2) {
    var t1h = tree_height$1(t1);
    var t2h = tree_height$1(t2);
    if (t2h > t1h + 2) {
        if (t2.Case === "MapNode") {
            if (tree_height$1(t2.Fields[2]) > t1h + 1) {
                if (t2.Fields[2].Case === "MapNode") {
                    return tree_mk$1(tree_mk$1(t1, k, v, t2.Fields[2].Fields[2]), t2.Fields[2].Fields[0], t2.Fields[2].Fields[1], tree_mk$1(t2.Fields[2].Fields[3], t2.Fields[0], t2.Fields[1], t2.Fields[3]));
                }
                else {
                    throw new Error("rebalance");
                }
            }
            else {
                return tree_mk$1(tree_mk$1(t1, k, v, t2.Fields[2]), t2.Fields[0], t2.Fields[1], t2.Fields[3]);
            }
        }
        else {
            throw new Error("rebalance");
        }
    }
    else {
        if (t1h > t2h + 2) {
            if (t1.Case === "MapNode") {
                if (tree_height$1(t1.Fields[3]) > t2h + 1) {
                    if (t1.Fields[3].Case === "MapNode") {
                        return tree_mk$1(tree_mk$1(t1.Fields[2], t1.Fields[0], t1.Fields[1], t1.Fields[3].Fields[2]), t1.Fields[3].Fields[0], t1.Fields[3].Fields[1], tree_mk$1(t1.Fields[3].Fields[3], k, v, t2));
                    }
                    else {
                        throw new Error("rebalance");
                    }
                }
                else {
                    return tree_mk$1(t1.Fields[2], t1.Fields[0], t1.Fields[1], tree_mk$1(t1.Fields[3], k, v, t2));
                }
            }
            else {
                throw new Error("rebalance");
            }
        }
        else {
            return tree_mk$1(t1, k, v, t2);
        }
    }
}
function tree_add$1(comparer, k, v, m) {
    if (m.Case === "MapOne") {
        var c = comparer.Compare(k, m.Fields[0]);
        if (c < 0) {
            return new MapTree("MapNode", [k, v, new MapTree("MapEmpty", []), m, 2]);
        }
        else if (c === 0) {
            return new MapTree("MapOne", [k, v]);
        }
        return new MapTree("MapNode", [k, v, m, new MapTree("MapEmpty", []), 2]);
    }
    else if (m.Case === "MapNode") {
        var c = comparer.Compare(k, m.Fields[0]);
        if (c < 0) {
            return tree_rebalance$1(tree_add$1(comparer, k, v, m.Fields[2]), m.Fields[0], m.Fields[1], m.Fields[3]);
        }
        else if (c === 0) {
            return new MapTree("MapNode", [k, v, m.Fields[2], m.Fields[3], m.Fields[4]]);
        }
        return tree_rebalance$1(m.Fields[2], m.Fields[0], m.Fields[1], tree_add$1(comparer, k, v, m.Fields[3]));
    }
    return new MapTree("MapOne", [k, v]);
}
function tree_find(comparer, k, m) {
    var res = tree_tryFind(comparer, k, m);
    if (res != null)
        return res;
    throw new Error("key not found");
}
function tree_tryFind(comparer, k, m) {
    if (m.Case === "MapOne") {
        var c = comparer.Compare(k, m.Fields[0]);
        return c === 0 ? m.Fields[1] : null;
    }
    else if (m.Case === "MapNode") {
        var c = comparer.Compare(k, m.Fields[0]);
        if (c < 0) {
            return tree_tryFind(comparer, k, m.Fields[2]);
        }
        else {
            if (c === 0) {
                return m.Fields[1];
            }
            else {
                return tree_tryFind(comparer, k, m.Fields[3]);
            }
        }
    }
    return null;
}
function tree_filter1(comparer, f, k, v, acc) {
    return f(k, v) ? tree_add$1(comparer, k, v, acc) : acc;
}
function tree_filterAux$1(comparer, f, s, acc) {
    return s.Case === "MapOne" ? tree_filter1(comparer, f, s.Fields[0], s.Fields[1], acc) : s.Case === "MapNode" ? tree_filterAux$1(comparer, f, s.Fields[3], tree_filter1(comparer, f, s.Fields[0], s.Fields[1], tree_filterAux$1(comparer, f, s.Fields[2], acc))) : acc;
}
function tree_filter$1(comparer, f, s) {
    return tree_filterAux$1(comparer, f, s, tree_empty());
}
function tree_mem$1(comparer, k, m) {
    if (m.Case === "MapOne") {
        return comparer.Compare(k, m.Fields[0]) === 0;
    }
    else if (m.Case === "MapNode") {
        var c = comparer.Compare(k, m.Fields[0]);
        if (c < 0) {
            return tree_mem$1(comparer, k, m.Fields[2]);
        }
        else {
            if (c === 0) {
                return true;
            }
            else {
                return tree_mem$1(comparer, k, m.Fields[3]);
            }
        }
    }
    else {
        return false;
    }
}
function tree_mkFromEnumerator$1(comparer, acc, e) {
    var cur = e.next();
    while (!cur.done) {
        acc = tree_add$1(comparer, cur.value[0], cur.value[1], acc);
        cur = e.next();
    }
    return acc;
}
function tree_ofSeq$1(comparer, c) {
    var ie = c[Symbol.iterator]();
    return tree_mkFromEnumerator$1(comparer, tree_empty(), ie);
}
function tree_collapseLHS$1(stack) {
    if (stack.tail != null) {
        if (stack.head.Case === "MapOne") {
            return stack;
        }
        else if (stack.head.Case === "MapNode") {
            return tree_collapseLHS$1(ofArray$1([
                stack.head.Fields[2],
                new MapTree("MapOne", [stack.head.Fields[0], stack.head.Fields[1]]),
                stack.head.Fields[3]
            ], stack.tail));
        }
        else {
            return tree_collapseLHS$1(stack.tail);
        }
    }
    else {
        return new List$1();
    }
}
function tree_mkIterator$1(s) {
    return { stack: tree_collapseLHS$1(new List$1(s, new List$1())), started: false };
}
function tree_moveNext$1(i) {
    function current(i) {
        if (i.stack.tail == null) {
            return null;
        }
        else if (i.stack.head.Case === "MapOne") {
            return [i.stack.head.Fields[0], i.stack.head.Fields[1]];
        }
        throw new Error("Please report error: Map iterator, unexpected stack for current");
    }
    if (i.started) {
        if (i.stack.tail == null) {
            return { done: true, value: null };
        }
        else {
            if (i.stack.head.Case === "MapOne") {
                i.stack = tree_collapseLHS$1(i.stack.tail);
                return {
                    done: i.stack.tail == null,
                    value: current(i)
                };
            }
            else {
                throw new Error("Please report error: Map iterator, unexpected stack for moveNext");
            }
        }
    }
    else {
        i.started = true;
        return {
            done: i.stack.tail == null,
            value: current(i)
        };
    }
    
}
var FableMap = (function () {
    function FableMap() {
    }
    FableMap.prototype.ToString = function () {
        return "map [" + Array.from(this).map(toString$2).join("; ") + "]";
    };
    FableMap.prototype.Equals = function (m2) {
        return this.CompareTo(m2) === 0;
    };
    FableMap.prototype.CompareTo = function (m2) {
        var _this = this;
        return this === m2 ? 0 : compareWith(function (kvp1, kvp2) {
            var c = _this.comparer.Compare(kvp1[0], kvp2[0]);
            return c !== 0 ? c : compare(kvp1[1], kvp2[1]);
        }, this, m2);
    };
    FableMap.prototype[Symbol.iterator] = function () {
        var i = tree_mkIterator$1(this.tree);
        return {
            next: function () { return tree_moveNext$1(i); }
        };
    };
    FableMap.prototype.entries = function () {
        return this[Symbol.iterator]();
    };
    FableMap.prototype.keys = function () {
        return map$3(function (kv) { return kv[0]; }, this);
    };
    FableMap.prototype.values = function () {
        return map$3(function (kv) { return kv[1]; }, this);
    };
    FableMap.prototype.get = function (k) {
        return tree_find(this.comparer, k, this.tree);
    };
    FableMap.prototype.has = function (k) {
        return tree_mem$1(this.comparer, k, this.tree);
    };
    FableMap.prototype.set = function (k, v) {
        throw new Error("not supported");
    };
    FableMap.prototype.delete = function (k) {
        throw new Error("not supported");
    };
    FableMap.prototype.clear = function () {
        throw new Error("not supported");
    };
    Object.defineProperty(FableMap.prototype, "size", {
        get: function () {
            return tree_size(this.tree);
        },
        enumerable: true,
        configurable: true
    });
    FableMap.prototype[_Symbol.reflection] = function () {
        return {
            type: "Microsoft.FSharp.Collections.FSharpMap",
            interfaces: ["System.IEquatable", "System.IComparable", "System.Collections.Generic.IDictionary"]
        };
    };
    return FableMap;
}());
function from$5(comparer, tree) {
    var map$$1 = new FableMap();
    map$$1.tree = tree;
    map$$1.comparer = comparer || new GenericComparer();
    return map$$1;
}
function create$6(ie, comparer) {
    comparer = comparer || new GenericComparer();
    return from$5(comparer, ie ? tree_ofSeq$1(comparer, ie) : tree_empty());
}
function add$3(k, v, map$$1) {
    return from$5(map$$1.comparer, tree_add$1(map$$1.comparer, k, v, map$$1.tree));
}


function tryGetValue(map$$1, key, defaultValue) {
    return map$$1.has(key) ? [true, map$$1.get(key)] : [false, defaultValue];
}


function tryFind$1(k, map$$1) {
    return tree_tryFind(map$$1.comparer, k, map$$1.tree);
}
function filter$3(f, map$$1) {
    return from$5(map$$1.comparer, tree_filter$1(map$$1.comparer, f, map$$1.tree));
}

function append$1(xs, ys) {
    return fold(function (acc, x) { return new List$1(x, acc); }, ys, reverse$1(xs));
}
function choose$1(f, xs) {
    var r = fold(function (acc, x) {
        var y = f(x);
        return y != null ? new List$1(y, acc) : acc;
    }, new List$1(), xs);
    return reverse$1(r);
}
function collect$1(f, xs) {
    return fold(function (acc, x) { return append$1(acc, f(x)); }, new List$1(), xs);
}
function concat$1(xs) {
    return collect$1(function (x) { return x; }, xs);
}
function filter$2(f, xs) {
    return reverse$1(fold(function (acc, x) { return f(x) ? new List$1(x, acc) : acc; }, new List$1(), xs));
}

function initialize$2(n, f) {
    if (n < 0) {
        throw new Error("List length must be non-negative");
    }
    var xs = new List$1();
    for (var i = 1; i <= n; i++) {
        xs = new List$1(f(n - i), xs);
    }
    return xs;
}
function map$5(f, xs) {
    return reverse$1(fold(function (acc, x) { return new List$1(f(x), acc); }, new List$1(), xs));
}
function mapIndexed$1(f, xs) {
    return reverse$1(fold(function (acc, x, i) { return new List$1(f(i, x), acc); }, new List$1(), xs));
}


function reverse$1(xs) {
    return fold(function (acc, x) { return new List$1(x, acc); }, new List$1(), xs);
}

function distinctBy(f, xs) {
    return choose(function (tup) { return tup[0]; }, scan(function (tup, x) {
        var acc = tup[1];
        var k = f(x);
        return acc.has(k) ? [null, acc] : [x, add$2(k, acc)];
    }, [null, create$5()], xs));
}
function distinct(xs) {
    return distinctBy(function (x) { return x; }, xs);
}
var SetTree = (function () {
    function SetTree(caseName, fields) {
        this.Case = caseName;
        this.Fields = fields;
    }
    return SetTree;
}());
var tree_tolerance = 2;
function tree_countAux(s, acc) {
    return s.Case === "SetOne" ? acc + 1 : s.Case === "SetEmpty" ? acc : tree_countAux(s.Fields[1], tree_countAux(s.Fields[2], acc + 1));
}
function tree_count(s) {
    return tree_countAux(s, 0);
}
function tree_SetOne(n) {
    return new SetTree("SetOne", [n]);
}
function tree_SetNode(x, l, r, h) {
    return new SetTree("SetNode", [x, l, r, h]);
}
function tree_height(t) {
    return t.Case === "SetOne" ? 1 : t.Case === "SetNode" ? t.Fields[3] : 0;
}
function tree_mk(l, k, r) {
    var matchValue = [l, r];
    var $target1 = function () {
        var hl = tree_height(l);
        var hr = tree_height(r);
        var m = hl < hr ? hr : hl;
        return tree_SetNode(k, l, r, m + 1);
    };
    if (matchValue[0].Case === "SetEmpty") {
        if (matchValue[1].Case === "SetEmpty") {
            return tree_SetOne(k);
        }
        else {
            return $target1();
        }
    }
    else {
        return $target1();
    }
}
function tree_rebalance(t1, k, t2) {
    var t1h = tree_height(t1);
    var t2h = tree_height(t2);
    if (t2h > t1h + tree_tolerance) {
        if (t2.Case === "SetNode") {
            if (tree_height(t2.Fields[1]) > t1h + 1) {
                if (t2.Fields[1].Case === "SetNode") {
                    return tree_mk(tree_mk(t1, k, t2.Fields[1].Fields[1]), t2.Fields[1].Fields[0], tree_mk(t2.Fields[1].Fields[2], t2.Fields[0], t2.Fields[2]));
                }
                else {
                    throw new Error("rebalance");
                }
            }
            else {
                return tree_mk(tree_mk(t1, k, t2.Fields[1]), t2.Fields[0], t2.Fields[2]);
            }
        }
        else {
            throw new Error("rebalance");
        }
    }
    else {
        if (t1h > t2h + tree_tolerance) {
            if (t1.Case === "SetNode") {
                if (tree_height(t1.Fields[2]) > t2h + 1) {
                    if (t1.Fields[2].Case === "SetNode") {
                        return tree_mk(tree_mk(t1.Fields[1], t1.Fields[0], t1.Fields[2].Fields[1]), t1.Fields[2].Fields[0], tree_mk(t1.Fields[2].Fields[2], k, t2));
                    }
                    else {
                        throw new Error("rebalance");
                    }
                }
                else {
                    return tree_mk(t1.Fields[1], t1.Fields[0], tree_mk(t1.Fields[2], k, t2));
                }
            }
            else {
                throw new Error("rebalance");
            }
        }
        else {
            return tree_mk(t1, k, t2);
        }
    }
}
function tree_add(comparer, k, t) {
    if (t.Case === "SetOne") {
        var c = comparer.Compare(k, t.Fields[0]);
        if (c < 0) {
            return tree_SetNode(k, new SetTree("SetEmpty", []), t, 2);
        }
        else if (c === 0) {
            return t;
        }
        else {
            return tree_SetNode(k, t, new SetTree("SetEmpty", []), 2);
        }
    }
    else if (t.Case === "SetEmpty") {
        return tree_SetOne(k);
    }
    else {
        var c = comparer.Compare(k, t.Fields[0]);
        if (c < 0) {
            return tree_rebalance(tree_add(comparer, k, t.Fields[1]), t.Fields[0], t.Fields[2]);
        }
        else if (c === 0) {
            return t;
        }
        else {
            return tree_rebalance(t.Fields[1], t.Fields[0], tree_add(comparer, k, t.Fields[2]));
        }
    }
}
function tree_mem(comparer, k, t) {
    if (t.Case === "SetOne") {
        return comparer.Compare(k, t.Fields[0]) === 0;
    }
    else if (t.Case === "SetEmpty") {
        return false;
    }
    else {
        var c = comparer.Compare(k, t.Fields[0]);
        if (c < 0) {
            return tree_mem(comparer, k, t.Fields[1]);
        }
        else if (c === 0) {
            return true;
        }
        else {
            return tree_mem(comparer, k, t.Fields[2]);
        }
    }
}
function tree_collapseLHS(stack) {
    return stack.tail != null
        ? stack.head.Case === "SetOne"
            ? stack
            : stack.head.Case === "SetNode"
                ? tree_collapseLHS(ofArray$1([
                    stack.head.Fields[1],
                    tree_SetOne(stack.head.Fields[0]),
                    stack.head.Fields[2]
                ], stack.tail))
                : tree_collapseLHS(stack.tail)
        : new List$1();
}
function tree_mkIterator(s) {
    return { stack: tree_collapseLHS(new List$1(s, new List$1())), started: false };
}

function tree_moveNext(i) {
    function current(i) {
        if (i.stack.tail == null) {
            return null;
        }
        else if (i.stack.head.Case === "SetOne") {
            return i.stack.head.Fields[0];
        }
        throw new Error("Please report error: Set iterator, unexpected stack for current");
    }
    if (i.started) {
        if (i.stack.tail == null) {
            return { done: true, value: null };
        }
        else {
            if (i.stack.head.Case === "SetOne") {
                i.stack = tree_collapseLHS(i.stack.tail);
                return {
                    done: i.stack.tail == null,
                    value: current(i)
                };
            }
            else {
                throw new Error("Please report error: Set iterator, unexpected stack for moveNext");
            }
        }
    }
    else {
        i.started = true;
        return {
            done: i.stack.tail == null,
            value: current(i)
        };
    }
    
}
function tree_compareStacks(comparer, l1, l2) {
    var $target8 = function (n1k, t1) { return tree_compareStacks(comparer, ofArray$1([new SetTree("SetEmpty", []), tree_SetOne(n1k)], t1), l2); };
    var $target9 = function (n1k, n1l, n1r, t1) { return tree_compareStacks(comparer, ofArray$1([n1l, tree_SetNode(n1k, new SetTree("SetEmpty", []), n1r, 0)], t1), l2); };
    var $target11 = function (n2k, n2l, n2r, t2) { return tree_compareStacks(comparer, l1, ofArray$1([n2l, tree_SetNode(n2k, new SetTree("SetEmpty", []), n2r, 0)], t2)); };
    if (l1.tail != null) {
        if (l2.tail != null) {
            if (l2.head.Case === "SetOne") {
                if (l1.head.Case === "SetOne") {
                    var n1k = l1.head.Fields[0], n2k = l2.head.Fields[0], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);
                    if (c !== 0) {
                        return c;
                    }
                    else {
                        return tree_compareStacks(comparer, t1, t2);
                    }
                }
                else {
                    if (l1.head.Case === "SetNode") {
                        if (l1.head.Fields[1].Case === "SetEmpty") {
                            var emp = l1.head.Fields[1], n1k = l1.head.Fields[0], n1r = l1.head.Fields[2], n2k = l2.head.Fields[0], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);
                            if (c !== 0) {
                                return c;
                            }
                            else {
                                return tree_compareStacks(comparer, ofArray$1([n1r], t1), ofArray$1([emp], t2));
                            }
                        }
                        else {
                            return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);
                        }
                    }
                    else {
                        var n2k = l2.head.Fields[0], t2 = l2.tail;
                        return tree_compareStacks(comparer, l1, ofArray$1([new SetTree("SetEmpty", []), tree_SetOne(n2k)], t2));
                    }
                }
            }
            else {
                if (l2.head.Case === "SetNode") {
                    if (l2.head.Fields[1].Case === "SetEmpty") {
                        if (l1.head.Case === "SetOne") {
                            var n1k = l1.head.Fields[0], n2k = l2.head.Fields[0], n2r = l2.head.Fields[2], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);
                            if (c !== 0) {
                                return c;
                            }
                            else {
                                return tree_compareStacks(comparer, ofArray$1([new SetTree("SetEmpty", [])], t1), ofArray$1([n2r], t2));
                            }
                        }
                        else {
                            if (l1.head.Case === "SetNode") {
                                if (l1.head.Fields[1].Case === "SetEmpty") {
                                    var n1k = l1.head.Fields[0], n1r = l1.head.Fields[2], n2k = l2.head.Fields[0], n2r = l2.head.Fields[2], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);
                                    if (c !== 0) {
                                        return c;
                                    }
                                    else {
                                        return tree_compareStacks(comparer, ofArray$1([n1r], t1), ofArray$1([n2r], t2));
                                    }
                                }
                                else {
                                    return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);
                                }
                            }
                            else {
                                return $target11(l2.head.Fields[0], l2.head.Fields[1], l2.head.Fields[2], l2.tail);
                            }
                        }
                    }
                    else {
                        if (l1.head.Case === "SetOne") {
                            return $target8(l1.head.Fields[0], l1.tail);
                        }
                        else {
                            if (l1.head.Case === "SetNode") {
                                return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);
                            }
                            else {
                                return $target11(l2.head.Fields[0], l2.head.Fields[1], l2.head.Fields[2], l2.tail);
                            }
                        }
                    }
                }
                else {
                    if (l1.head.Case === "SetOne") {
                        return $target8(l1.head.Fields[0], l1.tail);
                    }
                    else {
                        if (l1.head.Case === "SetNode") {
                            return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);
                        }
                        else {
                            return tree_compareStacks(comparer, l1.tail, l2.tail);
                        }
                    }
                }
            }
        }
        else {
            return 1;
        }
    }
    else {
        if (l2.tail != null) {
            return -1;
        }
        else {
            return 0;
        }
    }
}
function tree_compare(comparer, s1, s2) {
    if (s1.Case === "SetEmpty") {
        if (s2.Case === "SetEmpty") {
            return 0;
        }
        else {
            return -1;
        }
    }
    else {
        if (s2.Case === "SetEmpty") {
            return 1;
        }
        else {
            return tree_compareStacks(comparer, ofArray$1([s1]), ofArray$1([s2]));
        }
    }
}
function tree_mkFromEnumerator(comparer, acc, e) {
    var cur = e.next();
    while (!cur.done) {
        acc = tree_add(comparer, cur.value, acc);
        cur = e.next();
    }
    return acc;
}
function tree_ofSeq(comparer, c) {
    var ie = c[Symbol.iterator]();
    return tree_mkFromEnumerator(comparer, new SetTree("SetEmpty", []), ie);
}
var FableSet = (function () {
    function FableSet() {
    }
    FableSet.prototype.ToString = function () {
        return "set [" + Array.from(this).map(toString$2).join("; ") + "]";
    };
    FableSet.prototype.Equals = function (s2) {
        return this.CompareTo(s2) === 0;
    };
    FableSet.prototype.CompareTo = function (s2) {
        return this === s2 ? 0 : tree_compare(this.comparer, this.tree, s2.tree);
    };
    FableSet.prototype[Symbol.iterator] = function () {
        var i = tree_mkIterator(this.tree);
        return {
            next: function () { return tree_moveNext(i); }
        };
    };
    FableSet.prototype.values = function () {
        return this[Symbol.iterator]();
    };
    FableSet.prototype.has = function (v) {
        return tree_mem(this.comparer, v, this.tree);
    };
    FableSet.prototype.add = function (v) {
        throw new Error("not supported");
    };
    FableSet.prototype.delete = function (v) {
        throw new Error("not supported");
    };
    FableSet.prototype.clear = function () {
        throw new Error("not supported");
    };
    Object.defineProperty(FableSet.prototype, "size", {
        get: function () {
            return tree_count(this.tree);
        },
        enumerable: true,
        configurable: true
    });
    FableSet.prototype[_Symbol.reflection] = function () {
        return {
            type: "Microsoft.FSharp.Collections.FSharpSet",
            interfaces: ["System.IEquatable", "System.IComparable"]
        };
    };
    return FableSet;
}());
function from$4(comparer, tree) {
    var s = new FableSet();
    s.tree = tree;
    s.comparer = comparer || new GenericComparer();
    return s;
}
function create$5(ie, comparer) {
    comparer = comparer || new GenericComparer();
    return from$4(comparer, ie ? tree_ofSeq(comparer, ie) : new SetTree("SetEmpty", []));
}

function add$2(item$$1, s) {
    return from$4(s.comparer, tree_add(s.comparer, item$$1, s.tree));
}

var Trampoline = (function () {
    function Trampoline() {
        this.callCount = 0;
    }
    Object.defineProperty(Trampoline, "maxTrampolineCallCount", {
        get: function () {
            return 2000;
        },
        enumerable: true,
        configurable: true
    });
    Trampoline.prototype.incrementAndCheck = function () {
        return this.callCount++ > Trampoline.maxTrampolineCallCount;
    };
    Trampoline.prototype.hijack = function (f) {
        this.callCount = 0;
        setTimeout(f, 0);
    };
    return Trampoline;
}());
function protectedCont(f) {
    return function (ctx) {
        if (ctx.cancelToken.isCancelled)
            ctx.onCancel("cancelled");
        else if (ctx.trampoline.incrementAndCheck())
            ctx.trampoline.hijack(function () {
                try {
                    f(ctx);
                }
                catch (err) {
                    ctx.onError(err);
                }
            });
        else
            try {
                f(ctx);
            }
            catch (err) {
                ctx.onError(err);
            }
    };
}
function protectedBind(computation, binder) {
    return protectedCont(function (ctx) {
        computation({
            onSuccess: function (x) { return binder(x)(ctx); },
            onError: ctx.onError,
            onCancel: ctx.onCancel,
            cancelToken: ctx.cancelToken,
            trampoline: ctx.trampoline
        });
    });
}
function protectedReturn(value) {
    return protectedCont(function (ctx) { return ctx.onSuccess(value); });
}
var AsyncBuilder = (function () {
    function AsyncBuilder() {
    }
    AsyncBuilder.prototype.Bind = function (computation, binder) {
        return protectedBind(computation, binder);
    };
    AsyncBuilder.prototype.Combine = function (computation1, computation2) {
        return this.Bind(computation1, function () { return computation2; });
    };
    AsyncBuilder.prototype.Delay = function (generator) {
        return protectedCont(function (ctx) { return generator()(ctx); });
    };
    AsyncBuilder.prototype.For = function (sequence, body) {
        var iter = sequence[Symbol.iterator]();
        var cur = iter.next();
        return this.While(function () { return !cur.done; }, this.Delay(function () {
            var res = body(cur.value);
            cur = iter.next();
            return res;
        }));
    };
    AsyncBuilder.prototype.Return = function (value) {
        return protectedReturn(value);
    };
    AsyncBuilder.prototype.ReturnFrom = function (computation) {
        return computation;
    };
    AsyncBuilder.prototype.TryFinally = function (computation, compensation) {
        return protectedCont(function (ctx) {
            computation({
                onSuccess: function (x) {
                    compensation();
                    ctx.onSuccess(x);
                },
                onError: function (x) {
                    compensation();
                    ctx.onError(x);
                },
                onCancel: function (x) {
                    compensation();
                    ctx.onCancel(x);
                },
                cancelToken: ctx.cancelToken,
                trampoline: ctx.trampoline
            });
        });
    };
    AsyncBuilder.prototype.TryWith = function (computation, catchHandler) {
        return protectedCont(function (ctx) {
            computation({
                onSuccess: ctx.onSuccess,
                onCancel: ctx.onCancel,
                cancelToken: ctx.cancelToken,
                trampoline: ctx.trampoline,
                onError: function (ex) {
                    try {
                        catchHandler(ex)(ctx);
                    }
                    catch (ex2) {
                        ctx.onError(ex2);
                    }
                }
            });
        });
    };
    AsyncBuilder.prototype.Using = function (resource, binder) {
        return this.TryFinally(binder(resource), function () { return resource.Dispose(); });
    };
    AsyncBuilder.prototype.While = function (guard, computation) {
        var _this = this;
        if (guard())
            return this.Bind(computation, function () { return _this.While(guard, computation); });
        else
            return this.Return(void 0);
    };
    AsyncBuilder.prototype.Zero = function () {
        return protectedCont(function (ctx) { return ctx.onSuccess(void 0); });
    };
    return AsyncBuilder;
}());
var singleton$2 = new AsyncBuilder();

var Choice = (function () {
    function Choice(t, d) {
        this.Case = t;
        this.Fields = d;
    }
    Object.defineProperty(Choice.prototype, "valueIfChoice1", {
        get: function () {
            return this.Case === "Choice1Of2" ? this.Fields[0] : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Choice.prototype, "valueIfChoice2", {
        get: function () {
            return this.Case === "Choice2Of2" ? this.Fields[0] : null;
        },
        enumerable: true,
        configurable: true
    });
    Choice.prototype.Equals = function (other) {
        return equalsUnions(this, other);
    };
    Choice.prototype.CompareTo = function (other) {
        return compareUnions(this, other);
    };
    Choice.prototype[_Symbol.reflection] = function () {
        return {
            type: "Microsoft.FSharp.Core.FSharpChoice",
            interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"]
        };
    };
    return Choice;
}());

var Async$1 = (function () {
    function Async() {
    }
    return Async;
}());
function emptyContinuation(x) {
}
function awaitPromise(p) {
    return fromContinuations(function (conts) {
        return p.then(conts[0]).catch(function (err) {
            return (err == "cancelled" ? conts[2] : conts[1])(err);
        });
    });
}

var defaultCancellationToken = { isCancelled: false };

function fromContinuations(f) {
    return protectedCont(function (ctx) { return f([ctx.onSuccess, ctx.onError, ctx.onCancel]); });
}

function parallel(computations) {
    return awaitPromise(Promise.all(map$3(function (w) { return startAsPromise(w); }, computations)));
}
function sleep(millisecondsDueTime) {
    return protectedCont(function (ctx) {
        setTimeout(function () { return ctx.cancelToken.isCancelled ? ctx.onCancel("cancelled") : ctx.onSuccess(void 0); }, millisecondsDueTime);
    });
}
function start(computation, cancellationToken) {
    return startWithContinuations(computation, cancellationToken);
}
function startImmediate(computation, cancellationToken) {
    return start(computation, cancellationToken);
}
function startWithContinuations(computation, continuation, exceptionContinuation, cancellationContinuation, cancelToken) {
    if (typeof continuation !== "function") {
        cancelToken = continuation;
        continuation = null;
    }
    var trampoline = new Trampoline();
    computation({
        onSuccess: continuation ? continuation : emptyContinuation,
        onError: exceptionContinuation ? exceptionContinuation : emptyContinuation,
        onCancel: cancellationContinuation ? cancellationContinuation : emptyContinuation,
        cancelToken: cancelToken ? cancelToken : defaultCancellationToken,
        trampoline: trampoline
    });
}
function startAsPromise(computation, cancellationToken) {
    return new Promise(function (resolve, reject) {
        return startWithContinuations(computation, resolve, reject, reject, cancellationToken ? cancellationToken : defaultCancellationToken);
    });
}

function niceNumber(num, decs) {
  var str = toString$2(num);
  var dot = str.indexOf(".");
  var patternInput = dot === -1 ? [str, ""] : [str.substr(0, dot), str.substr(dot + 1, decs < str.length - dot - 1 ? decs : str.length - dot - 1)];
  var after = patternInput[1].length < decs ? patternInput[1] + _Array$from(delay(function () {
    return map$3(function (i) {
      return "0";
    }, range(1, decs - patternInput[1].length));
  })).join('') : patternInput[1];
  var res = patternInput[0];

  if (patternInput[0].length > 5) {
    var inputSequence = rangeStep(patternInput[0].length - 1, -1, 0);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(inputSequence), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var i_1 = _step.value;
        var j = patternInput[0].length - i_1;

        if (i_1 !== 0 ? j % 3 === 0 : false) {
          res = insert(res, i_1, ",");
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  if (forAll(function () {
    var x = "0";
    return function (y) {
      return x === y;
    };
  }(), after)) {
    return res;
  } else {
    return res + "." + after;
  }
}
function isLocalHost() {
  if (typeof window == 'undefined' ? true : window.location.hostname === "localhost") {
    return true;
  } else {
    return window.location.hostname === "127.0.0.1";
  }
}
var enabledCategories = !isLocalHost() ? create$5(new List$1(), new GenericComparer(compare)) : create$5(ofArray$1(["INTERPRETER"]), new GenericComparer(compare));
var Log = function () {
  function Log() {
    _classCallCheck(this, Log);
  }

  _createClass(Log, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Common.Log",
        properties: {}
      };
    }
  }], [{
    key: "setEnabled",
    value: function (cats) {
      enabledCategories = cats;
    }
  }, {
    key: "event",
    value: function (category, evt, article, data) {
      if (typeof logEvent != 'undefined') logEvent(category, evt, article, data);
    }
  }, {
    key: "message",
    value: function (level, category, msg) {
      for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }

      var args_1 = args == null ? [] : args;
      var category_1 = category.toLocaleUpperCase();

      if (!isLocalHost() ? level === "EXCEPTION" : false) {
        if (typeof logEvent != 'undefined') logEvent("system", "exception", "", {
          category: category_1,
          msg: msg,
          args: args_1
        });
      }

      if (((level === "EXCEPTION" ? true : level === "ERROR") ? true : enabledCategories.has("*")) ? true : enabledCategories.has(category_1)) {
        var dt = now();

        var p2 = function p2(s) {
          return padLeft(String(s), 2, "0");
        };

        var p4 = function p4(s_1) {
          return padLeft(String(s_1), 4, "0");
        };

        var prefix = fsFormat("[%s:%s:%s:%s] %s: ")(function (x) {
          return x;
        })(p2(hour(dt)))(p2(minute(dt)))(p2(second(dt)))(p4(millisecond(dt)))(category_1);
        var color = void 0;

        switch (level) {
          case "TRACE":
            color = "color:#808080";
            break;

          case "EXCEPTION":
            color = "color:#c00000";
            break;

          case "ERROR":
            color = "color:#900000";
            break;

          default:
            color = "";
        }

        console.log.apply(console, _Array$from(append(["%c" + prefix + msg, color], args_1)));
      }
    }
  }, {
    key: "trace",
    value: function (category, msg) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      Log.message.apply(Log, ["TRACE", category, msg].concat(args));
    }
  }, {
    key: "exn",
    value: function (category, msg) {
      for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }

      Log.message.apply(Log, ["EXCEPTION", category, msg].concat(args));
    }
  }, {
    key: "error",
    value: function (category, msg) {
      for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        args[_key4 - 2] = arguments[_key4];
      }

      Log.message.apply(Log, ["ERROR", category, msg].concat(args));
    }
  }]);

  return Log;
}();
setType("TheGamma.Common.Log", Log);
var Http = function () {
  function Http() {
    _classCallCheck(this, Http);
  }

  _createClass(Http, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Common.Http",
        properties: {}
      };
    }
  }], [{
    key: "Request",
    value: function (meth, url, data, cookies) {
      return fromContinuations(function (tupledArg) {
        var xhr = new XMLHttpRequest();
        xhr.open(meth, url, true);
        var $var1 = cookies != null ? cookies !== "" ? [0, cookies] : [1] : [1];

        switch ($var1[0]) {
          case 0:
            xhr.setRequestHeader("X-Cookie", $var1[1]);
            break;

          case 1:
            break;
        }

        xhr.onreadystatechange = function (_arg1) {
          if (xhr.readyState > 3 ? xhr.status === 200 : false) {
            tupledArg[0](xhr.responseText);
          }

          return {};
        };

        xhr.send(data != null ? data : "");
      });
    }
  }]);

  return Http;
}();
setType("TheGamma.Common.Http", Http);

function Async_AwaitFuture_Static(f) {
  return fromContinuations(function (tupledArg) {
    f.Then(tupledArg[0]);
  });
}

function Async_Future_Static(n, op, start$$1) {
  var res = new Choice("Choice1Of3", [null]);
  var handlers = new List$1();
  var running = false;

  var trigger = function trigger(h) {
    if (res.Case === "Choice2Of3") {
      var v = res.Fields[0];
      h(v);
    } else if (res.Case === "Choice3Of3") {
      var e = res.Fields[0];
      throw e;
    } else {
      handlers = new List$1(h, handlers);
    }
  };

  var ensureStarted = function ensureStarted() {
    if (!running) {
      iterate(function (n_1) {
        Log.trace("system", "Starting future '%s'....", n_1);
      }, defaultArg(n, [], function (x) {
        return [x];
      }));
      running = true;

      (function (arg00) {
        startImmediate(arg00);
      })(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Combine(builder_.TryWith(builder_.Delay(function () {
            return builder_.Bind(op, function (_arg1) {
              iterate(function (n_2) {
                Log.trace("system", "Future '%s' evaluated to: %O", n_2, _arg1);
              }, defaultArg(n, [], function (x) {
                return [x];
              }));
              res = new Choice("Choice2Of3", [_arg1]);
              return builder_.Zero();
            });
          }), function (_arg2) {
            Log.exn("system", "Evaluating future failed: %O", _arg2);
            res = new Choice("Choice3Of3", [_arg2]);
            return builder_.Zero();
          }), builder_.Delay(function () {
            return builder_.For(handlers, function (_arg3) {
              trigger(_arg3);
              return builder_.Zero();
            });
          }));
        });
      }(singleton$2));
    }
  };

  if (start$$1 === true) {
    ensureStarted(null);
  }

  return _defineProperty({
    Then: function (f) {
      ensureStarted(null);
      trigger(f);
    }
  }, _Symbol.reflection, function () {
    return {
      interfaces: ["TheGamma.Common.Future"]
    };
  });
}

function Async_StartAsFuture_Static(op) {
  return function (arg00) {
    return function (arg10) {
      return function (arg20) {
        return Async_Future_Static(arg00, arg10, arg20);
      };
    };
  }(null)(op)(true);
}

function Async_CreateNamedFuture_Static(name, op) {
  return function (arg00) {
    return function (arg10) {
      return function (arg20) {
        return Async_Future_Static(arg00, arg10, arg20);
      };
    };
  }(name)(op)(false);
}

function Async_StartAsNamedFuture_Static(name, op) {
  return function (arg00) {
    return function (arg10) {
      return function (arg20) {
        return Async_Future_Static(arg00, arg10, arg20);
      };
    };
  }(name)(op)(true);
}

var Async = function (__exports) {
  var _Array = __exports.Array = function (__exports) {
    var Parallel = __exports.Parallel = function (__exports) {
      var map$$1 = __exports.map = function (f, ar) {
        return function (builder_) {
          return builder_.Delay(function () {
            var res = new Array(ar.length).fill(null);
            var work = parallel(toList(delay(function () {
              return map$3(function (i) {
                return function (builder__1) {
                  return builder__1.Delay(function () {
                    return builder__1.Bind(f(ar[i]), function (_arg1) {
                      res[i] = _arg1;
                      return builder__1.Zero();
                    });
                  });
                }(singleton$2);
              }, range(0, ar.length - 1));
            })));
            return builder_.Bind(work, function (_arg2) {
              return builder_.Return(res);
            });
          });
        }(singleton$2);
      };

      return __exports;
    }({});

    var map$$1 = __exports.map = function (f, ar) {
      return function (builder_) {
        return builder_.Delay(function () {
          var res = new Array(ar.length).fill(null);
          return builder_.Combine(builder_.For(range(0, ar.length - 1), function (_arg1) {
            return builder_.Bind(f(ar[_arg1]), function (_arg2) {
              res[_arg1] = _arg2;
              return builder_.Zero();
            });
          }), builder_.Delay(function () {
            return builder_.Return(res);
          }));
        });
      }(singleton$2);
    };

    return __exports;
  }({});

  var collect$$1 = __exports.collect = function (f, l) {
    return function (builder_) {
      return builder_.Delay(function () {
        return l.tail == null ? builder_.Return(new List$1()) : builder_.Bind(f(l.head), function (_arg1) {
          return builder_.Bind(collect$$1(f, l.tail), function (_arg2) {
            return builder_.Return(append$1(_arg1, _arg2));
          });
        });
      });
    }(singleton$2);
  };

  var choose$$1 = __exports.choose = function (f, l) {
    return function (builder_) {
      return builder_.Delay(function () {
        return l.tail == null ? builder_.Return(new List$1()) : builder_.Bind(f(l.head), function (_arg1) {
          return builder_.Bind(choose$$1(f, l.tail), function (_arg2) {
            return builder_.Return(_arg1 != null ? new List$1(_arg1, _arg2) : _arg2);
          });
        });
      });
    }(singleton$2);
  };

  var map$$1 = __exports.map = function (f, l) {
    return function (builder_) {
      return builder_.Delay(function () {
        return l.tail == null ? builder_.Return(new List$1()) : builder_.Bind(f(l.head), function (_arg1) {
          return builder_.Bind(map$$1(f, l.tail), function (_arg2) {
            return builder_.Return(new List$1(_arg1, _arg2));
          });
        });
      });
    }(singleton$2);
  };

  var foldMap = __exports.foldMap = function (f, st, l) {
    return function (builder_) {
      return builder_.Delay(function () {
        return l.tail == null ? builder_.Return([st, new List$1()]) : builder_.Bind(f(st)(l.head), function (_arg1) {
          return builder_.Bind(foldMap(f, _arg1[1], l.tail), function (_arg2) {
            return builder_.Return([_arg2[0], new List$1(_arg1[0], _arg2[1])]);
          });
        });
      });
    }(singleton$2);
  };

  var fold$$1 = __exports.fold = function (f, st, l) {
    return function (builder_) {
      return builder_.Delay(function () {
        return l.tail == null ? builder_.Return(st) : builder_.Bind(f(st)(l.head), function (_arg1) {
          return builder_.ReturnFrom(fold$$1(f, _arg1, l.tail));
        });
      });
    }(singleton$2);
  };

  return __exports;
}({});
var ListDictionaryNode = function () {
  function ListDictionaryNode(result, nested) {
    _classCallCheck(this, ListDictionaryNode);

    this.Result = result;
    this.Nested = nested;
  }

  _createClass(ListDictionaryNode, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Common.ListDictionaryNode",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Result: Option(GenericParam("T")),
          Nested: makeGeneric(_Map, {
            TKey: GenericParam("K"),
            TValue: makeGeneric(ListDictionaryNode, {
              K: GenericParam("K"),
              T: GenericParam("T")
            })
          })
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return ListDictionaryNode;
}();
setType("TheGamma.Common.ListDictionaryNode", ListDictionaryNode);
var ListDictionaryModule = function (__exports) {
  var tryFind$$1 = __exports.tryFind = function (ks, dict) {
    var loop = function loop(ks_1) {
      return function (node) {
        var _loop = function _loop() {
          var matchValue = [ks_1, node];
          var $var2 = matchValue[0].tail != null ? function () {
            var ks_2 = matchValue[0].tail;
            var k = matchValue[0].head;
            var d = matchValue[1].Nested;
            return d.has(k);
          }() ? [1, matchValue[1].Nested, matchValue[0].head, matchValue[0].tail] : [2] : matchValue[1].Result != null ? [0, matchValue[1].Result] : [2];

          switch ($var2[0]) {
            case 0:
              return {
                v: $var2[1]
              };

            case 1:
              ks_1 = $var2[3];
              node = $var2[1].get($var2[2]);
              return "continue|loop";

            case 2:
              return {
                v: null
              };
          }
        };

        loop: while (true) {
          var _ret = _loop();

          switch (_ret) {
            case "continue|loop":
              continue loop;

            default:
              if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
          }
        }
      };
    };

    return loop(ks)(new ListDictionaryNode(null, dict));
  };

  var set = __exports.set = function (ks, v, dict) {
    var loop = function loop(ks_1) {
      return function (dict_1) {
        if (ks_1.tail != null) {
          if (!dict_1.has(ks_1.head)) {
            dict_1.set(ks_1.head, function () {
              var Nested = new _Map();
              return new ListDictionaryNode(null, Nested);
            }());
          }

          if (ks_1.tail.tail == null) {
            dict_1.get(ks_1.head).Result = v;
          } else {
            loop(ks_1.tail)(dict_1.get(ks_1.head).Nested);
          }
        } else {
          throw new Error("Empty key not supported");
        }
      };
    };

    loop(ks)(dict);
  };

  var count$$1 = __exports.count = function (dict) {
    var loop = function loop(node) {
      var nest = sumBy(function (kv) {
        return loop(kv[1]);
      }, node.Nested);

      if (function () {
        return node.Result != null;
      }(null)) {
        return 1 + nest;
      } else {
        return nest;
      }
    };

    return sumBy(function (kv_1) {
      return loop(kv_1[1]);
    }, dict);
  };

  return __exports;
}({});
var List = function (__exports) {
  var groupWith = __exports.groupWith = function (f, list) {
    var groups = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _getIterator(list), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var e = _step2.value;
        var added = false;
        var i = 0;

        while (!added ? i < groups.length : false) {
          if (f(e)(groups[i][0])) {
            groups[i][1].push(e);
            added = true;
          }

          i = i + 1;
        }

        if (!added) {
          groups.push([e, _Array$from(ofArray$1([e]))]);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return toList(map$3(function ($var3) {
      return toList($var3[1]);
    }, groups));
  };

  var unreduce = __exports.unreduce = function (f, s) {
    return toList(unfold(function (s_1) {
      return defaultArg(f(s_1), null, function (v) {
        return [v, v];
      });
    }, s));
  };

  return __exports;
}({});

var Position = function () {
    function Position(line, column) {
        _classCallCheck(this, Position);

        this.line = line;
        this.column = column;
    }

    _createClass(Position, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.Position",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    line: "number",
                    column: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return Position;
}();
setType("TheGamma.Babel.Position", Position);
var SourceLocation = function () {
    function SourceLocation(start, end) {
        _classCallCheck(this, SourceLocation);

        this.start = start;
        this.end = end;
    }

    _createClass(SourceLocation, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.SourceLocation",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    start: Position,
                    end: Position
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return SourceLocation;
}();
setType("TheGamma.Babel.SourceLocation", SourceLocation);
var AssignmentOperator = function () {
    function AssignmentOperator(caseName, fields) {
        _classCallCheck(this, AssignmentOperator);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(AssignmentOperator, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.AssignmentOperator",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    AssignAndBitwise: [],
                    AssignDivide: [],
                    AssignEqual: [],
                    AssignMinus: [],
                    AssignModulus: [],
                    AssignMultiply: [],
                    AssignOrBitwise: [],
                    AssignPlus: [],
                    AssignShiftLeft: [],
                    AssignShiftRightSignPropagating: [],
                    AssignShiftRightZeroFill: [],
                    AssignXorBitwise: []
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return AssignmentOperator;
}();
setType("TheGamma.Babel.AssignmentOperator", AssignmentOperator);
var BinaryOperator = function () {
    function BinaryOperator(caseName, fields) {
        _classCallCheck(this, BinaryOperator);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(BinaryOperator, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.BinaryOperator",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    BinaryAndBitwise: [],
                    BinaryDivide: [],
                    BinaryEqual: [],
                    BinaryEqualStrict: [],
                    BinaryExponent: [],
                    BinaryGreater: [],
                    BinaryGreaterOrEqual: [],
                    BinaryIn: [],
                    BinaryInstanceOf: [],
                    BinaryLess: [],
                    BinaryLessOrEqual: [],
                    BinaryMinus: [],
                    BinaryModulus: [],
                    BinaryMultiply: [],
                    BinaryOrBitwise: [],
                    BinaryPlus: [],
                    BinaryShiftLeft: [],
                    BinaryShiftRightSignPropagating: [],
                    BinaryShiftRightZeroFill: [],
                    BinaryUnequal: [],
                    BinaryUnequalStrict: [],
                    BinaryXorBitwise: []
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return BinaryOperator;
}();
setType("TheGamma.Babel.BinaryOperator", BinaryOperator);
var Pattern = function () {
    function Pattern(caseName, fields) {
        _classCallCheck(this, Pattern);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(Pattern, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.Pattern",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    IdentifierPattern: ["string", Option(SourceLocation)]
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return Pattern;
}();
setType("TheGamma.Babel.Pattern", Pattern);
var VariableDeclarationKind = function () {
    function VariableDeclarationKind(caseName, fields) {
        _classCallCheck(this, VariableDeclarationKind);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(VariableDeclarationKind, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.VariableDeclarationKind",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    Const: [],
                    Let: [],
                    Var: []
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return VariableDeclarationKind;
}();
setType("TheGamma.Babel.VariableDeclarationKind", VariableDeclarationKind);
var VariableDeclarator = function () {
    function VariableDeclarator(caseName, fields) {
        _classCallCheck(this, VariableDeclarator);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(VariableDeclarator, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.VariableDeclarator",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    VariableDeclarator: [Pattern, Option(Expression), Option(SourceLocation)]
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return VariableDeclarator;
}();
setType("TheGamma.Babel.VariableDeclarator", VariableDeclarator);
var ObjectMember = function () {
    function ObjectMember(caseName, fields) {
        _classCallCheck(this, ObjectMember);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(ObjectMember, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.ObjectMember",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    ObjectProperty: [Expression, Expression, "boolean", Option(SourceLocation)]
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return ObjectMember;
}();
setType("TheGamma.Babel.ObjectMember", ObjectMember);
var Expression = function () {
    function Expression(caseName, fields) {
        _classCallCheck(this, Expression);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(Expression, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.Expression",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    ArrayExpression: [makeGeneric(List$1, {
                        T: Expression
                    }), Option(SourceLocation)],
                    AssignmentExpression: [AssignmentOperator, Expression, Expression, Option(SourceLocation)],
                    BinaryExpression: [BinaryOperator, Expression, Expression, Option(SourceLocation)],
                    BooleanLiteral: ["boolean", Option(SourceLocation)],
                    CallExpression: [Expression, makeGeneric(List$1, {
                        T: Expression
                    }), Option(SourceLocation)],
                    FunctionExpression: [Option("string"), makeGeneric(List$1, {
                        T: Pattern
                    }), Statement, "boolean", "boolean", Option(SourceLocation)],
                    IdentifierExpression: ["string", Option(SourceLocation)],
                    MemberExpression: [Expression, Expression, "boolean", Option(SourceLocation)],
                    NewExpression: [Expression, makeGeneric(List$1, {
                        T: Expression
                    }), Option(SourceLocation)],
                    NullLiteral: [Option(SourceLocation)],
                    NumericLiteral: ["number", Option(SourceLocation)],
                    ObjectExpression: [makeGeneric(List$1, {
                        T: ObjectMember
                    }), Option(SourceLocation)],
                    StringLiteral: ["string", Option(SourceLocation)]
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return Expression;
}();
setType("TheGamma.Babel.Expression", Expression);
var Statement = function () {
    function Statement(caseName, fields) {
        _classCallCheck(this, Statement);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(Statement, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.Statement",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    BlockStatement: [makeGeneric(List$1, {
                        T: Statement
                    }), Option(SourceLocation)],
                    EmptyStatement: [Option(SourceLocation)],
                    ExpressionStatement: [Expression, Option(SourceLocation)],
                    ReturnStatement: [Expression, Option(SourceLocation)],
                    VariableDeclaration: [VariableDeclarationKind, makeGeneric(List$1, {
                        T: VariableDeclarator
                    }), Option(SourceLocation)]
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return Statement;
}();
setType("TheGamma.Babel.Statement", Statement);
var Program$1 = function () {
    function Program(location, body) {
        _classCallCheck(this, Program);

        this.location = location;
        this.body = body;
    }

    _createClass(Program, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Babel.Program",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    location: Option(SourceLocation),
                    body: makeGeneric(List$1, {
                        T: Statement
                    })
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return Program;
}();
setType("TheGamma.Babel.Program", Program$1);
var Serializer = function (__exports) {
    var createObj$$1 = __exports.createObj = function (props) {
        return createObj(concat$1(props));
    };

    var serializeBinaryOperator = __exports.serializeBinaryOperator = function (_arg1) {
        if (_arg1.Case === "BinaryUnequal") {
            return "!=";
        } else if (_arg1.Case === "BinaryEqualStrict") {
            return "===";
        } else if (_arg1.Case === "BinaryUnequalStrict") {
            return "!==";
        } else if (_arg1.Case === "BinaryLess") {
            return "<";
        } else if (_arg1.Case === "BinaryLessOrEqual") {
            return "<=";
        } else if (_arg1.Case === "BinaryGreater") {
            return ">";
        } else if (_arg1.Case === "BinaryGreaterOrEqual") {
            return ">=";
        } else if (_arg1.Case === "BinaryShiftLeft") {
            return "<<";
        } else if (_arg1.Case === "BinaryShiftRightSignPropagating") {
            return ">>";
        } else if (_arg1.Case === "BinaryShiftRightZeroFill") {
            return ">>>";
        } else if (_arg1.Case === "BinaryMinus") {
            return "-";
        } else if (_arg1.Case === "BinaryPlus") {
            return "+";
        } else if (_arg1.Case === "BinaryMultiply") {
            return "*";
        } else if (_arg1.Case === "BinaryDivide") {
            return "/";
        } else if (_arg1.Case === "BinaryModulus") {
            return "%";
        } else if (_arg1.Case === "BinaryExponent") {
            return "**";
        } else if (_arg1.Case === "BinaryOrBitwise") {
            return "|";
        } else if (_arg1.Case === "BinaryXorBitwise") {
            return "^";
        } else if (_arg1.Case === "BinaryAndBitwise") {
            return "&";
        } else if (_arg1.Case === "BinaryIn") {
            return "in";
        } else if (_arg1.Case === "BinaryInstanceOf") {
            return "instanceof";
        } else {
            return "==";
        }
    };

    var serializeAssignOperator = __exports.serializeAssignOperator = function (_arg1) {
        if (_arg1.Case === "AssignMinus") {
            return "-=";
        } else if (_arg1.Case === "AssignPlus") {
            return "+=";
        } else if (_arg1.Case === "AssignMultiply") {
            return "*=";
        } else if (_arg1.Case === "AssignDivide") {
            return "/=";
        } else if (_arg1.Case === "AssignModulus") {
            return "%=";
        } else if (_arg1.Case === "AssignShiftLeft") {
            return "<<=";
        } else if (_arg1.Case === "AssignShiftRightSignPropagating") {
            return ">>=";
        } else if (_arg1.Case === "AssignShiftRightZeroFill") {
            return ">>>=";
        } else if (_arg1.Case === "AssignOrBitwise") {
            return "|=";
        } else if (_arg1.Case === "AssignXorBitwise") {
            return "^=";
        } else if (_arg1.Case === "AssignAndBitwise") {
            return "&=";
        } else {
            return "=";
        }
    };

    var serializePattern = __exports.serializePattern = function (pat) {
        return createObj$$1(ofArray$1([ofArray$1([["type", "Identifier"]]), ofArray$1([["name", pat.Fields[0]]]), function () {
            var $var57 = pat.Fields[1];

            if ($var57 != null) {
                return ofArray$1([["loc", $var57]]);
            } else {
                return new List$1();
            }
        }()]));
    };

    var serializeMember = __exports.serializeMember = function (mem) {
        return createObj$$1(ofArray$1([ofArray$1([["type", "ObjectProperty"]]), ofArray$1([["key", serializeExpression(mem.Fields[0])]]), ofArray$1([["value", serializeExpression(mem.Fields[1])]]), ofArray$1([["computed", mem.Fields[2]]]), function () {
            var $var58 = mem.Fields[3];

            if ($var58 != null) {
                return ofArray$1([["loc", $var58]]);
            } else {
                return new List$1();
            }
        }()]));
    };

    var serializeDeclarator = __exports.serializeDeclarator = function (_arg1) {
        return createObj$$1(ofArray$1([ofArray$1([["type", "VariableDeclarator"]]), ofArray$1([["id", serializePattern(_arg1.Fields[0])]]), function () {
            var $var59 = defaultArg(_arg1.Fields[1], null, function (expr) {
                return serializeExpression(expr);
            });

            if ($var59 != null) {
                return ofArray$1([["init", $var59]]);
            } else {
                return new List$1();
            }
        }(), function () {
            var $var60 = _arg1.Fields[2];

            if ($var60 != null) {
                return ofArray$1([["loc", $var60]]);
            } else {
                return new List$1();
            }
        }()]));
    };

    var serializeExpression = __exports.serializeExpression = function (expr) {
        if (expr.Case === "NewExpression") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "NewExpression"]]), ofArray$1([["callee", serializeExpression(expr.Fields[0])]]), ofArray$1([["arguments", _Array$from(map$5(function (expr_1) {
                return serializeExpression(expr_1);
            }, expr.Fields[1]))]]), function () {
                var $var61 = expr.Fields[2];

                if ($var61 != null) {
                    return ofArray$1([["loc", $var61]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else if (expr.Case === "FunctionExpression") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "FunctionExpression"]]), function () {
                var $var62 = expr.Fields[0];

                if ($var62 != null) {
                    return ofArray$1([["id", $var62]]);
                } else {
                    return new List$1();
                }
            }(), ofArray$1([["params", _Array$from(map$5(function (pat) {
                return serializePattern(pat);
            }, expr.Fields[1]))]]), ofArray$1([["body", serializeStatement(expr.Fields[2])]]), ofArray$1([["generator", expr.Fields[3]]]), ofArray$1([["async", expr.Fields[4]]]), function () {
                var $var63 = expr.Fields[5];

                if ($var63 != null) {
                    return ofArray$1([["loc", $var63]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else if (expr.Case === "AssignmentExpression") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "AssignmentExpression"]]), ofArray$1([["left", serializeExpression(expr.Fields[1])]]), ofArray$1([["right", serializeExpression(expr.Fields[2])]]), ofArray$1([["operator", serializeAssignOperator(expr.Fields[0])]]), function () {
                var $var64 = expr.Fields[3];

                if ($var64 != null) {
                    return ofArray$1([["loc", $var64]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else if (expr.Case === "CallExpression") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "CallExpression"]]), ofArray$1([["callee", serializeExpression(expr.Fields[0])]]), ofArray$1([["arguments", _Array$from(map$5(function (expr_2) {
                return serializeExpression(expr_2);
            }, expr.Fields[1]))]]), function () {
                var $var65 = expr.Fields[2];

                if ($var65 != null) {
                    return ofArray$1([["loc", $var65]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else if (expr.Case === "MemberExpression") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "MemberExpression"]]), ofArray$1([["object", serializeExpression(expr.Fields[0])]]), ofArray$1([["property", serializeExpression(expr.Fields[1])]]), ofArray$1([["computed", expr.Fields[2]]]), function () {
                var $var66 = expr.Fields[3];

                if ($var66 != null) {
                    return ofArray$1([["loc", $var66]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else if (expr.Case === "BinaryExpression") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "BinaryExpression"]]), ofArray$1([["left", serializeExpression(expr.Fields[1])]]), ofArray$1([["right", serializeExpression(expr.Fields[2])]]), ofArray$1([["operator", serializeBinaryOperator(expr.Fields[0])]]), function () {
                var $var67 = expr.Fields[3];

                if ($var67 != null) {
                    return ofArray$1([["loc", $var67]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else if (expr.Case === "ObjectExpression") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "ObjectExpression"]]), ofArray$1([["properties", _Array$from(map$5(function (mem) {
                return serializeMember(mem);
            }, expr.Fields[0]))]]), function () {
                var $var68 = expr.Fields[1];

                if ($var68 != null) {
                    return ofArray$1([["loc", $var68]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else if (expr.Case === "ArrayExpression") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "ArrayExpression"]]), ofArray$1([["elements", _Array$from(map$5(function (expr_3) {
                return serializeExpression(expr_3);
            }, expr.Fields[0]))]]), function () {
                var $var69 = expr.Fields[1];

                if ($var69 != null) {
                    return ofArray$1([["loc", $var69]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else if (expr.Case === "NullLiteral") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "NullLiteral"]]), function () {
                var $var70 = expr.Fields[0];

                if ($var70 != null) {
                    return ofArray$1([["loc", $var70]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else if (expr.Case === "StringLiteral") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "StringLiteral"]]), ofArray$1([["value", expr.Fields[0]]]), function () {
                var $var71 = expr.Fields[1];

                if ($var71 != null) {
                    return ofArray$1([["loc", $var71]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else if (expr.Case === "BooleanLiteral") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "BooleanLiteral"]]), ofArray$1([["value", expr.Fields[0]]]), function () {
                var $var72 = expr.Fields[1];

                if ($var72 != null) {
                    return ofArray$1([["loc", $var72]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else if (expr.Case === "NumericLiteral") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "NumericLiteral"]]), ofArray$1([["value", expr.Fields[0]]]), function () {
                var $var73 = expr.Fields[1];

                if ($var73 != null) {
                    return ofArray$1([["loc", $var73]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else {
            return createObj$$1(ofArray$1([ofArray$1([["type", "Identifier"]]), ofArray$1([["name", expr.Fields[0]]]), function () {
                var $var74 = expr.Fields[1];

                if ($var74 != null) {
                    return ofArray$1([["loc", $var74]]);
                } else {
                    return new List$1();
                }
            }()]));
        }
    };

    var serializeStatement = __exports.serializeStatement = function (stm) {
        if (stm.Case === "BlockStatement") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "BlockStatement"]]), function () {
                var $var75 = stm.Fields[1];

                if ($var75 != null) {
                    return ofArray$1([["loc", $var75]]);
                } else {
                    return new List$1();
                }
            }(), ofArray$1([["body", _Array$from(map$5(function (stm_1) {
                return serializeStatement(stm_1);
            }, stm.Fields[0]))]])]));
        } else if (stm.Case === "EmptyStatement") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "EmptyStatement"]]), function () {
                var $var76 = stm.Fields[0];

                if ($var76 != null) {
                    return ofArray$1([["loc", $var76]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else if (stm.Case === "ReturnStatement") {
            return createObj$$1(ofArray$1([ofArray$1([["type", "ReturnStatement"]]), function () {
                var $var77 = stm.Fields[1];

                if ($var77 != null) {
                    return ofArray$1([["loc", $var77]]);
                } else {
                    return new List$1();
                }
            }(), ofArray$1([["argument", serializeExpression(stm.Fields[0])]])]));
        } else if (stm.Case === "VariableDeclaration") {
            var kind = stm.Fields[0].Case === "Let" ? "let" : stm.Fields[0].Case === "Const" ? "const" : "var";
            return createObj$$1(ofArray$1([ofArray$1([["type", "VariableDeclaration"]]), ofArray$1([["kind", kind]]), ofArray$1([["declarations", _Array$from(map$5(function (arg00_) {
                return serializeDeclarator(arg00_);
            }, stm.Fields[1]))]]), function () {
                var $var78 = stm.Fields[2];

                if ($var78 != null) {
                    return ofArray$1([["loc", $var78]]);
                } else {
                    return new List$1();
                }
            }()]));
        } else {
            return createObj$$1(ofArray$1([ofArray$1([["type", "ExpressionStatement"]]), function () {
                var $var79 = stm.Fields[1];

                if ($var79 != null) {
                    return ofArray$1([["loc", $var79]]);
                } else {
                    return new List$1();
                }
            }(), ofArray$1([["expression", serializeExpression(stm.Fields[0])]])]));
        }
    };

    var serializeProgram = __exports.serializeProgram = function (prog) {
        return createObj$$1(ofArray$1([ofArray$1([["type", "Program"]]), function () {
            var $var80 = prog.location;

            if ($var80 != null) {
                return ofArray$1([["loc", $var80]]);
            } else {
                return new List$1();
            }
        }(), ofArray$1([["sourceType", "module"]]), ofArray$1([["body", _Array$from(map$5(function (stm) {
            return serializeStatement(stm);
        }, prog.body))]]), ofArray$1([["directives", []]])]));
    };

    return __exports;
}({});
var BabelOperators = function (__exports) {
    var ident = __exports.ident = function (s) {
        return new Expression("IdentifierExpression", [s, null]);
    };

    var str = __exports.str = function (v) {
        return new Expression("StringLiteral", [v, null]);
    };

    var num = __exports.num = function (v) {
        return new Expression("NumericLiteral", [v, null]);
    };

    var bool = __exports.bool = function (v) {
        return new Expression("BooleanLiteral", [v, null]);
    };

    var arr = __exports.arr = function (l) {
        return new Expression("ArrayExpression", [l, null]);
    };

    var op_Dynamic = __exports.op_Dynamic = function (e, s) {
        return new Expression("MemberExpression", [e, new Expression("IdentifierExpression", [s, null]), false, null]);
    };

    var op_DivideQmarkDivide = __exports.op_DivideQmarkDivide = function (e, a) {
        return new Expression("MemberExpression", [e, a, true, null]);
    };

    var op_DivideAtDivide = __exports.op_DivideAtDivide = function (e, args) {
        return new Expression("CallExpression", [e, args, null]);
    };

    var func = __exports.func = function (v, f) {
        var body = new Statement("BlockStatement", [ofArray$1([new Statement("ReturnStatement", [f(ident(v)), null])]), null]);
        return new Expression("FunctionExpression", [null, ofArray$1([new Pattern("IdentifierPattern", [v, null])]), body, false, false, null]);
    };

    var funcN = __exports.funcN = function (n, f) {
        var args = initialize$2(n, function (i) {
            return "_arg" + String(i);
        });
        var body = new Statement("BlockStatement", [ofArray$1([new Statement("ReturnStatement", [f(map$5(function (s) {
            return ident(s);
        }, args)), null])]), null]);
        return new Expression("FunctionExpression", [null, map$5(function (s_1) {
            return new Pattern("IdentifierPattern", [s_1, null]);
        }, args), body, false, false, null]);
    };

    return __exports;
}({});

var _Range = function () {
  function _Range(start, end) {
    _classCallCheck(this, _Range);

    this.Start = start;
    this.End = end;
  }

  _createClass(_Range, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Range",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Start: "number",
          End: "number"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return _Range;
}();

setType("TheGamma.Range", _Range);

var _Error = function () {
  function _Error(number, message, range) {
    _classCallCheck(this, _Error);

    this.Number = number;
    this.Message = message;
    this.Range = range;
  }

  _createClass(_Error, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Error",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Number: "number",
          Message: "string",
          Range: GenericParam("Range")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return _Error;
}();

setType("TheGamma.Error", _Error);
var Operator = function () {
  function Operator(caseName, fields) {
    _classCallCheck(this, Operator);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Operator, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Operator",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Divide: [],
          Equals: [],
          GreaterThan: [],
          GreaterThanOrEqual: [],
          LessThan: [],
          LessThanOrEqual: [],
          Minus: [],
          Modulo: [],
          Multiply: [],
          Plus: [],
          Power: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Operator;
}();
setType("TheGamma.Operator", Operator);
var TokenKind = function () {
  function TokenKind(caseName, fields) {
    _classCallCheck(this, TokenKind);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(TokenKind, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TokenKind",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Arrow: [],
          Boolean: ["boolean"],
          Colon: [],
          Comma: [],
          Dot: [],
          EndOfFile: [],
          Equals: [],
          Error: ["string"],
          Fun: [],
          Ident: ["string"],
          LParen: [],
          LSquare: [],
          Let: [],
          Newline: [],
          Number: ["string", "number"],
          Operator: [Operator],
          QIdent: ["string"],
          RParen: [],
          RSquare: [],
          String: ["string"],
          White: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return TokenKind;
}();
setType("TheGamma.TokenKind", TokenKind);
var Token = function () {
  function Token(token, range) {
    _classCallCheck(this, Token);

    this.Token = token;
    this.Range = range;
  }

  _createClass(Token, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Token",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Token: TokenKind,
          Range: _Range
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return Token;
}();
setType("TheGamma.Token", Token);
var Emitter = function () {
  function Emitter(emit) {
    _classCallCheck(this, Emitter);

    this.Emit = emit;
  }

  _createClass(Emitter, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Emitter",
        interfaces: ["FSharpRecord"],
        properties: {
          Emit: "function"
        }
      };
    }
  }]);

  return Emitter;
}();
setType("TheGamma.Emitter", Emitter);
var Metadata = function () {
  function Metadata(context, type, data) {
    _classCallCheck(this, Metadata);

    this.Context = context;
    this.Type = type;
    this.Data = data;
  }

  _createClass(Metadata, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Metadata",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Context: "string",
          Type: "string",
          Data: Any
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return Metadata;
}();
setType("TheGamma.Metadata", Metadata);
var Documentation = function () {
  function Documentation(caseName, fields) {
    _classCallCheck(this, Documentation);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Documentation, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Documentation",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Details: ["string", "string"],
          None: [],
          Text: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Documentation;
}();
setType("TheGamma.Documentation", Documentation);
var Member = function () {
  function Member(name, type, metadata, emitter) {
    _classCallCheck(this, Member);

    this.Name = name;
    this.Type = type;
    this.Metadata = metadata;
    this.Emitter = emitter;
  }

  _createClass(Member, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Member",
        interfaces: ["FSharpRecord"],
        properties: {
          Name: "string",
          Type: Type,
          Metadata: makeGeneric(List$1, {
            T: Metadata
          }),
          Emitter: Emitter
        }
      };
    }
  }]);

  return Member;
}();
setType("TheGamma.Member", Member);
var PrimitiveType = function () {
  function PrimitiveType(caseName, fields) {
    _classCallCheck(this, PrimitiveType);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(PrimitiveType, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.PrimitiveType",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Bool: [],
          Date: [],
          Number: [],
          String: [],
          Unit: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return PrimitiveType;
}();
setType("TheGamma.PrimitiveType", PrimitiveType);
var Type = function () {
  function Type(caseName, fields) {
    _classCallCheck(this, Type);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Type, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Type",
        interfaces: ["FSharpUnion"],
        cases: {
          Any: [],
          Delayed: [Interface("TheGamma.Common.Future")],
          List: [Type],
          Method: [makeGeneric(List$1, {
            T: Tuple(["string", "boolean", Type])
          }), "function"],
          Object: [Interface("TheGamma.ObjectType")],
          Primitive: [PrimitiveType]
        }
      };
    }
  }]);

  return Type;
}();
setType("TheGamma.Type", Type);
var Name = function () {
  function Name(name) {
    _classCallCheck(this, Name);

    this.Name = name;
  }

  _createClass(Name, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Name",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Name: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return Name;
}();
setType("TheGamma.Name", Name);
var Constant = function () {
  function Constant(caseName, fields) {
    _classCallCheck(this, Constant);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Constant, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Constant",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Boolean: ["boolean"],
          Empty: [],
          Number: ["number"],
          String: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Constant;
}();
setType("TheGamma.Constant", Constant);
var EntityKind = function () {
  function EntityKind(caseName, fields) {
    _classCallCheck(this, EntityKind);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(EntityKind, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.EntityKind",
        interfaces: ["FSharpUnion"],
        cases: {
          ArgumentList: [makeGeneric(List$1, {
            T: Entity
          })],
          Binding: [Name, Entity],
          Call: [Entity, Entity],
          CallSite: [Entity, Choice],
          Constant: [Constant],
          Function: [Entity, Entity],
          GlobalValue: [Name, Option(Expression)],
          LetCommand: [Entity, Entity],
          List: [makeGeneric(List$1, {
            T: Entity
          })],
          Member: [Entity, Entity],
          MemberName: [Name],
          NamedParam: [Name, Entity],
          Operator: [Entity, Operator, Entity],
          Placeholder: [Name, Entity],
          Program: [makeGeneric(List$1, {
            T: Entity
          })],
          Root: [],
          RunCommand: [Entity],
          Variable: [Name, Entity]
        }
      };
    }
  }]);

  return EntityKind;
}();
setType("TheGamma.EntityKind", EntityKind);
var Entity = function () {
  function Entity(kind, symbol, value, meta, type, errors) {
    _classCallCheck(this, Entity);

    this.Kind = kind;
    this.Symbol = symbol;
    this.Value = value;
    this.Meta = meta;
    this.Type = type;
    this.Errors = errors;
  }

  _createClass(Entity, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Entity",
        interfaces: ["FSharpRecord"],
        properties: {
          Kind: EntityKind,
          Symbol: Interface("TheGamma.Common.Symbol"),
          Value: Option(EntityValue),
          Meta: makeGeneric(List$1, {
            T: Metadata
          }),
          Type: Option(Type),
          Errors: makeGeneric(List$1, {
            T: makeGeneric(_Error, {
              Range: _Range
            })
          })
        }
      };
    }
  }]);

  return Entity;
}();
setType("TheGamma.Entity", Entity);
var EntityValue = function () {
  function EntityValue(value, preview) {
    _classCallCheck(this, EntityValue);

    this.Value = value;
    this.Preview = preview;
  }

  _createClass(EntityValue, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.EntityValue",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Value: Interface("TheGamma.RuntimeValue"),
          Preview: Any
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return EntityValue;
}();
setType("TheGamma.EntityValue", EntityValue);

var _Node = function () {
  function _Node(whiteBefore, whiteAfter, range, node, entity) {
    _classCallCheck(this, _Node);

    this.WhiteBefore = whiteBefore;
    this.WhiteAfter = whiteAfter;
    this.Range = range;
    this.Node = node;
    this.Entity = entity;
  }

  _createClass(_Node, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Node",
        interfaces: ["FSharpRecord"],
        properties: {
          WhiteBefore: makeGeneric(List$1, {
            T: Token
          }),
          WhiteAfter: makeGeneric(List$1, {
            T: Token
          }),
          Range: _Range,
          Node: GenericParam("T"),
          Entity: Option(Entity)
        }
      };
    }
  }]);

  return _Node;
}();

setType("TheGamma.Node", _Node);
var Argument = function () {
  function Argument(name, value) {
    _classCallCheck(this, Argument);

    this.Name = name;
    this.Value = value;
  }

  _createClass(Argument, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Argument",
        interfaces: ["FSharpRecord"],
        properties: {
          Name: Option(makeGeneric(_Node, {
            T: Name
          })),
          Value: makeGeneric(_Node, {
            T: Expr
          })
        }
      };
    }
  }]);

  return Argument;
}();
setType("TheGamma.Argument", Argument);
var Program$$1 = function () {
  function Program$$1(body) {
    _classCallCheck(this, Program$$1);

    this.Body = body;
  }

  _createClass(Program$$1, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Program",
        interfaces: ["FSharpRecord"],
        properties: {
          Body: makeGeneric(_Node, {
            T: makeGeneric(List$1, {
              T: makeGeneric(_Node, {
                T: Command
              })
            })
          })
        }
      };
    }
  }]);

  return Program$$1;
}();
setType("TheGamma.Program", Program$$1);
var Command = function () {
  function Command(caseName, fields) {
    _classCallCheck(this, Command);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Command, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Command",
        interfaces: ["FSharpUnion"],
        cases: {
          Expr: [makeGeneric(_Node, {
            T: Expr
          })],
          Let: [makeGeneric(_Node, {
            T: Name
          }), makeGeneric(_Node, {
            T: Expr
          })]
        }
      };
    }
  }]);

  return Command;
}();
setType("TheGamma.Command", Command);
var Expr = function () {
  function Expr(caseName, fields) {
    _classCallCheck(this, Expr);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Expr, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Expr",
        interfaces: ["FSharpUnion"],
        cases: {
          Binary: [makeGeneric(_Node, {
            T: Expr
          }), makeGeneric(_Node, {
            T: Operator
          }), makeGeneric(_Node, {
            T: Expr
          })],
          Boolean: ["boolean"],
          Call: [makeGeneric(_Node, {
            T: Expr
          }), makeGeneric(_Node, {
            T: makeGeneric(List$1, {
              T: Argument
            })
          })],
          Empty: [],
          Function: [makeGeneric(_Node, {
            T: Name
          }), makeGeneric(_Node, {
            T: Expr
          })],
          List: [makeGeneric(List$1, {
            T: makeGeneric(_Node, {
              T: Expr
            })
          })],
          Member: [makeGeneric(_Node, {
            T: Expr
          }), makeGeneric(_Node, {
            T: Expr
          })],
          Number: ["number"],
          Placeholder: [makeGeneric(_Node, {
            T: Name
          }), makeGeneric(_Node, {
            T: Expr
          })],
          String: ["string"],
          Variable: [makeGeneric(_Node, {
            T: Name
          })]
        }
      };
    }
  }]);

  return Expr;
}();
setType("TheGamma.Expr", Expr);

var ProvidedType = function () {
  function ProvidedType(caseName, fields) {
    _classCallCheck(this, ProvidedType);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(ProvidedType, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.ProvidedType",
        interfaces: ["FSharpUnion"],
        cases: {
          GlobalValue: ["string", makeGeneric(List$1, {
            T: Metadata
          }), Expression, Type],
          NamedType: ["string", Type]
        }
      };
    }
  }]);

  return ProvidedType;
}();
setType("TheGamma.TypeProviders.ProvidedType", ProvidedType);
var ProviderHelpers = function (__exports) {
  var docMeta = __exports.docMeta = function (doc) {
    return new Metadata("http://thegamma.net", "Documentation", doc);
  };

  return __exports;
}({});

var BabelOptions = function () {
  function BabelOptions(presets) {
    _classCallCheck(this, BabelOptions);

    this.presets = presets;
  }

  _createClass(BabelOptions, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "Fable.Helpers.Babel.BabelOptions",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          presets: FableArray("string")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return BabelOptions;
}();
setType("Fable.Helpers.Babel.BabelOptions", BabelOptions);
var BabelResult = function () {
  function BabelResult(code) {
    _classCallCheck(this, BabelResult);

    this.code = code;
  }

  _createClass(BabelResult, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "Fable.Helpers.Babel.BabelResult",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          code: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return BabelResult;
}();
setType("Fable.Helpers.Babel.BabelResult", BabelResult);

var SeriesInternals = function (__exports) {
  var slice = __exports.slice = function (lo, hi, arr) {
    return _Array$from(initialize(hi - lo + 1, function (i) {
      return arr[lo + i];
    }));
  };

  var dictAny = __exports.dictAny = function (v) {
    return new _Map(v);
  };

  var zipUnsorted = __exports.zipUnsorted = function (arr1, arr2) {
    var d1 = dictAny(arr1);
    var d2 = dictAny(arr2);
    var res = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(d1), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var kv1 = _step.value;
        var v2 = d2.has(kv1[0]) ? d2.get(kv1[0]) : null;
        res.push([kv1[0], [kv1[1], v2]]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _getIterator(d2), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var kv2 = _step2.value;

        if (!d1.has(kv2[0])) {
          res.push([kv2[0], [null, kv2[1]]]);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return _Array$from(res);
  };

  var isSortedUsing = __exports.isSortedUsing = function (test, proj, arr) {
    var loop = function loop(i) {
      loop: while (true) {
        if (i === arr.length) {
          return true;
        } else if (test(proj(arr[i - 1]))(proj(arr[i]))) {
          i = i + 1;
          continue loop;
        } else {
          return false;
        }
      }
    };

    if (arr.length === 0) {
      return true;
    } else {
      return loop(1);
    }
  };

  var zipSorted = __exports.zipSorted = function (arr1, arr2) {
    var i1 = 0;
    var i2 = 0;
    var res = [];

    while (i1 < arr1.length ? i2 < arr2.length : false) {
      var patternInput = [arr1[i1], arr2[i2]];
      var v2 = patternInput[1][1];
      var v1 = patternInput[0][1];
      var k2 = patternInput[1][0];
      var k1 = patternInput[0][0];

      if (function (a) {
        return function (b) {
          return (a < b ? -1 : a == b ? 0 : 1) === 0;
        };
      }(k1)(k2)) {
        res.push([k1, [v1, v2]]);
        i1 = i1 + 1;
        i2 = i2 + 1;
      } else if (function (a_1) {
        return function (b_1) {
          return (a_1 < b_1 ? -1 : a_1 == b_1 ? 0 : 1) < 0;
        };
      }(k1)(k2)) {
        res.push([k1, [v1, null]]);
        i1 = i1 + 1;
      } else if (function (a_2) {
        return function (b_2) {
          return (a_2 < b_2 ? -1 : a_2 == b_2 ? 0 : 1) < 0;
        };
      }(k2)(k1)) {
        res.push([k2, [null, v2]]);
        i2 = i2 + 1;
      }
    }

    while (i1 < arr1.length) {
      var patternInput_1 = arr1[i1];
      res.push([patternInput_1[0], [patternInput_1[1], null]]);
      i1 = i1 + 1;
    }

    while (i2 < arr2.length) {
      var patternInput_2 = arr2[i2];
      res.push([patternInput_2[0], [null, patternInput_2[1]]]);
      i2 = i2 + 2;
    }

    return _Array$from(res);
  };

  var zipAny = __exports.zipAny = function (arr1, arr2) {
    var op_LessEqualsDot = function op_LessEqualsDot(a) {
      return function (b) {
        return (a < b ? -1 : a == b ? 0 : 1) <= 0;
      };
    };

    var op_GreaterEqualsDot = function op_GreaterEqualsDot(a_1) {
      return function (b_1) {
        return (a_1 < b_1 ? -1 : a_1 == b_1 ? 0 : 1) >= 0;
      };
    };

    if (isSortedUsing(op_LessEqualsDot, function (tuple) {
      return tuple[0];
    }, arr1) ? isSortedUsing(op_LessEqualsDot, function (tuple_1) {
      return tuple_1[0];
    }, arr2) : false) {
      return zipSorted(arr1, arr2);
    } else if (isSortedUsing(op_GreaterEqualsDot, function (tuple_2) {
      return tuple_2[0];
    }, arr1) ? isSortedUsing(op_GreaterEqualsDot, function (tuple_3) {
      return tuple_3[0];
    }, arr2) : false) {
      return zipSorted(arr1.slice().reverse(), arr2.slice().reverse()).slice().reverse();
    } else {
      return zipUnsorted(arr1, arr2);
    }
  };

  return __exports;
}({});
var helpers = function () {
  function helpers() {
    _classCallCheck(this, helpers);
  }

  _createClass(helpers, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Series.helpers",
        properties: {}
      };
    }
  }]);

  return helpers;
}();
setType("TheGamma.Series.helpers", helpers);

var series = function () {
  function series(data, keyName, valueName, seriesName) {
    _classCallCheck(this, series);

    this.data = data;
    this.keyName = keyName;
    this.valueName = valueName;
    this.seriesName = seriesName;
  }

  _createClass(series, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Series.series",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          data: Interface("TheGamma.Common.Future"),
          keyName: "string",
          valueName: "string",
          seriesName: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "set",
    value: function (data, keyName, valueName, seriesName) {
      return new series(data, keyName != null ? keyName : this.keyName, valueName != null ? valueName : this.valueName, seriesName != null ? seriesName : this.seriesName);
    }
  }, {
    key: "setProperties",
    value: function (keyName, valueName, seriesName) {
      var keyName_1 = keyName != null ? keyName : this.keyName;
      var valueName_1 = valueName != null ? valueName : this.valueName;
      var seriesName_1 = seriesName != null ? seriesName : this.seriesName;
      return new series(this.data, keyName_1, valueName_1, seriesName_1);
    }
  }, {
    key: "sortKeys",
    value: function (reverse$$1) {
      return function (arg00) {
        return function (arg10) {
          var $var5 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var5.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var5.keyName, $var5.valueName, $var5.seriesName);
        };
      }(function (arr) {
        return (equals(reverse$$1, true) ? function (array) {
          return array.slice().reverse();
        } : function (x) {
          return x;
        })(_Array$from(sortWith(function (tupledArg, tupledArg_1) {
          return tupledArg[0] < tupledArg_1[0] ? -1 : tupledArg[0] == tupledArg_1[0] ? 0 : 1;
        }, arr)));
      })(this);
    }
  }, {
    key: "sortValues",
    value: function (reverse$$1) {
      return function (arg00) {
        return function (arg10) {
          var $var6 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var6.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var6.keyName, $var6.valueName, $var6.seriesName);
        };
      }(function (arr) {
        return (equals(reverse$$1, true) ? function (array) {
          return array.slice().reverse();
        } : function (x) {
          return x;
        })(_Array$from(sortWith(function (tupledArg, tupledArg_1) {
          return tupledArg[1] < tupledArg_1[1] ? -1 : tupledArg[1] == tupledArg_1[1] ? 0 : 1;
        }, arr)));
      })(this);
    }
  }, {
    key: "sortBy",
    value: function (f, reverse$$1) {
      return function (arg00) {
        return function (arg10) {
          var $var7 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var7.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var7.keyName, $var7.valueName, $var7.seriesName);
        };
      }(function (arr) {
        return (equals(reverse$$1, true) ? function (array) {
          return array.slice().reverse();
        } : function (x) {
          return x;
        })(_Array$from(sortWith(function (tupledArg, tupledArg_1) {
          return f(tupledArg[1]) < f(tupledArg_1[1]) ? -1 : f(tupledArg[1]) == f(tupledArg_1[1]) ? 0 : 1;
        }, arr)));
      })(this);
    }
  }, {
    key: "reverse",
    value: function () {
      return function (arg00) {
        return function (arg10) {
          var $var8 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var8.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var8.keyName, $var8.valueName, $var8.seriesName);
        };
      }(function (array) {
        return array.slice().reverse();
      })(this);
    }
  }, {
    key: "take",
    value: function (count$$1) {
      return function (arg00) {
        return function (arg10) {
          var $var9 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var9.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var9.keyName, $var9.valueName, $var9.seriesName);
        };
      }(function (arr) {
        return SeriesInternals.slice(0, (arr.length < count$$1 ? arr.length : count$$1) - 1, arr);
      })(this);
    }
  }, {
    key: "skip",
    value: function (count$$1) {
      return function (arg00) {
        return function (arg10) {
          var $var10 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var10.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var10.keyName, $var10.valueName, $var10.seriesName);
        };
      }(function (arr) {
        return SeriesInternals.slice(arr.length < count$$1 ? arr.length : count$$1, arr.length - 1, arr);
      })(this);
    }
  }, {
    key: "shuffle",
    value: function () {
      return function (arg00) {
        return function (arg10) {
          var $var11 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var11.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var11.keyName, $var11.valueName, $var11.seriesName);
        };
      }(function (arr) {
        var rnd = {};
        return _Array$from(sortWith(function (x, y) {
          return compare(function (_arg7) {
            return randomNext(0, 2147483647);
          }(x), function (_arg7) {
            return randomNext(0, 2147483647);
          }(y));
        }, arr));
      })(this);
    }
  }, {
    key: "map",
    value: function (f) {
      return function (arg00) {
        return function (arg10) {
          var $var12 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var12.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var12.keyName, $var12.valueName, $var12.seriesName);
        };
      }(function () {
        var mapping = function mapping(tupledArg) {
          return [tupledArg[0], f(tupledArg[1])];
        };

        return function (array) {
          return array.map(mapping);
        };
      }())(this);
    }
  }, {
    key: "mapKeys",
    value: function (f) {
      return function (arg00) {
        return function (arg10) {
          var $var13 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var13.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var13.keyName, $var13.valueName, $var13.seriesName);
        };
      }(function () {
        var mapping = function mapping(tupledArg) {
          return [f(tupledArg[0]), tupledArg[1]];
        };

        return function (array) {
          return array.map(mapping);
        };
      }())(this);
    }
  }, {
    key: "mapPairs",
    value: function (f) {
      return function (arg00) {
        return function (arg10) {
          var $var14 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var14.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var14.keyName, $var14.valueName, $var14.seriesName);
        };
      }(function () {
        var mapping = function mapping(tupledArg) {
          return [tupledArg[0], f(tupledArg[0])(tupledArg[1])];
        };

        return function (array) {
          return array.map(mapping);
        };
      }())(this);
    }
  }, {
    key: "filter",
    value: function (f) {
      return function (arg00) {
        return function (arg10) {
          var $var15 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var15.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var15.keyName, $var15.valueName, $var15.seriesName);
        };
      }(function () {
        var predicate = function predicate($var16) {
          return f(function (tuple) {
            return tuple[1];
          }($var16));
        };

        return function (array) {
          return array.filter(predicate);
        };
      }())(this);
    }
  }, {
    key: "filterIndex",
    value: function (f) {
      return function (arg00) {
        return function (arg10) {
          var $var17 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var17.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var17.keyName, $var17.valueName, $var17.seriesName);
        };
      }(function ($var19) {
        return function () {
          return function () {
            var mapping = function mapping(tuple_1) {
              return tuple_1[1];
            };

            return function (array) {
              return array.map(mapping);
            };
          }();
        }()(function ($var18) {
          return _Array$from(mapIndexed(function (i, v) {
            return [f(i), v];
          }, $var18)).filter(function (tuple) {
            return tuple[0];
          });
        }($var19));
      })(this);
    }
  }, {
    key: "choose",
    value: function (f) {
      return function (arg00) {
        return function (arg10) {
          var $var20 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var20.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var20.keyName, $var20.valueName, $var20.seriesName);
        };
      }(function () {
        var chooser = function chooser(tupledArg) {
          var matchValue = f(tupledArg[1]);

          if (matchValue != null) {
            return [tupledArg[0], matchValue];
          } else {
            return null;
          }
        };

        return function (array) {
          return _Array$from(choose(chooser, array));
        };
      }())(this);
    }
  }, {
    key: "joinOuter",
    value: function (s2) {
      var _this = this;

      var data = function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(Async_AwaitFuture_Static(_this.data), function (_arg4) {
            return builder_.Bind(Async_AwaitFuture_Static(s2.data), function (_arg5) {
              return builder_.Return(SeriesInternals.zipAny(_arg4, _arg5));
            });
          });
        });
      }(singleton$2);

      return series.create(data, this.keyName, "Values", this.seriesName + " and " + s2.seriesName);
    }
  }, {
    key: "joinInner",
    value: function (s2) {
      return this.joinOuter(s2).choose(function (_arg6) {
        var $var21 = _arg6[0] != null ? _arg6[1] != null ? [0, _arg6[0], _arg6[1]] : [1] : [1];

        switch ($var21[0]) {
          case 0:
            return [$var21[1], $var21[2]];

          case 1:
            return null;
        }
      });
    }
  }, {
    key: "appendScalar",
    value: function (key, _value) {
      return function (arg00) {
        return function (arg10) {
          var $var22 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var22.data), function (_arg1) {
                return builder_.Return(arg00(_arg1));
              });
            });
          }(singleton$2));
          return new series(nd, $var22.keyName, $var22.valueName, $var22.seriesName);
        };
      }(function (arr) {
        return arr.concat([[key, _value]]);
      })(this);
    }
  }, {
    key: "append",
    value: function (s2) {
      var _this2 = this;

      return this.set(Async_StartAsFuture_Static(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(Async_AwaitFuture_Static(_this2.data), function (_arg7) {
            return builder_.Bind(Async_AwaitFuture_Static(s2.data), function (_arg8) {
              return builder_.Return(_arg7.concat(_arg8));
            });
          });
        });
      }(singleton$2)));
    }
  }, {
    key: "realign",
    value: function (newKeys, defaultValue) {
      return function (arg00) {
        return function (arg10) {
          var $var23 = arg10;
          var nd = Async_StartAsFuture_Static(function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(Async_AwaitFuture_Static($var23.data), function (_arg2) {
                return builder_.ReturnFrom(arg00(_arg2));
              });
            });
          }(singleton$2));
          return new series(nd, $var23.keyName, $var23.valueName, $var23.seriesName);
        };
      }(function (arr) {
        return function (builder__1) {
          return builder__1.Delay(function () {
            return builder__1.Bind(Async_AwaitFuture_Static(newKeys.data), function (_arg9) {
              var newKeys_1 = _arg9.map(function (tupledArg) {
                return tupledArg[1];
              });

              var lookup = create$6(arr, new GenericComparer(compare));
              return builder__1.Return(newKeys_1.map(function (k) {
                var matchValue = tryFind$1(k, lookup);

                if (matchValue == null) {
                  return [k, defaultValue];
                } else {
                  return [k, matchValue];
                }
              }));
            });
          });
        }(singleton$2);
      })(this);
    }
  }, {
    key: "preview",
    value: function () {
      return this.take(10);
    }
  }], [{
    key: "create",
    value: function (data, keyName, valueName, seriesName) {
      return new series(Async_StartAsFuture_Static(data), keyName, valueName, seriesName);
    }
  }, {
    key: "values",
    value: function (_values) {
      var data = Async_StartAsFuture_Static(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Return(_Array$from(mapIndexed(function (i, v) {
            return [i, v];
          }, _values)));
        });
      }(singleton$2));
      return new series(data, "key", "value", "");
    }
  }, {
    key: "range",
    value: function (from, to) {
      return series.values(Int32Array.from(range(from, to)));
    }
  }, {
    key: "rangeBy",
    value: function (from, to, step) {
      return series.values(Int32Array.from(rangeStep(from, step, to)));
    }
  }, {
    key: "ordinal",
    value: function (data, keyName, valueName, seriesName) {
      var data_1 = Async_StartAsFuture_Static(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(data, function (_arg3) {
            return builder_.Return(_Array$from(mapIndexed(function (i, v) {
              return [i, v];
            }, _arg3)));
          });
        });
      }(singleton$2));
      return new series(data_1, keyName, valueName, seriesName);
    }
  }]);

  return series;
}();

setType("TheGamma.Series.series", series);

function convertTupleSequence(f, g, data) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.Bind(data, function (_arg1) {
        return builder_.Return(_arg1.map(function (tupledArg) {
          return [f(tupledArg[0]), g(tupledArg[1])];
        }));
      });
    });
  }(singleton$2);
}

function trimLeft(c, s) {
  return _Array$from(skipWhile(function (y) {
    return c === y;
  }, s.split(""))).join('');
}
function trimRight(c, s) {
  return _Array$from(skipWhile(function (y) {
    return c === y;
  }, s.split("").slice().reverse())).slice().reverse().join('');
}
function concatUrl(a, b) {
  return trimRight("/", a) + "/" + trimLeft("/", b);
}
var RuntimeContext = function () {
  _createClass(RuntimeContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProvidersRuntime.RuntimeContext",
        properties: {
          root: "string",
          trace: "string"
        }
      };
    }
  }]);

  function RuntimeContext(root, cookies, trace) {
    _classCallCheck(this, RuntimeContext);

    this["root@19"] = root;
    this.cookies = cookies;
    this["trace@19"] = trace;
  }

  _createClass(RuntimeContext, [{
    key: "addTrace",
    value: function (suffix) {
      var _this = this;

      var traces = toList(delay(function () {
        return append(!isNullOrEmpty(_this["trace@19"]) ? singleton(_this["trace@19"]) : empty(), delay(function () {
          return !isNullOrEmpty(suffix) ? singleton(suffix) : empty();
        }));
      }));
      return new RuntimeContext(this["root@19"], this.cookies, join("&", traces));
    }
  }, {
    key: "getValue",
    value: function (endpoint) {
      var _this2 = this;

      return function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(Http.Request("POST", concatUrl(_this2["root@19"], endpoint), _this2["trace@19"], _this2.cookies), function (_arg1) {
            return builder_.Return(JSON.parse(_arg1));
          });
        });
      }(singleton$2);
    }
  }, {
    key: "root",
    get: function () {
      return this["root@19"];
    }
  }, {
    key: "trace",
    get: function () {
      return this["trace@19"];
    }
  }]);

  return RuntimeContext;
}();
setType("TheGamma.TypeProvidersRuntime.RuntimeContext", RuntimeContext);
var PivotContext = function () {
  _createClass(PivotContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProvidersRuntime.PivotContext",
        properties: {}
      };
    }
  }]);

  function PivotContext(root, calls) {
    _classCallCheck(this, PivotContext);

    this.root = root;
    this.calls = calls;
  }

  _createClass(PivotContext, [{
    key: "addCall",
    value: function (callid, values) {
      return new PivotContext(this.root, [[callid, values]].concat(this.calls));
    }
  }, {
    key: "getData",
    value: function (conv, tfs, isPreview) {
      var _this3 = this;

      return function (builder_) {
        return builder_.Delay(function () {
          var url = function () {
            var folder = function folder(tfs_1) {
              return function (tupledArg) {
                var vals = join(",", map$3(function (value) {
                  return toString$2(value);
                }, tupledArg[1]));
                return replace$$1(tfs_1, tupledArg[0], vals);
              };
            };

            return function (array) {
              return fold(function ($var119, $var120) {
                return folder($var119)($var120);
              }, tfs, array);
            };
          }()(_this3.calls);

          var url_1 = _this3.root + "?" + url + (isPreview ? "&preview" : "");
          Log.trace("runtime", "Pivot: %s", url_1);
          return builder_.Bind(Http.Request("GET", url_1), function (_arg1) {
            return builder_.Return(_Array$from(map$3(conv, JSON.parse(_arg1))));
          });
        });
      }(singleton$2);
    }
  }]);

  return PivotContext;
}();
setType("TheGamma.TypeProvidersRuntime.PivotContext", PivotContext);

var ChartData = function () {
  function ChartData(data) {
    _classCallCheck(this, ChartData);

    this.data = data;
  }

  _createClass(ChartData, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.ChartData",
        interfaces: ["FSharpRecord"],
        properties: {
          data: Async$1
        }
      };
    }
  }]);

  return ChartData;
}();
setType("TheGamma.GoogleCharts.ChartData", ChartData);
var LazyCharting = function (__exports) {
  var chartsToDraw = __exports.chartsToDraw = [];
  var googleLoaded = (Object.defineProperty(__exports, 'googleLoaded', {
    get: function get() {
      return googleLoaded;
    },
    set: function set(x) {
      return googleLoaded = x;
    }
  }), false);

  var drawChartOnLoad = __exports.drawChartOnLoad = function (f) {
    if (googleLoaded) {
      f(null);
    } else {
      chartsToDraw.push(f);
    }
  };

  if (typeof google != "undefined") google.load('visualization', '1', {
    'packages': ['corechart'],
    'callback': function () {
      (function () {
        googleLoaded = true;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _getIterator(chartsToDraw), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var f = _step.value;
            f(null);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      })();
    }
  });
  return __exports;
}({});
var Helpers = function (__exports) {
  var copy = __exports.copy = function (o, prop) {
    if (o == null) {
      return undefined;
    } else {
      return o[prop];
    }
  };

  var orDefault = __exports.orDefault = function (newValue) {
    if (newValue != null) {
      return newValue;
    } else {
      return undefined;
    }
  };

  var right = __exports.right = function (o, prop, newValue) {
    if (newValue != null) {
      return newValue;
    } else if (o == null) {
      return undefined;
    } else {
      return o[prop];
    }
  };

  var showChart = __exports.showChart = function (chart, outputId) {
    LazyCharting.drawChartOnLoad(function () {
      (function (arg00) {
        startImmediate(arg00);
      })(function (builder_) {
        return builder_.Delay(function () {
          return builder_.TryWith(builder_.Delay(function () {
            return builder_.Bind(chart["data"].data, function (_arg1) {
              var ctor = eval("(function(a) { return new google.visualization." + chart.typeName + " (a); })");
              var ch = ctor(document.getElementById(outputId));
              if (chart.options.height == undefined) chart.options.height = 400;
              ch.draw(_arg1, chart.options);
              return builder_.Zero();
            });
          }), function (_arg2) {
            Log.error("google", "Error when getting data or rendering chart: %O", _arg2);
            return builder_.Zero();
          });
        });
      }(singleton$2));
    });
  };

  return __exports;
}({});
var ChartDataOperations = function (__exports) {
  var collect$$1 = __exports.collect = function (f, l) {
    return function (builder_) {
      return builder_.Delay(function () {
        return l.tail == null ? builder_.Return(new List$1()) : builder_.Bind(f(l.head), function (_arg1) {
          return builder_.Bind(collect$$1(f, l.tail), function (_arg2) {
            return builder_.Return(append$1(_arg1, _arg2));
          });
        });
      });
    }(singleton$2);
  };

  var oneKeyValue = __exports.oneKeyValue = function (keyType, v) {
    return new ChartData(function (builder_) {
      return builder_.Delay(function () {
        var data = new google.visualization.DataTable();
        data.addColumn(keyType, v.keyName);
        data.addColumn("number", v.seriesName);
        return builder_.Bind(Async_AwaitFuture_Static(v.mapPairs(function (k) {
          return function (v_1) {
            return [k, v_1];
          };
        }).data), function (_arg1) {
          (function (arg00) {
            data.addRows(arg00);
          })(_arg1.map(function (tuple) {
            return tuple[1];
          }));

          return builder_.Return(data);
        });
      });
    }(singleton$2));
  };

  var oneKeyTwoValues = __exports.oneKeyTwoValues = function (keyType, v) {
    return new ChartData(function (builder_) {
      return builder_.Delay(function () {
        var data = new google.visualization.DataTable();
        data.addColumn(keyType, v.keyName);
        data.addColumn("number", v.seriesName);
        data.addColumn("number", v.seriesName);
        return builder_.Bind(Async_AwaitFuture_Static(v.mapPairs(function (k) {
          return function (tupledArg) {
            return [k, tupledArg[0], tupledArg[1]];
          };
        }).data), function (_arg1) {
          (function (arg00) {
            data.addRows(arg00);
          })(_arg1.map(function (tuple) {
            return tuple[1];
          }));

          return builder_.Return(data);
        });
      });
    }(singleton$2));
  };

  var oneKeyAppendValues = __exports.oneKeyAppendValues = function (keyType, vs, colors) {
    return new ChartData(function (builder_) {
      return builder_.Delay(function () {
        var data = new google.visualization.DataTable();
        data.addColumn(keyType, vs[0].keyName);
        data.addColumn("number", vs[0].valueName);
        data.addColumn({
          type: "string",
          role: "style"
        });
        return builder_.Bind(collect$$1(function (tupledArg) {
          return function (builder__1) {
            return builder__1.Delay(function () {
              return builder__1.Bind(Async_AwaitFuture_Static(tupledArg[0].mapPairs(function (k) {
                return function (v) {
                  return [k, v, tupledArg[1]];
                };
              }).data), function (_arg1) {
                return builder__1.Return(ofArray$1(_arg1.map(function (tuple) {
                  return tuple[1];
                })));
              });
            });
          }(singleton$2);
        }, ofArray$1(_Array$from(zip(vs, colors)))), function (_arg2) {
          (function (arg00) {
            data.addRows(arg00);
          })(_Array$from(toList(sortWith(function (x, y) {
            return -compare(function (tupledArg_2) {
              return tupledArg_2[1];
            }(x), function (tupledArg_2) {
              return tupledArg_2[1];
            }(y));
          }, _arg2))).map(function (tupledArg_1) {
            return [tupledArg_1[0], tupledArg_1[1], tupledArg_1[2]];
          }));

          return builder_.Return(data);
        });
      });
    }(singleton$2));
  };

  var oneKeyNValues = __exports.oneKeyNValues = function (keyType, v) {
    return new ChartData(function (builder_) {
      return builder_.Delay(function () {
        var data = new google.visualization.DataTable();
        return builder_.Bind(Async_AwaitFuture_Static(v.data), function (_arg1) {
          var v_1 = _arg1.map(function (tuple) {
            return tuple[1];
          });

          data.addColumn(keyType, v_1[0].keyName);
          return builder_.Combine(builder_.For(range(0, v_1.length - 1), function (_arg2) {
            data.addColumn("number", v_1[_arg2].seriesName);
            return builder_.Zero();
          }), builder_.Delay(function () {
            var head$$1 = v_1[0].map(function (v_2) {
              return create$6(ofArray$1([[0, v_2]]), new GenericComparer(compare));
            });

            var tail$$1 = _Array$from(mapIndexed(function (i, v_3) {
              return [i + 1, v_3];
            }, SeriesInternals.slice(1, v_1.length - 1, v_1)));

            var all = fold(function (s1, tupledArg) {
              return s1.joinOuter(tupledArg[1]).map(function (tupledArg_1) {
                var matchValue = [defaultArg(tupledArg_1[0], create$6(null, new GenericComparer(compare))), tupledArg_1[1]];

                if (matchValue[1] == null) {
                  return matchValue[0];
                } else {
                  var r = matchValue[1];
                  return add$3(tupledArg[0], r, matchValue[0]);
                }
              });
            }, head$$1, tail$$1);
            return builder_.Bind(Async_AwaitFuture_Static(all.mapPairs(function (k) {
              return function (vals) {
                var data_1 = _Array$from(initialize(v_1.length, function (i_1) {
                  return defaultArg(tryFind$1(i_1, vals), undefined);
                }));

                return _Array$from(append([k], data_1));
              };
            }).data), function (_arg3) {
              (function (arg00) {
                data.addRows(arg00);
              })(_arg3.map(function (tuple_1) {
                return tuple_1[1];
              }));

              return builder_.Return(data);
            });
          }));
        });
      });
    }(singleton$2));
  };

  var twoValues = __exports.twoValues = function (v1, v2) {
    return new ChartData(function (builder_) {
      return builder_.Delay(function () {
        var data = new google.visualization.DataTable();
        data.addColumn("number", v1.seriesName);
        data.addColumn("number", v2.seriesName);
        return builder_.Bind(Async_AwaitFuture_Static(v1.joinInner(v2).map(function (tupledArg) {
          return [tupledArg[0], tupledArg[1]];
        }).data), function (_arg1) {
          (function (arg00) {
            data.addRows(arg00);
          })(_arg1.map(function (tuple) {
            return tuple[1];
          }));

          return builder_.Return(data);
        });
      });
    }(singleton$2));
  };

  return __exports;
}({});

var ChartSizeAxis = function () {
    function ChartSizeAxis(maxSize, maxValue, minSize, minValue) {
        _classCallCheck(this, ChartSizeAxis);

        this.maxSize = maxSize;
        this.maxValue = maxValue;
        this.minSize = minSize;
        this.minValue = minValue;
    }

    _createClass(ChartSizeAxis, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartSizeAxis",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    maxSize: "number",
                    maxValue: "number",
                    minSize: "number",
                    minValue: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartSizeAxis;
}();
setType("TheGamma.GoogleCharts.Options.ChartSizeAxis", ChartSizeAxis);
var ChartTextStyle = function () {
    function ChartTextStyle(fontName, fontSize, bold, italic, color, auraColor, opacity) {
        _classCallCheck(this, ChartTextStyle);

        this.fontName = fontName;
        this.fontSize = fontSize;
        this.bold = bold;
        this.italic = italic;
        this.color = color;
        this.auraColor = auraColor;
        this.opacity = opacity;
    }

    _createClass(ChartTextStyle, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartTextStyle",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    fontName: "string",
                    fontSize: "number",
                    bold: "boolean",
                    italic: "boolean",
                    color: "string",
                    auraColor: "string",
                    opacity: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartTextStyle;
}();
setType("TheGamma.GoogleCharts.Options.ChartTextStyle", ChartTextStyle);
var ChartTooltip = function () {
    function ChartTooltip(isHtml, showColorCode, textStyle, trigger) {
        _classCallCheck(this, ChartTooltip);

        this.isHtml = isHtml;
        this.showColorCode = showColorCode;
        this.textStyle = textStyle;
        this.trigger = trigger;
    }

    _createClass(ChartTooltip, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartTooltip",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    isHtml: "boolean",
                    showColorCode: "boolean",
                    textStyle: ChartTextStyle,
                    trigger: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartTooltip;
}();
setType("TheGamma.GoogleCharts.Options.ChartTooltip", ChartTooltip);
var ChartLegend = function () {
    function ChartLegend(alignment, maxLines, position, textStyle, numberFormat) {
        _classCallCheck(this, ChartLegend);

        this.alignment = alignment;
        this.maxLines = maxLines;
        this.position = position;
        this.textStyle = textStyle;
        this.numberFormat = numberFormat;
    }

    _createClass(ChartLegend, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartLegend",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    alignment: "string",
                    maxLines: "number",
                    position: "string",
                    textStyle: ChartTextStyle,
                    numberFormat: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartLegend;
}();
setType("TheGamma.GoogleCharts.Options.ChartLegend", ChartLegend);
var ChartColorAxis = function () {
    function ChartColorAxis(minValue, maxValue, values, colors, legend) {
        _classCallCheck(this, ChartColorAxis);

        this.minValue = minValue;
        this.maxValue = maxValue;
        this.values = values;
        this.colors = colors;
        this.legend = legend;
    }

    _createClass(ChartColorAxis, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartColorAxis",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    minValue: "number",
                    maxValue: "number",
                    values: FableArray(Float64Array, true),
                    colors: FableArray("string"),
                    legend: ChartLegend
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartColorAxis;
}();
setType("TheGamma.GoogleCharts.Options.ChartColorAxis", ChartColorAxis);
var GeoChartMagnifyingGlass = function () {
    function GeoChartMagnifyingGlass(enable, zoomFactor) {
        _classCallCheck(this, GeoChartMagnifyingGlass);

        this.enable = enable;
        this.zoomFactor = zoomFactor;
    }

    _createClass(GeoChartMagnifyingGlass, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.GeoChartMagnifyingGlass",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    enable: "boolean",
                    zoomFactor: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return GeoChartMagnifyingGlass;
}();
setType("TheGamma.GoogleCharts.Options.GeoChartMagnifyingGlass", GeoChartMagnifyingGlass);
var GeoChartOptions = function () {
    function GeoChartOptions(backgroundColor, colorAxis, datalessRegionColor, displayMode, enableRegionInteractivity, height, keepAspectRatio, legend, region, magnifyingGlass, markerOpacity, resolution, sizeAxis, tooltip, width) {
        _classCallCheck(this, GeoChartOptions);

        this.backgroundColor = backgroundColor;
        this.colorAxis = colorAxis;
        this.datalessRegionColor = datalessRegionColor;
        this.displayMode = displayMode;
        this.enableRegionInteractivity = enableRegionInteractivity;
        this.height = height;
        this.keepAspectRatio = keepAspectRatio;
        this.legend = legend;
        this.region = region;
        this.magnifyingGlass = magnifyingGlass;
        this.markerOpacity = markerOpacity;
        this.resolution = resolution;
        this.sizeAxis = sizeAxis;
        this.tooltip = tooltip;
        this.width = width;
    }

    _createClass(GeoChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.GeoChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    backgroundColor: Any,
                    colorAxis: ChartColorAxis,
                    datalessRegionColor: "string",
                    displayMode: "string",
                    enableRegionInteractivity: "boolean",
                    height: "number",
                    keepAspectRatio: "boolean",
                    legend: ChartLegend,
                    region: "string",
                    magnifyingGlass: GeoChartMagnifyingGlass,
                    markerOpacity: "number",
                    resolution: "string",
                    sizeAxis: ChartSizeAxis,
                    tooltip: ChartTooltip,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return GeoChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.GeoChartOptions", GeoChartOptions);
var ChartBoxStyleGradient = function () {
    function ChartBoxStyleGradient(color1, color2, x1, y1, x2, y2, useObjectBoundingBoxUnits) {
        _classCallCheck(this, ChartBoxStyleGradient);

        this.color1 = color1;
        this.color2 = color2;
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.useObjectBoundingBoxUnits = useObjectBoundingBoxUnits;
    }

    _createClass(ChartBoxStyleGradient, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartBoxStyleGradient",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color1: "string",
                    color2: "string",
                    x1: "string",
                    y1: "string",
                    x2: "string",
                    y2: "string",
                    useObjectBoundingBoxUnits: "boolean"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartBoxStyleGradient;
}();
setType("TheGamma.GoogleCharts.Options.ChartBoxStyleGradient", ChartBoxStyleGradient);
var ChartBoxStyle = function () {
    function ChartBoxStyle(stroke, strokeWidth, rx, ry, gradient) {
        _classCallCheck(this, ChartBoxStyle);

        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
        this.rx = rx;
        this.ry = ry;
        this.gradient = gradient;
    }

    _createClass(ChartBoxStyle, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartBoxStyle",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    stroke: "string",
                    strokeWidth: "number",
                    rx: "number",
                    ry: "number",
                    gradient: ChartBoxStyleGradient
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartBoxStyle;
}();
setType("TheGamma.GoogleCharts.Options.ChartBoxStyle", ChartBoxStyle);
var ChartAnnotations = function () {
    function ChartAnnotations(boxStyle, textStyle) {
        _classCallCheck(this, ChartAnnotations);

        this.boxStyle = boxStyle;
        this.textStyle = textStyle;
    }

    _createClass(ChartAnnotations, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartAnnotations",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    boxStyle: ChartBoxStyle,
                    textStyle: ChartTextStyle
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartAnnotations;
}();
setType("TheGamma.GoogleCharts.Options.ChartAnnotations", ChartAnnotations);
var ChartCrosshairFocused = function () {
    function ChartCrosshairFocused(color, opacity) {
        _classCallCheck(this, ChartCrosshairFocused);

        this.color = color;
        this.opacity = opacity;
    }

    _createClass(ChartCrosshairFocused, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartCrosshairFocused",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color: "string",
                    opacity: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartCrosshairFocused;
}();
setType("TheGamma.GoogleCharts.Options.ChartCrosshairFocused", ChartCrosshairFocused);
var ChartCrosshairSelected = function () {
    function ChartCrosshairSelected(color, opacity) {
        _classCallCheck(this, ChartCrosshairSelected);

        this.color = color;
        this.opacity = opacity;
    }

    _createClass(ChartCrosshairSelected, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartCrosshairSelected",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color: "string",
                    opacity: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartCrosshairSelected;
}();
setType("TheGamma.GoogleCharts.Options.ChartCrosshairSelected", ChartCrosshairSelected);
var ChartCrosshair = function () {
    function ChartCrosshair(color, focused, opacity, orientation, selected, trigger) {
        _classCallCheck(this, ChartCrosshair);

        this.color = color;
        this.focused = focused;
        this.opacity = opacity;
        this.orientation = orientation;
        this.selected = selected;
        this.trigger = trigger;
    }

    _createClass(ChartCrosshair, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartCrosshair",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color: "string",
                    focused: ChartCrosshairFocused,
                    opacity: "number",
                    orientation: "string",
                    selected: ChartCrosshairSelected,
                    trigger: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartCrosshair;
}();
setType("TheGamma.GoogleCharts.Options.ChartCrosshair", ChartCrosshair);
var ChartExplorer = function () {
    function ChartExplorer(actions, axis, keepInBounds, maxZoomIn, maxZoomOut, zoomDelta) {
        _classCallCheck(this, ChartExplorer);

        this.actions = actions;
        this.axis = axis;
        this.keepInBounds = keepInBounds;
        this.maxZoomIn = maxZoomIn;
        this.maxZoomOut = maxZoomOut;
        this.zoomDelta = zoomDelta;
    }

    _createClass(ChartExplorer, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartExplorer",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    actions: FableArray("string"),
                    axis: "string",
                    keepInBounds: "boolean",
                    maxZoomIn: "number",
                    maxZoomOut: "number",
                    zoomDelta: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartExplorer;
}();
setType("TheGamma.GoogleCharts.Options.ChartExplorer", ChartExplorer);
var ChartStroke = function () {
    function ChartStroke(stroke, strokeWidth, fill) {
        _classCallCheck(this, ChartStroke);

        this.stroke = stroke;
        this.strokeWidth = strokeWidth;
        this.fill = fill;
    }

    _createClass(ChartStroke, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartStroke",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    stroke: "string",
                    strokeWidth: "number",
                    fill: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartStroke;
}();
setType("TheGamma.GoogleCharts.Options.ChartStroke", ChartStroke);
var ChartArea = function () {
    function ChartArea(top, left, width, height) {
        _classCallCheck(this, ChartArea);

        this.top = top;
        this.left = left;
        this.width = width;
        this.height = height;
    }

    _createClass(ChartArea, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartArea",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    top: Any,
                    left: Any,
                    width: Any,
                    height: Any
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return ChartArea;
}();
setType("TheGamma.GoogleCharts.Options.ChartArea", ChartArea);
var TransitionAnimation = function () {
    function TransitionAnimation(duration, easing) {
        _classCallCheck(this, TransitionAnimation);

        this.duration = duration;
        this.easing = easing;
    }

    _createClass(TransitionAnimation, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.TransitionAnimation",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    duration: "number",
                    easing: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return TransitionAnimation;
}();
setType("TheGamma.GoogleCharts.Options.TransitionAnimation", TransitionAnimation);
var ChartGridlines = function () {
    function ChartGridlines(color, count) {
        _classCallCheck(this, ChartGridlines);

        this.color = color;
        this.count = count;
    }

    _createClass(ChartGridlines, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartGridlines",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color: "string",
                    count: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartGridlines;
}();
setType("TheGamma.GoogleCharts.Options.ChartGridlines", ChartGridlines);
var ChartViewWindow = function () {
    function ChartViewWindow(max, min) {
        _classCallCheck(this, ChartViewWindow);

        this.max = max;
        this.min = min;
    }

    _createClass(ChartViewWindow, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartViewWindow",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    max: "number",
                    min: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartViewWindow;
}();
setType("TheGamma.GoogleCharts.Options.ChartViewWindow", ChartViewWindow);
var ChartAxis = function () {
    function ChartAxis(baseline, baselineColor, direction, format, gridlines, minorGridlines, logScale, textPosition, textStyle, ticks, title, titleTextStyle, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode, viewWindow) {
        _classCallCheck(this, ChartAxis);

        this.baseline = baseline;
        this.baselineColor = baselineColor;
        this.direction = direction;
        this.format = format;
        this.gridlines = gridlines;
        this.minorGridlines = minorGridlines;
        this.logScale = logScale;
        this.textPosition = textPosition;
        this.textStyle = textStyle;
        this.ticks = ticks;
        this.title = title;
        this.titleTextStyle = titleTextStyle;
        this.allowContainerBoundaryTextCufoff = allowContainerBoundaryTextCufoff;
        this.slantedText = slantedText;
        this.slantedTextAngle = slantedTextAngle;
        this.maxAlternation = maxAlternation;
        this.maxTextLines = maxTextLines;
        this.minTextSpacing = minTextSpacing;
        this.showTextEvery = showTextEvery;
        this.maxValue = maxValue;
        this.minValue = minValue;
        this.viewWindowMode = viewWindowMode;
        this.viewWindow = viewWindow;
    }

    _createClass(ChartAxis, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartAxis",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    baseline: "number",
                    baselineColor: "string",
                    direction: "number",
                    format: "string",
                    gridlines: ChartGridlines,
                    minorGridlines: ChartGridlines,
                    logScale: "boolean",
                    textPosition: "string",
                    textStyle: ChartTextStyle,
                    ticks: FableArray(Any),
                    title: "string",
                    titleTextStyle: ChartTextStyle,
                    allowContainerBoundaryTextCufoff: "boolean",
                    slantedText: "boolean",
                    slantedTextAngle: "number",
                    maxAlternation: "number",
                    maxTextLines: "number",
                    minTextSpacing: "number",
                    showTextEvery: "number",
                    maxValue: "number",
                    minValue: "number",
                    viewWindowMode: "string",
                    viewWindow: ChartViewWindow
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return ChartAxis;
}();
setType("TheGamma.GoogleCharts.Options.ChartAxis", ChartAxis);
var ChartBoundingBox = function () {
    function ChartBoundingBox(left, top, width, height) {
        _classCallCheck(this, ChartBoundingBox);

        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
    }

    _createClass(ChartBoundingBox, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartBoundingBox",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    left: "number",
                    top: "number",
                    width: "number",
                    height: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartBoundingBox;
}();
setType("TheGamma.GoogleCharts.Options.ChartBoundingBox", ChartBoundingBox);
var GroupWidth = function () {
    function GroupWidth(groupWidth) {
        _classCallCheck(this, GroupWidth);

        this.groupWidth = groupWidth;
    }

    _createClass(GroupWidth, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.GroupWidth",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    groupWidth: Any
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return GroupWidth;
}();
setType("TheGamma.GoogleCharts.Options.GroupWidth", GroupWidth);
var Trendline = function () {
    function Trendline(color, lineWidth, labelInLegend, opacity, pointSize, pointsVisible, showR2, type, visibleInLegend) {
        _classCallCheck(this, Trendline);

        this.color = color;
        this.lineWidth = lineWidth;
        this.labelInLegend = labelInLegend;
        this.opacity = opacity;
        this.pointSize = pointSize;
        this.pointsVisible = pointsVisible;
        this.showR2 = showR2;
        this.type = type;
        this.visibleInLegend = visibleInLegend;
    }

    _createClass(Trendline, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.Trendline",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color: "string",
                    lineWidth: "number",
                    labelInLegend: "string",
                    opacity: "number",
                    pointSize: "number",
                    pointsVisible: "boolean",
                    showR2: "boolean",
                    type: "string",
                    visibleInLegend: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return Trendline;
}();
setType("TheGamma.GoogleCharts.Options.Trendline", Trendline);
var ScatterChartOptions = function () {
    function ScatterChartOptions(aggregationTarget, animation, annotations, axisTitlesPosition, backgroundColor, chartArea, colors, crosshair, curveType, dataOpacity, enableInteractivity, explorer, fontSize, fontName, forceIFrame, hAxis, height, legend, lineWidth, pointSize, selectionMode, series, theme, title, titlePosition, titleTextStyle, tooltip, trendlines, vAxis, width) {
        _classCallCheck(this, ScatterChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.annotations = annotations;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.chartArea = chartArea;
        this.colors = colors;
        this.crosshair = crosshair;
        this.curveType = curveType;
        this.dataOpacity = dataOpacity;
        this.enableInteractivity = enableInteractivity;
        this.explorer = explorer;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.forceIFrame = forceIFrame;
        this.hAxis = hAxis;
        this.height = height;
        this.legend = legend;
        this.lineWidth = lineWidth;
        this.pointSize = pointSize;
        this.selectionMode = selectionMode;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.trendlines = trendlines;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(ScatterChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ScatterChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    annotations: ChartAnnotations,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    crosshair: ChartCrosshair,
                    curveType: "string",
                    dataOpacity: "number",
                    enableInteractivity: "boolean",
                    explorer: ChartExplorer,
                    fontSize: "number",
                    fontName: "string",
                    forceIFrame: "boolean",
                    hAxis: ChartAxis,
                    height: "number",
                    legend: ChartLegend,
                    lineWidth: "number",
                    pointSize: "number",
                    selectionMode: "string",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    trendlines: FableArray(Trendline),
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return ScatterChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.ScatterChartOptions", ScatterChartOptions);
var ColumnChartOptions = function () {
    function ColumnChartOptions(aggregationTarget, animation, annotations, axisTitlesPosition, backgroundColor, bar, chartArea, colors, enableInteractivity, focusTarget, fontSize, fontName, hAxis, height, isStacked, legend, reverseCategories, selectionMode, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, ColumnChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.annotations = annotations;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.bar = bar;
        this.chartArea = chartArea;
        this.colors = colors;
        this.enableInteractivity = enableInteractivity;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxis = hAxis;
        this.height = height;
        this.isStacked = isStacked;
        this.legend = legend;
        this.reverseCategories = reverseCategories;
        this.selectionMode = selectionMode;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(ColumnChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ColumnChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    annotations: ChartAnnotations,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    bar: GroupWidth,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    enableInteractivity: "boolean",
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxis: ChartAxis,
                    height: "number",
                    isStacked: "boolean",
                    legend: ChartLegend,
                    reverseCategories: "boolean",
                    selectionMode: "string",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return ColumnChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.ColumnChartOptions", ColumnChartOptions);
var LineChartOptions = function () {
    function LineChartOptions(aggregationTarget, animation, annotations, axisTitlesPosition, backgroundColor, chartArea, colors, crosshair, curveType, dataOpacity, enableInteractivity, explorer, focusTarget, fontSize, fontName, hAxis, height, interpolateNulls, legend, lineWidth, orientation, pointSize, reverseCategories, selectionMode, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, LineChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.annotations = annotations;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.chartArea = chartArea;
        this.colors = colors;
        this.crosshair = crosshair;
        this.curveType = curveType;
        this.dataOpacity = dataOpacity;
        this.enableInteractivity = enableInteractivity;
        this.explorer = explorer;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxis = hAxis;
        this.height = height;
        this.interpolateNulls = interpolateNulls;
        this.legend = legend;
        this.lineWidth = lineWidth;
        this.orientation = orientation;
        this.pointSize = pointSize;
        this.reverseCategories = reverseCategories;
        this.selectionMode = selectionMode;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(LineChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.LineChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    annotations: ChartAnnotations,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    crosshair: ChartCrosshair,
                    curveType: "string",
                    dataOpacity: "number",
                    enableInteractivity: "boolean",
                    explorer: ChartExplorer,
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxis: ChartAxis,
                    height: "number",
                    interpolateNulls: "boolean",
                    legend: ChartLegend,
                    lineWidth: "number",
                    orientation: "string",
                    pointSize: "number",
                    reverseCategories: "boolean",
                    selectionMode: "string",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return LineChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.LineChartOptions", LineChartOptions);
var BarChartOptions = function () {
    function BarChartOptions(aggregationTarget, animation, annotations, axisTitlesPosition, backgroundColor, bar, chartArea, colors, dataOpacity, enableInteractivity, focusTarget, fontSize, fontName, hAxes, hAxis, height, isStacked, legend, reverseCategories, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, BarChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.annotations = annotations;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.bar = bar;
        this.chartArea = chartArea;
        this.colors = colors;
        this.dataOpacity = dataOpacity;
        this.enableInteractivity = enableInteractivity;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxes = hAxes;
        this.hAxis = hAxis;
        this.height = height;
        this.isStacked = isStacked;
        this.legend = legend;
        this.reverseCategories = reverseCategories;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(BarChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.BarChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    annotations: ChartAnnotations,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    bar: GroupWidth,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    dataOpacity: "number",
                    enableInteractivity: "boolean",
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxes: Any,
                    hAxis: ChartAxis,
                    height: "number",
                    isStacked: "boolean",
                    legend: ChartLegend,
                    reverseCategories: "boolean",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return BarChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.BarChartOptions", BarChartOptions);
var HistogramHistogram = function () {
    function HistogramHistogram(bucketSize, hideBucketItems, lastBucketPercentile) {
        _classCallCheck(this, HistogramHistogram);

        this.bucketSize = bucketSize;
        this.hideBucketItems = hideBucketItems;
        this.lastBucketPercentile = lastBucketPercentile;
    }

    _createClass(HistogramHistogram, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.HistogramHistogram",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    bucketSize: "number",
                    hideBucketItems: "boolean",
                    lastBucketPercentile: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return HistogramHistogram;
}();
setType("TheGamma.GoogleCharts.Options.HistogramHistogram", HistogramHistogram);
var HistogramOptions = function () {
    function HistogramOptions(animation, axisTitlesPosition, backgroundColor, bar, chartArea, colors, dataOpacity, enableInteractivity, focusTarget, fontSize, fontName, hAxis, histogram, height, interpolateNulls, isStacked, legend, orientation, reverseCategories, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, HistogramOptions);

        this.animation = animation;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.bar = bar;
        this.chartArea = chartArea;
        this.colors = colors;
        this.dataOpacity = dataOpacity;
        this.enableInteractivity = enableInteractivity;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxis = hAxis;
        this.histogram = histogram;
        this.height = height;
        this.interpolateNulls = interpolateNulls;
        this.isStacked = isStacked;
        this.legend = legend;
        this.orientation = orientation;
        this.reverseCategories = reverseCategories;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(HistogramOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.HistogramOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    animation: TransitionAnimation,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    bar: GroupWidth,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    dataOpacity: "number",
                    enableInteractivity: "boolean",
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxis: ChartAxis,
                    histogram: HistogramHistogram,
                    height: "number",
                    interpolateNulls: "boolean",
                    isStacked: "boolean",
                    legend: ChartLegend,
                    orientation: "string",
                    reverseCategories: "boolean",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return HistogramOptions;
}();
setType("TheGamma.GoogleCharts.Options.HistogramOptions", HistogramOptions);
var AreaChartOptions = function () {
    function AreaChartOptions(aggregationTarget, animation, areaOpacity, axisTitlesPosition, backgroundColor, chartArea, colors, crosshair, dataOpacity, enableInteractivity, explorer, focusTarget, fontSize, fontName, hAxis, height, interpolateNulls, isStacked, legend, lineWidth, orientation, pointSize, reverseCategories, selectionMode, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, AreaChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.areaOpacity = areaOpacity;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.chartArea = chartArea;
        this.colors = colors;
        this.crosshair = crosshair;
        this.dataOpacity = dataOpacity;
        this.enableInteractivity = enableInteractivity;
        this.explorer = explorer;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxis = hAxis;
        this.height = height;
        this.interpolateNulls = interpolateNulls;
        this.isStacked = isStacked;
        this.legend = legend;
        this.lineWidth = lineWidth;
        this.orientation = orientation;
        this.pointSize = pointSize;
        this.reverseCategories = reverseCategories;
        this.selectionMode = selectionMode;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(AreaChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.AreaChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    areaOpacity: "number",
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    crosshair: ChartCrosshair,
                    dataOpacity: "number",
                    enableInteractivity: "boolean",
                    explorer: ChartExplorer,
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxis: ChartAxis,
                    height: "number",
                    interpolateNulls: "boolean",
                    isStacked: "boolean",
                    legend: ChartLegend,
                    lineWidth: "number",
                    orientation: "string",
                    pointSize: "number",
                    reverseCategories: "boolean",
                    selectionMode: "string",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return AreaChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.AreaChartOptions", AreaChartOptions);
var AnnotationChartOptions = function () {
    function AnnotationChartOptions(allowHtml, allValuesSuffix, annotationsWidth, colors, dateFormat, displayAnnotations, displayAnnotationsFilter, displayDateTimeBarSeparator, displayExactValues, displayLegendDots, displayLegendValues, displayRangeSelector, displayZoomButtons, fill, legendPosition, max, min, numberFormats, scaleColumns, scaleFormat, scaleType, thickness, zoomEndTime, zoomStartTime) {
        _classCallCheck(this, AnnotationChartOptions);

        this.allowHtml = allowHtml;
        this.allValuesSuffix = allValuesSuffix;
        this.annotationsWidth = annotationsWidth;
        this.colors = colors;
        this.dateFormat = dateFormat;
        this.displayAnnotations = displayAnnotations;
        this.displayAnnotationsFilter = displayAnnotationsFilter;
        this.displayDateTimeBarSeparator = displayDateTimeBarSeparator;
        this.displayExactValues = displayExactValues;
        this.displayLegendDots = displayLegendDots;
        this.displayLegendValues = displayLegendValues;
        this.displayRangeSelector = displayRangeSelector;
        this.displayZoomButtons = displayZoomButtons;
        this.fill = fill;
        this.legendPosition = legendPosition;
        this.max = max;
        this.min = min;
        this.numberFormats = numberFormats;
        this.scaleColumns = scaleColumns;
        this.scaleFormat = scaleFormat;
        this.scaleType = scaleType;
        this.thickness = thickness;
        this.zoomEndTime = zoomEndTime;
        this.zoomStartTime = zoomStartTime;
    }

    _createClass(AnnotationChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.AnnotationChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    allowHtml: "boolean",
                    allValuesSuffix: "string",
                    annotationsWidth: "number",
                    colors: FableArray("string"),
                    dateFormat: "string",
                    displayAnnotations: "boolean",
                    displayAnnotationsFilter: "boolean",
                    displayDateTimeBarSeparator: "boolean",
                    displayExactValues: "boolean",
                    displayLegendDots: "boolean",
                    displayLegendValues: "boolean",
                    displayRangeSelector: "boolean",
                    displayZoomButtons: "boolean",
                    fill: "number",
                    legendPosition: "string",
                    max: "number",
                    min: "number",
                    numberFormats: Any,
                    scaleColumns: FableArray(Float64Array, true),
                    scaleFormat: "string",
                    scaleType: "string",
                    thickness: "number",
                    zoomEndTime: Date,
                    zoomStartTime: Date
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return AnnotationChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.AnnotationChartOptions", AnnotationChartOptions);
var SteppedAreaChartOptions = function () {
    function SteppedAreaChartOptions(aggregationTarget, animation, areaOpacity, axisTitlesPosition, backgroundColor, chartArea, colors, connectSteps, enableInteractivity, focusTarget, fontSize, fontName, hAxis, height, interpolateNulls, isStacked, legend, reverseCategories, selectionMode, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, SteppedAreaChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.areaOpacity = areaOpacity;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.chartArea = chartArea;
        this.colors = colors;
        this.connectSteps = connectSteps;
        this.enableInteractivity = enableInteractivity;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxis = hAxis;
        this.height = height;
        this.interpolateNulls = interpolateNulls;
        this.isStacked = isStacked;
        this.legend = legend;
        this.reverseCategories = reverseCategories;
        this.selectionMode = selectionMode;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(SteppedAreaChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.SteppedAreaChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    areaOpacity: "number",
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    connectSteps: "boolean",
                    enableInteractivity: "boolean",
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxis: ChartAxis,
                    height: "number",
                    interpolateNulls: "boolean",
                    isStacked: "boolean",
                    legend: ChartLegend,
                    reverseCategories: "boolean",
                    selectionMode: "string",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return SteppedAreaChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.SteppedAreaChartOptions", SteppedAreaChartOptions);
var PieChartOptions = function () {
    function PieChartOptions(backgroundColor, chartArea, colors, enableInteractivity, fontSize, fontName, height, is3D, legend, pieHole, pieSliceBorderColor, pieSliceText, pieSliceTextStyle, pieStartAngle, reverseCategories, pieResidueSliceColor, pieResidueSliceLabel, slices, sliceVisibilityThreshold, title, titleTextStyle, tooltip, width) {
        _classCallCheck(this, PieChartOptions);

        this.backgroundColor = backgroundColor;
        this.chartArea = chartArea;
        this.colors = colors;
        this.enableInteractivity = enableInteractivity;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.height = height;
        this.is3D = is3D;
        this.legend = legend;
        this.pieHole = pieHole;
        this.pieSliceBorderColor = pieSliceBorderColor;
        this.pieSliceText = pieSliceText;
        this.pieSliceTextStyle = pieSliceTextStyle;
        this.pieStartAngle = pieStartAngle;
        this.reverseCategories = reverseCategories;
        this.pieResidueSliceColor = pieResidueSliceColor;
        this.pieResidueSliceLabel = pieResidueSliceLabel;
        this.slices = slices;
        this.sliceVisibilityThreshold = sliceVisibilityThreshold;
        this.title = title;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.width = width;
    }

    _createClass(PieChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.PieChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    backgroundColor: Any,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    enableInteractivity: "boolean",
                    fontSize: "number",
                    fontName: "string",
                    height: "number",
                    is3D: "boolean",
                    legend: ChartLegend,
                    pieHole: "number",
                    pieSliceBorderColor: "string",
                    pieSliceText: "string",
                    pieSliceTextStyle: ChartTextStyle,
                    pieStartAngle: "number",
                    reverseCategories: "boolean",
                    pieResidueSliceColor: "string",
                    pieResidueSliceLabel: "string",
                    slices: Any,
                    sliceVisibilityThreshold: "number",
                    title: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return PieChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.PieChartOptions", PieChartOptions);
var ChartBubble = function () {
    function ChartBubble(opacity, stroke, textStyle) {
        _classCallCheck(this, ChartBubble);

        this.opacity = opacity;
        this.stroke = stroke;
        this.textStyle = textStyle;
    }

    _createClass(ChartBubble, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.ChartBubble",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    opacity: "number",
                    stroke: "string",
                    textStyle: ChartTextStyle
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return ChartBubble;
}();
setType("TheGamma.GoogleCharts.Options.ChartBubble", ChartBubble);
var BubbleChartOptions = function () {
    function BubbleChartOptions(animation, axisTitlesPosition, backgroundColor, bubble, chartArea, colors, colorAxis, enableInteractivity, explorer, fontSize, fontName, forceIFrame, hAxis, height, legend, selectionMode, series, sizeAxis, sortBubblesBySize, theme, title, titlePosition, titleTextStyle, tooltip, vAxis, width) {
        _classCallCheck(this, BubbleChartOptions);

        this.animation = animation;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.bubble = bubble;
        this.chartArea = chartArea;
        this.colors = colors;
        this.colorAxis = colorAxis;
        this.enableInteractivity = enableInteractivity;
        this.explorer = explorer;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.forceIFrame = forceIFrame;
        this.hAxis = hAxis;
        this.height = height;
        this.legend = legend;
        this.selectionMode = selectionMode;
        this.series = series;
        this.sizeAxis = sizeAxis;
        this.sortBubblesBySize = sortBubblesBySize;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(BubbleChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.BubbleChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    animation: TransitionAnimation,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    bubble: ChartBubble,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    colorAxis: ChartColorAxis,
                    enableInteractivity: "boolean",
                    explorer: ChartExplorer,
                    fontSize: "number",
                    fontName: "string",
                    forceIFrame: "boolean",
                    hAxis: ChartAxis,
                    height: "number",
                    legend: ChartLegend,
                    selectionMode: "string",
                    series: Any,
                    sizeAxis: ChartSizeAxis,
                    sortBubblesBySize: "boolean",
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return BubbleChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.BubbleChartOptions", BubbleChartOptions);
var TreeMapOptions = function () {
    function TreeMapOptions(fontColor, fontFamily, fontSize, forceIFrame, headerColor, headerHeight, headerHighlightColor, hintOpacity, maxColor, maxDepth, maxHighlightColor, maxPostDepth, maxColorValue, midColor, midHighlightColor, minColor, minHighlightColor, minColorValue, showScale, showTooltips, textStyle, title, titleTextStyle, useWeightedAverageForAggregation) {
        _classCallCheck(this, TreeMapOptions);

        this.fontColor = fontColor;
        this.fontFamily = fontFamily;
        this.fontSize = fontSize;
        this.forceIFrame = forceIFrame;
        this.headerColor = headerColor;
        this.headerHeight = headerHeight;
        this.headerHighlightColor = headerHighlightColor;
        this.hintOpacity = hintOpacity;
        this.maxColor = maxColor;
        this.maxDepth = maxDepth;
        this.maxHighlightColor = maxHighlightColor;
        this.maxPostDepth = maxPostDepth;
        this.maxColorValue = maxColorValue;
        this.midColor = midColor;
        this.midHighlightColor = midHighlightColor;
        this.minColor = minColor;
        this.minHighlightColor = minHighlightColor;
        this.minColorValue = minColorValue;
        this.showScale = showScale;
        this.showTooltips = showTooltips;
        this.textStyle = textStyle;
        this.title = title;
        this.titleTextStyle = titleTextStyle;
        this.useWeightedAverageForAggregation = useWeightedAverageForAggregation;
    }

    _createClass(TreeMapOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.TreeMapOptions",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    fontColor: "string",
                    fontFamily: "string",
                    fontSize: "number",
                    forceIFrame: "boolean",
                    headerColor: "string",
                    headerHeight: "number",
                    headerHighlightColor: "string",
                    hintOpacity: "number",
                    maxColor: "string",
                    maxDepth: "number",
                    maxHighlightColor: "string",
                    maxPostDepth: "number",
                    maxColorValue: "number",
                    midColor: "string",
                    midHighlightColor: "string",
                    minColor: "string",
                    minHighlightColor: "string",
                    minColorValue: "number",
                    showScale: "boolean",
                    showTooltips: "boolean",
                    textStyle: ChartTextStyle,
                    title: "string",
                    titleTextStyle: ChartTextStyle,
                    useWeightedAverageForAggregation: "boolean"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return TreeMapOptions;
}();
setType("TheGamma.GoogleCharts.Options.TreeMapOptions", TreeMapOptions);
var CssClassNames = function () {
    function CssClassNames(headerRow, tableRow, oddTableRow, selectedTableRow, hoverTableRow, headerCell, tableCell, rowNumberCell) {
        _classCallCheck(this, CssClassNames);

        this.headerRow = headerRow;
        this.tableRow = tableRow;
        this.oddTableRow = oddTableRow;
        this.selectedTableRow = selectedTableRow;
        this.hoverTableRow = hoverTableRow;
        this.headerCell = headerCell;
        this.tableCell = tableCell;
        this.rowNumberCell = rowNumberCell;
    }

    _createClass(CssClassNames, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.CssClassNames",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    headerRow: "string",
                    tableRow: "string",
                    oddTableRow: "string",
                    selectedTableRow: "string",
                    hoverTableRow: "string",
                    headerCell: "string",
                    tableCell: "string",
                    rowNumberCell: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return CssClassNames;
}();
setType("TheGamma.GoogleCharts.Options.CssClassNames", CssClassNames);
var TableOptions = function () {
    function TableOptions(allowHtml, alternatingRowStyle, cssClassName, firstRowNumber, height, page, pageSize, rtlTable, scrollLeftStartPosition, showRowNumber, sort, sortAscending, sortColumn, startPage, width) {
        _classCallCheck(this, TableOptions);

        this.allowHtml = allowHtml;
        this.alternatingRowStyle = alternatingRowStyle;
        this.cssClassName = cssClassName;
        this.firstRowNumber = firstRowNumber;
        this.height = height;
        this.page = page;
        this.pageSize = pageSize;
        this.rtlTable = rtlTable;
        this.scrollLeftStartPosition = scrollLeftStartPosition;
        this.showRowNumber = showRowNumber;
        this.sort = sort;
        this.sortAscending = sortAscending;
        this.sortColumn = sortColumn;
        this.startPage = startPage;
        this.width = width;
    }

    _createClass(TableOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.TableOptions",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    allowHtml: "boolean",
                    alternatingRowStyle: "boolean",
                    cssClassName: CssClassNames,
                    firstRowNumber: "number",
                    height: "string",
                    page: "string",
                    pageSize: "number",
                    rtlTable: "boolean",
                    scrollLeftStartPosition: "number",
                    showRowNumber: "boolean",
                    sort: "string",
                    sortAscending: "boolean",
                    sortColumn: "number",
                    startPage: "number",
                    width: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return TableOptions;
}();
setType("TheGamma.GoogleCharts.Options.TableOptions", TableOptions);
var LabelStyle = function () {
    function LabelStyle(color, fontName, fontSize) {
        _classCallCheck(this, LabelStyle);

        this.color = color;
        this.fontName = fontName;
        this.fontSize = fontSize;
    }

    _createClass(LabelStyle, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.LabelStyle",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    color: "string",
                    fontName: "string",
                    fontSize: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return LabelStyle;
}();
setType("TheGamma.GoogleCharts.Options.LabelStyle", LabelStyle);
var TimelineTimeline = function () {
    function TimelineTimeline(barLabelStyle, colorByRowLabel, groupByRowLabel, rowLabelStyle, showRowLabels, singleColor) {
        _classCallCheck(this, TimelineTimeline);

        this.barLabelStyle = barLabelStyle;
        this.colorByRowLabel = colorByRowLabel;
        this.groupByRowLabel = groupByRowLabel;
        this.rowLabelStyle = rowLabelStyle;
        this.showRowLabels = showRowLabels;
        this.singleColor = singleColor;
    }

    _createClass(TimelineTimeline, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.TimelineTimeline",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    barLabelStyle: LabelStyle,
                    colorByRowLabel: "boolean",
                    groupByRowLabel: "boolean",
                    rowLabelStyle: LabelStyle,
                    showRowLabels: "boolean",
                    singleColor: "string"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return TimelineTimeline;
}();
setType("TheGamma.GoogleCharts.Options.TimelineTimeline", TimelineTimeline);
var TimelineOptions = function () {
    function TimelineOptions(avoidOverlappingGridLines, backgroundColor, colors, enableInteractivity, forceIFrame, height, timeline, width) {
        _classCallCheck(this, TimelineOptions);

        this.avoidOverlappingGridLines = avoidOverlappingGridLines;
        this.backgroundColor = backgroundColor;
        this.colors = colors;
        this.enableInteractivity = enableInteractivity;
        this.forceIFrame = forceIFrame;
        this.height = height;
        this.timeline = timeline;
        this.width = width;
    }

    _createClass(TimelineOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.TimelineOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    avoidOverlappingGridLines: "boolean",
                    backgroundColor: Any,
                    colors: FableArray("string"),
                    enableInteractivity: "boolean",
                    forceIFrame: "boolean",
                    height: "number",
                    timeline: TimelineTimeline,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return TimelineOptions;
}();
setType("TheGamma.GoogleCharts.Options.TimelineOptions", TimelineOptions);
var CandlestickCandlestick = function () {
    function CandlestickCandlestick(hollowIsRising, fallingColor, risingColor) {
        _classCallCheck(this, CandlestickCandlestick);

        this.hollowIsRising = hollowIsRising;
        this.fallingColor = fallingColor;
        this.risingColor = risingColor;
    }

    _createClass(CandlestickCandlestick, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.CandlestickCandlestick",
                interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
                properties: {
                    hollowIsRising: "boolean",
                    fallingColor: ChartStroke,
                    risingColor: ChartStroke
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareRecords(this, other);
        }
    }]);

    return CandlestickCandlestick;
}();
setType("TheGamma.GoogleCharts.Options.CandlestickCandlestick", CandlestickCandlestick);
var CandlestickChartOptions = function () {
    function CandlestickChartOptions(aggregationTarget, animation, axisTitlesPosition, backgroundColor, bar, candlestick, chartArea, colors, enableInteractivity, focusTarget, fontSize, fontName, hAxis, height, legend, orientation, reverseCategories, selectionMode, series, theme, title, titlePosition, titleTextStyle, tooltip, vAxes, vAxis, width) {
        _classCallCheck(this, CandlestickChartOptions);

        this.aggregationTarget = aggregationTarget;
        this.animation = animation;
        this.axisTitlesPosition = axisTitlesPosition;
        this.backgroundColor = backgroundColor;
        this.bar = bar;
        this.candlestick = candlestick;
        this.chartArea = chartArea;
        this.colors = colors;
        this.enableInteractivity = enableInteractivity;
        this.focusTarget = focusTarget;
        this.fontSize = fontSize;
        this.fontName = fontName;
        this.hAxis = hAxis;
        this.height = height;
        this.legend = legend;
        this.orientation = orientation;
        this.reverseCategories = reverseCategories;
        this.selectionMode = selectionMode;
        this.series = series;
        this.theme = theme;
        this.title = title;
        this.titlePosition = titlePosition;
        this.titleTextStyle = titleTextStyle;
        this.tooltip = tooltip;
        this.vAxes = vAxes;
        this.vAxis = vAxis;
        this.width = width;
    }

    _createClass(CandlestickChartOptions, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.GoogleCharts.Options.CandlestickChartOptions",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    aggregationTarget: "string",
                    animation: TransitionAnimation,
                    axisTitlesPosition: "string",
                    backgroundColor: Any,
                    bar: GroupWidth,
                    candlestick: CandlestickCandlestick,
                    chartArea: ChartArea,
                    colors: FableArray("string"),
                    enableInteractivity: "boolean",
                    focusTarget: "string",
                    fontSize: "number",
                    fontName: "string",
                    hAxis: ChartAxis,
                    height: "number",
                    legend: ChartLegend,
                    orientation: "string",
                    reverseCategories: "boolean",
                    selectionMode: "string",
                    series: Any,
                    theme: "string",
                    title: "string",
                    titlePosition: "string",
                    titleTextStyle: ChartTextStyle,
                    tooltip: ChartTooltip,
                    vAxes: Any,
                    vAxis: ChartAxis,
                    width: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return CandlestickChartOptions;
}();
setType("TheGamma.GoogleCharts.Options.CandlestickChartOptions", CandlestickChartOptions);

var Geo = function () {
  function Geo(data, typeName, options) {
    _classCallCheck(this, Geo);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Geo, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Geo",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: GeoChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (backgroundColor, datalessRegionColor, displayMode, enableRegionInteractivity, height, keepAspectRatio, region, markerOpacity, resolution, width) {
      var newOptions = void 0;
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var datalessRegionColor_1 = Helpers.right(this.options, "datalessRegionColor", datalessRegionColor);
      var displayMode_1 = Helpers.right(this.options, "displayMode", displayMode);
      var enableRegionInteractivity_1 = Helpers.right(this.options, "enableRegionInteractivity", enableRegionInteractivity);
      var height_1 = Helpers.right(this.options, "height", height);
      var keepAspectRatio_1 = Helpers.right(this.options, "keepAspectRatio", keepAspectRatio);
      var region_1 = Helpers.right(this.options, "region", region);
      var markerOpacity_1 = Helpers.right(this.options, "markerOpacity", markerOpacity);
      var resolution_1 = Helpers.right(this.options, "resolution", resolution);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new GeoChartOptions(backgroundColor_1, this.options.colorAxis, datalessRegionColor_1, displayMode_1, enableRegionInteractivity_1, height_1, keepAspectRatio_1, this.options.legend, region_1, this.options.magnifyingGlass, markerOpacity_1, resolution_1, this.options.sizeAxis, this.options.tooltip, width_1);
      return new Geo(this.data, this.typeName, newOptions);
    }
  }, {
    key: "colorAxis",
    value: function (minValue, maxValue, values, colors) {
      var o = this.options.colorAxis;
      var newNested = new ChartColorAxis(Helpers.right(o, "minValue", minValue), Helpers.right(o, "maxValue", maxValue), Helpers.right(o, "values", defaultArg(values, null, function (source) {
        return Float64Array.from(source);
      })), Helpers.right(o, "colors", defaultArg(colors, null, function (source_1) {
        return _Array$from(source_1);
      })), Helpers.copy(o, "legend"));
      var options = new GeoChartOptions(this.options.backgroundColor, newNested, this.options.datalessRegionColor, this.options.displayMode, this.options.enableRegionInteractivity, this.options.height, this.options.keepAspectRatio, this.options.legend, this.options.region, this.options.magnifyingGlass, this.options.markerOpacity, this.options.resolution, this.options.sizeAxis, this.options.tooltip, this.options.width);
      return new Geo(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new GeoChartOptions(this.options.backgroundColor, this.options.colorAxis, this.options.datalessRegionColor, this.options.displayMode, this.options.enableRegionInteractivity, this.options.height, this.options.keepAspectRatio, newNested, this.options.region, this.options.magnifyingGlass, this.options.markerOpacity, this.options.resolution, this.options.sizeAxis, this.options.tooltip, this.options.width);
      return new Geo(this.data, this.typeName, options);
    }
  }, {
    key: "magnifyingGlass",
    value: function (enable, zoomFactor) {
      var o = this.options.magnifyingGlass;
      var newNested = new GeoChartMagnifyingGlass(Helpers.right(o, "enable", enable), Helpers.right(o, "zoomFactor", zoomFactor));
      var options = new GeoChartOptions(this.options.backgroundColor, this.options.colorAxis, this.options.datalessRegionColor, this.options.displayMode, this.options.enableRegionInteractivity, this.options.height, this.options.keepAspectRatio, this.options.legend, this.options.region, newNested, this.options.markerOpacity, this.options.resolution, this.options.sizeAxis, this.options.tooltip, this.options.width);
      return new Geo(this.data, this.typeName, options);
    }
  }, {
    key: "sizeAxis",
    value: function (maxSize, maxValue, minSize, minValue) {
      var o = this.options.sizeAxis;
      var newNested = new ChartSizeAxis(Helpers.right(o, "maxSize", maxSize), Helpers.right(o, "maxValue", maxValue), Helpers.right(o, "minSize", minSize), Helpers.right(o, "minValue", minValue));
      var options = new GeoChartOptions(this.options.backgroundColor, this.options.colorAxis, this.options.datalessRegionColor, this.options.displayMode, this.options.enableRegionInteractivity, this.options.height, this.options.keepAspectRatio, this.options.legend, this.options.region, this.options.magnifyingGlass, this.options.markerOpacity, this.options.resolution, newNested, this.options.tooltip, this.options.width);
      return new Geo(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new GeoChartOptions(this.options.backgroundColor, this.options.colorAxis, this.options.datalessRegionColor, this.options.displayMode, this.options.enableRegionInteractivity, this.options.height, this.options.keepAspectRatio, this.options.legend, this.options.region, this.options.magnifyingGlass, this.options.markerOpacity, this.options.resolution, this.options.sizeAxis, newNested, this.options.width);
      return new Geo(this.data, this.typeName, options);
    }
  }]);

  return Geo;
}();
setType("TheGamma.GoogleCharts.Extensions.Geo", Geo);

var Scatter = function () {
  function Scatter(data, typeName, options) {
    _classCallCheck(this, Scatter);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Scatter, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Scatter",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: ScatterChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, axisTitlesPosition, backgroundColor, colors, curveType, dataOpacity, enableInteractivity, fontSize, fontName, forceIFrame, height, lineWidth, pointSize, selectionMode, series, theme, title, titlePosition, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var curveType_1 = Helpers.right(this.options, "curveType", curveType);
      var dataOpacity_1 = Helpers.right(this.options, "dataOpacity", dataOpacity);
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var forceIFrame_1 = Helpers.right(this.options, "forceIFrame", forceIFrame);
      var height_1 = Helpers.right(this.options, "height", height);
      var lineWidth_1 = Helpers.right(this.options, "lineWidth", lineWidth);
      var pointSize_1 = Helpers.right(this.options, "pointSize", pointSize);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new ScatterChartOptions(aggregationTarget_1, this.options.animation, this.options.annotations, axisTitlesPosition_1, backgroundColor_1, this.options.chartArea, colors_1, this.options.crosshair, curveType_1, dataOpacity_1, enableInteractivity_1, this.options.explorer, fontSize_1, fontName_1, forceIFrame_1, this.options.hAxis, height_1, this.options.legend, lineWidth_1, pointSize_1, selectionMode_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, width_1);
      return new Scatter(this.data, this.typeName, newOptions);
    }
  }, {
    key: "trendlines",
    value: function (_trendlines) {
      var options = void 0;
      var trendlines_1 = Helpers.right(this.options, "trendlines", defaultArg(_trendlines, null, function (source) {
        return _Array$from(source);
      }));
      options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, trendlines_1, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new ScatterChartOptions(this.options.aggregationTarget, newNested, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "crosshair",
    value: function (color, opacity, orientation, trigger) {
      var o = this.options.crosshair;
      var newNested = void 0;
      var color_1 = Helpers.right(o, "color", color);
      var opacity_1 = Helpers.right(o, "opacity", opacity);
      var orientation_1 = Helpers.right(o, "orientation", orientation);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartCrosshair(color_1, Helpers.copy(o, "focused"), opacity_1, orientation_1, Helpers.copy(o, "selected"), trigger_1);
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, newNested, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "explorer",
    value: function (actions, axis, keepInBounds, maxZoomIn, maxZoomOut, zoomDelta) {
      var o = this.options.explorer;
      var newNested = new ChartExplorer(Helpers.right(o, "actions", defaultArg(actions, null, function (source) {
        return _Array$from(source);
      })), Helpers.right(o, "axis", axis), Helpers.right(o, "keepInBounds", keepInBounds), Helpers.right(o, "maxZoomIn", maxZoomIn), Helpers.right(o, "maxZoomOut", maxZoomOut), Helpers.right(o, "zoomDelta", zoomDelta));
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, newNested, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, newNested, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, newNested, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.trendlines, this.options.vAxis, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new ScatterChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.lineWidth, this.options.pointSize, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.trendlines, newNested, this.options.width);
      return new Scatter(this.data, this.typeName, options);
    }
  }]);

  return Scatter;
}();

setType("TheGamma.GoogleCharts.Extensions.Scatter", Scatter);
var Column = function () {
  function Column(data, typeName, options) {
    _classCallCheck(this, Column);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Column, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Column",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: ColumnChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, axisTitlesPosition, backgroundColor, colors, enableInteractivity, focusTarget, fontSize, fontName, height, isStacked, reverseCategories, selectionMode, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var isStacked_1 = Helpers.right(this.options, "isStacked", isStacked);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new ColumnChartOptions(aggregationTarget_1, this.options.animation, this.options.annotations, axisTitlesPosition_1, backgroundColor_1, this.options.bar, this.options.chartArea, colors_1, enableInteractivity_1, focusTarget_1, fontSize_1, fontName_1, this.options.hAxis, height_1, isStacked_1, this.options.legend, reverseCategories_1, selectionMode_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new Column(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new ColumnChartOptions(this.options.aggregationTarget, newNested, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "bar",
    value: function (groupWidth) {
      var o = this.options.bar;
      var newNested = new GroupWidth(Helpers.right(o, "groupWidth", groupWidth));
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, newNested, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, newNested, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, newNested, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new ColumnChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new Column(this.data, this.typeName, options);
    }
  }]);

  return Column;
}();
setType("TheGamma.GoogleCharts.Extensions.Column", Column);
var Line = function () {
  function Line(data, typeName, options) {
    _classCallCheck(this, Line);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Line, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Line",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: LineChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, axisTitlesPosition, backgroundColor, colors, curveType, dataOpacity, enableInteractivity, focusTarget, fontSize, fontName, height, interpolateNulls, lineWidth, orientation, pointSize, reverseCategories, selectionMode, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var curveType_1 = Helpers.right(this.options, "curveType", curveType);
      var dataOpacity_1 = Helpers.right(this.options, "dataOpacity", dataOpacity);
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var interpolateNulls_1 = Helpers.right(this.options, "interpolateNulls", interpolateNulls);
      var lineWidth_1 = Helpers.right(this.options, "lineWidth", lineWidth);
      var orientation_1 = Helpers.right(this.options, "orientation", orientation);
      var pointSize_1 = Helpers.right(this.options, "pointSize", pointSize);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new LineChartOptions(aggregationTarget_1, this.options.animation, this.options.annotations, axisTitlesPosition_1, backgroundColor_1, this.options.chartArea, colors_1, this.options.crosshair, curveType_1, dataOpacity_1, enableInteractivity_1, this.options.explorer, focusTarget_1, fontSize_1, fontName_1, this.options.hAxis, height_1, interpolateNulls_1, this.options.legend, lineWidth_1, orientation_1, pointSize_1, reverseCategories_1, selectionMode_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new Line(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new LineChartOptions(this.options.aggregationTarget, newNested, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "crosshair",
    value: function (color, opacity, orientation, trigger) {
      var o = this.options.crosshair;
      var newNested = void 0;
      var color_1 = Helpers.right(o, "color", color);
      var opacity_1 = Helpers.right(o, "opacity", opacity);
      var orientation_1 = Helpers.right(o, "orientation", orientation);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartCrosshair(color_1, Helpers.copy(o, "focused"), opacity_1, orientation_1, Helpers.copy(o, "selected"), trigger_1);
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, newNested, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "explorer",
    value: function (actions, axis, keepInBounds, maxZoomIn, maxZoomOut, zoomDelta) {
      var o = this.options.explorer;
      var newNested = new ChartExplorer(Helpers.right(o, "actions", defaultArg(actions, null, function (source) {
        return _Array$from(source);
      })), Helpers.right(o, "axis", axis), Helpers.right(o, "keepInBounds", keepInBounds), Helpers.right(o, "maxZoomIn", maxZoomIn), Helpers.right(o, "maxZoomOut", maxZoomOut), Helpers.right(o, "zoomDelta", zoomDelta));
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, newNested, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, newNested, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, newNested, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new LineChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.curveType, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new Line(this.data, this.typeName, options);
    }
  }]);

  return Line;
}();
setType("TheGamma.GoogleCharts.Extensions.Line", Line);
var Bar = function () {
  function Bar(data, typeName, options) {
    _classCallCheck(this, Bar);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Bar, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Bar",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: BarChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, axisTitlesPosition, backgroundColor, colors, dataOpacity, enableInteractivity, focusTarget, fontSize, fontName, hAxes, height, isStacked, reverseCategories, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var dataOpacity_1 = Helpers.right(this.options, "dataOpacity", dataOpacity);
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var hAxes_1 = Helpers.right(this.options, "hAxes", hAxes);
      var height_1 = Helpers.right(this.options, "height", height);
      var isStacked_1 = Helpers.right(this.options, "isStacked", isStacked);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new BarChartOptions(aggregationTarget_1, this.options.animation, this.options.annotations, axisTitlesPosition_1, backgroundColor_1, this.options.bar, this.options.chartArea, colors_1, dataOpacity_1, enableInteractivity_1, focusTarget_1, fontSize_1, fontName_1, hAxes_1, this.options.hAxis, height_1, isStacked_1, this.options.legend, reverseCategories_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new Bar(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new BarChartOptions(this.options.aggregationTarget, newNested, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "bar",
    value: function (groupWidth) {
      var o = this.options.bar;
      var newNested = new GroupWidth(Helpers.right(o, "groupWidth", groupWidth));
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, newNested, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, newNested, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, newNested, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new BarChartOptions(this.options.aggregationTarget, this.options.animation, this.options.annotations, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxes, this.options.hAxis, this.options.height, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new Bar(this.data, this.typeName, options);
    }
  }]);

  return Bar;
}();
setType("TheGamma.GoogleCharts.Extensions.Bar", Bar);
var Histogram = function () {
  function Histogram(data, typeName, options) {
    _classCallCheck(this, Histogram);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Histogram, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Histogram",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: HistogramOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (axisTitlesPosition, backgroundColor, colors, dataOpacity, enableInteractivity, focusTarget, fontSize, fontName, height, interpolateNulls, isStacked, orientation, reverseCategories, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var dataOpacity_1 = Helpers.right(this.options, "dataOpacity", dataOpacity);
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var interpolateNulls_1 = Helpers.right(this.options, "interpolateNulls", interpolateNulls);
      var isStacked_1 = Helpers.right(this.options, "isStacked", isStacked);
      var orientation_1 = Helpers.right(this.options, "orientation", orientation);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new HistogramOptions(this.options.animation, axisTitlesPosition_1, backgroundColor_1, this.options.bar, this.options.chartArea, colors_1, dataOpacity_1, enableInteractivity_1, focusTarget_1, fontSize_1, fontName_1, this.options.hAxis, this.options.histogram, height_1, interpolateNulls_1, isStacked_1, this.options.legend, orientation_1, reverseCategories_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new Histogram(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new HistogramOptions(newNested, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "bar",
    value: function (groupWidth) {
      var o = this.options.bar;
      var newNested = new GroupWidth(Helpers.right(o, "groupWidth", groupWidth));
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, newNested, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, newNested, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "histogram",
    value: function (bucketSize, hideBucketItems, lastBucketPercentile) {
      var o = this.options.histogram;
      var newNested = new HistogramHistogram(Helpers.right(o, "bucketSize", bucketSize), Helpers.right(o, "hideBucketItems", hideBucketItems), Helpers.right(o, "lastBucketPercentile", lastBucketPercentile));
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, newNested, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, newNested, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new HistogramOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.chartArea, this.options.colors, this.options.dataOpacity, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.histogram, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new Histogram(this.data, this.typeName, options);
    }
  }]);

  return Histogram;
}();
setType("TheGamma.GoogleCharts.Extensions.Histogram", Histogram);
var Area = function () {
  function Area(data, typeName, options) {
    _classCallCheck(this, Area);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Area, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Area",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: AreaChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, areaOpacity, axisTitlesPosition, backgroundColor, colors, dataOpacity, enableInteractivity, focusTarget, fontSize, fontName, height, interpolateNulls, isStacked, lineWidth, orientation, pointSize, reverseCategories, selectionMode, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var areaOpacity_1 = Helpers.right(this.options, "areaOpacity", areaOpacity);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var dataOpacity_1 = Helpers.right(this.options, "dataOpacity", dataOpacity);
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var interpolateNulls_1 = Helpers.right(this.options, "interpolateNulls", interpolateNulls);
      var isStacked_1 = Helpers.right(this.options, "isStacked", isStacked);
      var lineWidth_1 = Helpers.right(this.options, "lineWidth", lineWidth);
      var orientation_1 = Helpers.right(this.options, "orientation", orientation);
      var pointSize_1 = Helpers.right(this.options, "pointSize", pointSize);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new AreaChartOptions(aggregationTarget_1, this.options.animation, areaOpacity_1, axisTitlesPosition_1, backgroundColor_1, this.options.chartArea, colors_1, this.options.crosshair, dataOpacity_1, enableInteractivity_1, this.options.explorer, focusTarget_1, fontSize_1, fontName_1, this.options.hAxis, height_1, interpolateNulls_1, isStacked_1, this.options.legend, lineWidth_1, orientation_1, pointSize_1, reverseCategories_1, selectionMode_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new Area(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new AreaChartOptions(this.options.aggregationTarget, newNested, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "crosshair",
    value: function (color, opacity, orientation, trigger) {
      var o = this.options.crosshair;
      var newNested = void 0;
      var color_1 = Helpers.right(o, "color", color);
      var opacity_1 = Helpers.right(o, "opacity", opacity);
      var orientation_1 = Helpers.right(o, "orientation", orientation);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartCrosshair(color_1, Helpers.copy(o, "focused"), opacity_1, orientation_1, Helpers.copy(o, "selected"), trigger_1);
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, newNested, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "explorer",
    value: function (actions, axis, keepInBounds, maxZoomIn, maxZoomOut, zoomDelta) {
      var o = this.options.explorer;
      var newNested = new ChartExplorer(Helpers.right(o, "actions", defaultArg(actions, null, function (source) {
        return _Array$from(source);
      })), Helpers.right(o, "axis", axis), Helpers.right(o, "keepInBounds", keepInBounds), Helpers.right(o, "maxZoomIn", maxZoomIn), Helpers.right(o, "maxZoomOut", maxZoomOut), Helpers.right(o, "zoomDelta", zoomDelta));
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, newNested, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, newNested, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, newNested, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new AreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.crosshair, this.options.dataOpacity, this.options.enableInteractivity, this.options.explorer, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.lineWidth, this.options.orientation, this.options.pointSize, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new Area(this.data, this.typeName, options);
    }
  }]);

  return Area;
}();
setType("TheGamma.GoogleCharts.Extensions.Area", Area);
var Annotation = function () {
  function Annotation(data, typeName, options) {
    _classCallCheck(this, Annotation);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Annotation, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Annotation",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: AnnotationChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (allowHtml, allValuesSuffix, annotationsWidth, colors, dateFormat, displayAnnotations, displayAnnotationsFilter, displayDateTimeBarSeparator, displayExactValues, displayLegendDots, displayLegendValues, displayRangeSelector, displayZoomButtons, fill, legendPosition, max, min, numberFormats, scaleColumns, scaleFormat, scaleType, thickness, zoomEndTime, zoomStartTime) {
      var newOptions = new AnnotationChartOptions(Helpers.right(this.options, "allowHtml", allowHtml), Helpers.right(this.options, "allValuesSuffix", allValuesSuffix), Helpers.right(this.options, "annotationsWidth", annotationsWidth), Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      })), Helpers.right(this.options, "dateFormat", dateFormat), Helpers.right(this.options, "displayAnnotations", displayAnnotations), Helpers.right(this.options, "displayAnnotationsFilter", displayAnnotationsFilter), Helpers.right(this.options, "displayDateTimeBarSeparator", displayDateTimeBarSeparator), Helpers.right(this.options, "displayExactValues", displayExactValues), Helpers.right(this.options, "displayLegendDots", displayLegendDots), Helpers.right(this.options, "displayLegendValues", displayLegendValues), Helpers.right(this.options, "displayRangeSelector", displayRangeSelector), Helpers.right(this.options, "displayZoomButtons", displayZoomButtons), Helpers.right(this.options, "fill", fill), Helpers.right(this.options, "legendPosition", legendPosition), Helpers.right(this.options, "max", max), Helpers.right(this.options, "min", min), Helpers.right(this.options, "numberFormats", numberFormats), Helpers.right(this.options, "scaleColumns", defaultArg(scaleColumns, null, function (source_1) {
        return Float64Array.from(source_1);
      })), Helpers.right(this.options, "scaleFormat", scaleFormat), Helpers.right(this.options, "scaleType", scaleType), Helpers.right(this.options, "thickness", thickness), Helpers.right(this.options, "zoomEndTime", zoomEndTime), Helpers.right(this.options, "zoomStartTime", zoomStartTime));
      return new Annotation(this.data, this.typeName, newOptions);
    }
  }]);

  return Annotation;
}();
setType("TheGamma.GoogleCharts.Extensions.Annotation", Annotation);
var SteppedArea = function () {
  function SteppedArea(data, typeName, options) {
    _classCallCheck(this, SteppedArea);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(SteppedArea, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.SteppedArea",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: SteppedAreaChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, areaOpacity, axisTitlesPosition, backgroundColor, colors, connectSteps, enableInteractivity, focusTarget, fontSize, fontName, height, interpolateNulls, isStacked, reverseCategories, selectionMode, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var areaOpacity_1 = Helpers.right(this.options, "areaOpacity", areaOpacity);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var connectSteps_1 = Helpers.right(this.options, "connectSteps", connectSteps);
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var interpolateNulls_1 = Helpers.right(this.options, "interpolateNulls", interpolateNulls);
      var isStacked_1 = Helpers.right(this.options, "isStacked", isStacked);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new SteppedAreaChartOptions(aggregationTarget_1, this.options.animation, areaOpacity_1, axisTitlesPosition_1, backgroundColor_1, this.options.chartArea, colors_1, connectSteps_1, enableInteractivity_1, focusTarget_1, fontSize_1, fontName_1, this.options.hAxis, height_1, interpolateNulls_1, isStacked_1, this.options.legend, reverseCategories_1, selectionMode_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new SteppedArea(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, newNested, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, newNested, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, newNested, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new SteppedAreaChartOptions(this.options.aggregationTarget, this.options.animation, this.options.areaOpacity, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.connectSteps, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.interpolateNulls, this.options.isStacked, this.options.legend, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new SteppedArea(this.data, this.typeName, options);
    }
  }]);

  return SteppedArea;
}();
setType("TheGamma.GoogleCharts.Extensions.SteppedArea", SteppedArea);
var Pie = function () {
  function Pie(data, typeName, options) {
    _classCallCheck(this, Pie);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Pie, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Pie",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: PieChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (backgroundColor, colors, enableInteractivity, fontSize, fontName, height, is3D, pieHole, pieSliceBorderColor, pieSliceText, pieStartAngle, reverseCategories, pieResidueSliceColor, pieResidueSliceLabel, slices, sliceVisibilityThreshold, title, width) {
      var newOptions = void 0;
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var is3D_1 = Helpers.right(this.options, "is3D", is3D);
      var pieHole_1 = Helpers.right(this.options, "pieHole", pieHole);
      var pieSliceBorderColor_1 = Helpers.right(this.options, "pieSliceBorderColor", pieSliceBorderColor);
      var pieSliceText_1 = Helpers.right(this.options, "pieSliceText", pieSliceText);
      var pieStartAngle_1 = Helpers.right(this.options, "pieStartAngle", pieStartAngle);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var pieResidueSliceColor_1 = Helpers.right(this.options, "pieResidueSliceColor", pieResidueSliceColor);
      var pieResidueSliceLabel_1 = Helpers.right(this.options, "pieResidueSliceLabel", pieResidueSliceLabel);
      var slices_1 = Helpers.right(this.options, "slices", slices);
      var sliceVisibilityThreshold_1 = Helpers.right(this.options, "sliceVisibilityThreshold", sliceVisibilityThreshold);
      var title_1 = Helpers.right(this.options, "title", title);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new PieChartOptions(backgroundColor_1, this.options.chartArea, colors_1, enableInteractivity_1, fontSize_1, fontName_1, height_1, is3D_1, this.options.legend, pieHole_1, pieSliceBorderColor_1, pieSliceText_1, this.options.pieSliceTextStyle, pieStartAngle_1, reverseCategories_1, pieResidueSliceColor_1, pieResidueSliceLabel_1, slices_1, sliceVisibilityThreshold_1, title_1, this.options.titleTextStyle, this.options.tooltip, width_1);
      return new Pie(this.data, this.typeName, newOptions);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new PieChartOptions(this.options.backgroundColor, newNested, this.options.colors, this.options.enableInteractivity, this.options.fontSize, this.options.fontName, this.options.height, this.options.is3D, this.options.legend, this.options.pieHole, this.options.pieSliceBorderColor, this.options.pieSliceText, this.options.pieSliceTextStyle, this.options.pieStartAngle, this.options.reverseCategories, this.options.pieResidueSliceColor, this.options.pieResidueSliceLabel, this.options.slices, this.options.sliceVisibilityThreshold, this.options.title, this.options.titleTextStyle, this.options.tooltip, this.options.width);
      return new Pie(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new PieChartOptions(this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.fontSize, this.options.fontName, this.options.height, this.options.is3D, newNested, this.options.pieHole, this.options.pieSliceBorderColor, this.options.pieSliceText, this.options.pieSliceTextStyle, this.options.pieStartAngle, this.options.reverseCategories, this.options.pieResidueSliceColor, this.options.pieResidueSliceLabel, this.options.slices, this.options.sliceVisibilityThreshold, this.options.title, this.options.titleTextStyle, this.options.tooltip, this.options.width);
      return new Pie(this.data, this.typeName, options);
    }
  }, {
    key: "pieSliceTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.pieSliceTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new PieChartOptions(this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.fontSize, this.options.fontName, this.options.height, this.options.is3D, this.options.legend, this.options.pieHole, this.options.pieSliceBorderColor, this.options.pieSliceText, newNested, this.options.pieStartAngle, this.options.reverseCategories, this.options.pieResidueSliceColor, this.options.pieResidueSliceLabel, this.options.slices, this.options.sliceVisibilityThreshold, this.options.title, this.options.titleTextStyle, this.options.tooltip, this.options.width);
      return new Pie(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new PieChartOptions(this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.fontSize, this.options.fontName, this.options.height, this.options.is3D, this.options.legend, this.options.pieHole, this.options.pieSliceBorderColor, this.options.pieSliceText, this.options.pieSliceTextStyle, this.options.pieStartAngle, this.options.reverseCategories, this.options.pieResidueSliceColor, this.options.pieResidueSliceLabel, this.options.slices, this.options.sliceVisibilityThreshold, this.options.title, newNested, this.options.tooltip, this.options.width);
      return new Pie(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new PieChartOptions(this.options.backgroundColor, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.fontSize, this.options.fontName, this.options.height, this.options.is3D, this.options.legend, this.options.pieHole, this.options.pieSliceBorderColor, this.options.pieSliceText, this.options.pieSliceTextStyle, this.options.pieStartAngle, this.options.reverseCategories, this.options.pieResidueSliceColor, this.options.pieResidueSliceLabel, this.options.slices, this.options.sliceVisibilityThreshold, this.options.title, this.options.titleTextStyle, newNested, this.options.width);
      return new Pie(this.data, this.typeName, options);
    }
  }]);

  return Pie;
}();
setType("TheGamma.GoogleCharts.Extensions.Pie", Pie);
var Bubble = function () {
  function Bubble(data, typeName, options) {
    _classCallCheck(this, Bubble);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Bubble, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Bubble",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: BubbleChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (axisTitlesPosition, backgroundColor, colors, enableInteractivity, fontSize, fontName, forceIFrame, height, selectionMode, series, sortBubblesBySize, theme, title, titlePosition, width) {
      var newOptions = void 0;
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var forceIFrame_1 = Helpers.right(this.options, "forceIFrame", forceIFrame);
      var height_1 = Helpers.right(this.options, "height", height);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var sortBubblesBySize_1 = Helpers.right(this.options, "sortBubblesBySize", sortBubblesBySize);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new BubbleChartOptions(this.options.animation, axisTitlesPosition_1, backgroundColor_1, this.options.bubble, this.options.chartArea, colors_1, this.options.colorAxis, enableInteractivity_1, this.options.explorer, fontSize_1, fontName_1, forceIFrame_1, this.options.hAxis, height_1, this.options.legend, selectionMode_1, series_1, this.options.sizeAxis, sortBubblesBySize_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, width_1);
      return new Bubble(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new BubbleChartOptions(newNested, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "bubble",
    value: function (opacity, stroke) {
      var o = this.options.bubble;
      var newNested = new ChartBubble(Helpers.right(o, "opacity", opacity), Helpers.right(o, "stroke", stroke), Helpers.copy(o, "textStyle"));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, newNested, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "colorAxis",
    value: function (minValue, maxValue, values, colors) {
      var o = this.options.colorAxis;
      var newNested = new ChartColorAxis(Helpers.right(o, "minValue", minValue), Helpers.right(o, "maxValue", maxValue), Helpers.right(o, "values", defaultArg(values, null, function (source) {
        return Float64Array.from(source);
      })), Helpers.right(o, "colors", defaultArg(colors, null, function (source_1) {
        return _Array$from(source_1);
      })), Helpers.copy(o, "legend"));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, newNested, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "explorer",
    value: function (actions, axis, keepInBounds, maxZoomIn, maxZoomOut, zoomDelta) {
      var o = this.options.explorer;
      var newNested = new ChartExplorer(Helpers.right(o, "actions", defaultArg(actions, null, function (source) {
        return _Array$from(source);
      })), Helpers.right(o, "axis", axis), Helpers.right(o, "keepInBounds", keepInBounds), Helpers.right(o, "maxZoomIn", maxZoomIn), Helpers.right(o, "maxZoomOut", maxZoomOut), Helpers.right(o, "zoomDelta", zoomDelta));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, newNested, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, newNested, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, newNested, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "sizeAxis",
    value: function (maxSize, maxValue, minSize, minValue) {
      var o = this.options.sizeAxis;
      var newNested = new ChartSizeAxis(Helpers.right(o, "maxSize", maxSize), Helpers.right(o, "maxValue", maxValue), Helpers.right(o, "minSize", minSize), Helpers.right(o, "minValue", minValue));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, newNested, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxis, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new BubbleChartOptions(this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bubble, this.options.chartArea, this.options.colors, this.options.colorAxis, this.options.enableInteractivity, this.options.explorer, this.options.fontSize, this.options.fontName, this.options.forceIFrame, this.options.hAxis, this.options.height, this.options.legend, this.options.selectionMode, this.options.series, this.options.sizeAxis, this.options.sortBubblesBySize, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, newNested, this.options.width);
      return new Bubble(this.data, this.typeName, options);
    }
  }]);

  return Bubble;
}();
setType("TheGamma.GoogleCharts.Extensions.Bubble", Bubble);
var TreeMap = function () {
  function TreeMap(data, typeName, options) {
    _classCallCheck(this, TreeMap);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(TreeMap, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.TreeMap",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: TreeMapOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (fontColor, fontFamily, fontSize, forceIFrame, headerColor, headerHeight, headerHighlightColor, hintOpacity, maxColor, maxDepth, maxHighlightColor, maxPostDepth, maxColorValue, midColor, midHighlightColor, minColor, minHighlightColor, minColorValue, showScale, showTooltips, title, useWeightedAverageForAggregation) {
      var newOptions = void 0;
      var fontColor_1 = Helpers.right(this.options, "fontColor", fontColor);
      var fontFamily_1 = Helpers.right(this.options, "fontFamily", fontFamily);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var forceIFrame_1 = Helpers.right(this.options, "forceIFrame", forceIFrame);
      var headerColor_1 = Helpers.right(this.options, "headerColor", headerColor);
      var headerHeight_1 = Helpers.right(this.options, "headerHeight", headerHeight);
      var headerHighlightColor_1 = Helpers.right(this.options, "headerHighlightColor", headerHighlightColor);
      var hintOpacity_1 = Helpers.right(this.options, "hintOpacity", hintOpacity);
      var maxColor_1 = Helpers.right(this.options, "maxColor", maxColor);
      var maxDepth_1 = Helpers.right(this.options, "maxDepth", maxDepth);
      var maxHighlightColor_1 = Helpers.right(this.options, "maxHighlightColor", maxHighlightColor);
      var maxPostDepth_1 = Helpers.right(this.options, "maxPostDepth", maxPostDepth);
      var maxColorValue_1 = Helpers.right(this.options, "maxColorValue", maxColorValue);
      var midColor_1 = Helpers.right(this.options, "midColor", midColor);
      var midHighlightColor_1 = Helpers.right(this.options, "midHighlightColor", midHighlightColor);
      var minColor_1 = Helpers.right(this.options, "minColor", minColor);
      var minHighlightColor_1 = Helpers.right(this.options, "minHighlightColor", minHighlightColor);
      var minColorValue_1 = Helpers.right(this.options, "minColorValue", minColorValue);
      var showScale_1 = Helpers.right(this.options, "showScale", showScale);
      var showTooltips_1 = Helpers.right(this.options, "showTooltips", showTooltips);
      var title_1 = Helpers.right(this.options, "title", title);
      var useWeightedAverageForAggregation_1 = Helpers.right(this.options, "useWeightedAverageForAggregation", useWeightedAverageForAggregation);
      newOptions = new TreeMapOptions(fontColor_1, fontFamily_1, fontSize_1, forceIFrame_1, headerColor_1, headerHeight_1, headerHighlightColor_1, hintOpacity_1, maxColor_1, maxDepth_1, maxHighlightColor_1, maxPostDepth_1, maxColorValue_1, midColor_1, midHighlightColor_1, minColor_1, minHighlightColor_1, minColorValue_1, showScale_1, showTooltips_1, this.options.textStyle, title_1, this.options.titleTextStyle, useWeightedAverageForAggregation_1);
      return new TreeMap(this.data, this.typeName, newOptions);
    }
  }, {
    key: "textStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.textStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new TreeMapOptions(this.options.fontColor, this.options.fontFamily, this.options.fontSize, this.options.forceIFrame, this.options.headerColor, this.options.headerHeight, this.options.headerHighlightColor, this.options.hintOpacity, this.options.maxColor, this.options.maxDepth, this.options.maxHighlightColor, this.options.maxPostDepth, this.options.maxColorValue, this.options.midColor, this.options.midHighlightColor, this.options.minColor, this.options.minHighlightColor, this.options.minColorValue, this.options.showScale, this.options.showTooltips, newNested, this.options.title, this.options.titleTextStyle, this.options.useWeightedAverageForAggregation);
      return new TreeMap(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new TreeMapOptions(this.options.fontColor, this.options.fontFamily, this.options.fontSize, this.options.forceIFrame, this.options.headerColor, this.options.headerHeight, this.options.headerHighlightColor, this.options.hintOpacity, this.options.maxColor, this.options.maxDepth, this.options.maxHighlightColor, this.options.maxPostDepth, this.options.maxColorValue, this.options.midColor, this.options.midHighlightColor, this.options.minColor, this.options.minHighlightColor, this.options.minColorValue, this.options.showScale, this.options.showTooltips, this.options.textStyle, this.options.title, newNested, this.options.useWeightedAverageForAggregation);
      return new TreeMap(this.data, this.typeName, options);
    }
  }]);

  return TreeMap;
}();
setType("TheGamma.GoogleCharts.Extensions.TreeMap", TreeMap);
var Table = function () {
  function Table(data, typeName, options) {
    _classCallCheck(this, Table);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Table, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Table",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: TableOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (allowHtml, alternatingRowStyle, firstRowNumber, height, page, pageSize, rtlTable, scrollLeftStartPosition, showRowNumber, sort, sortAscending, sortColumn, startPage, width) {
      var newOptions = void 0;
      var allowHtml_1 = Helpers.right(this.options, "allowHtml", allowHtml);
      var alternatingRowStyle_1 = Helpers.right(this.options, "alternatingRowStyle", alternatingRowStyle);
      var firstRowNumber_1 = Helpers.right(this.options, "firstRowNumber", firstRowNumber);
      var height_1 = Helpers.right(this.options, "height", height);
      var page_1 = Helpers.right(this.options, "page", page);
      var pageSize_1 = Helpers.right(this.options, "pageSize", pageSize);
      var rtlTable_1 = Helpers.right(this.options, "rtlTable", rtlTable);
      var scrollLeftStartPosition_1 = Helpers.right(this.options, "scrollLeftStartPosition", scrollLeftStartPosition);
      var showRowNumber_1 = Helpers.right(this.options, "showRowNumber", showRowNumber);
      var sort_1 = Helpers.right(this.options, "sort", sort);
      var sortAscending_1 = Helpers.right(this.options, "sortAscending", sortAscending);
      var sortColumn_1 = Helpers.right(this.options, "sortColumn", sortColumn);
      var startPage_1 = Helpers.right(this.options, "startPage", startPage);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new TableOptions(allowHtml_1, alternatingRowStyle_1, this.options.cssClassName, firstRowNumber_1, height_1, page_1, pageSize_1, rtlTable_1, scrollLeftStartPosition_1, showRowNumber_1, sort_1, sortAscending_1, sortColumn_1, startPage_1, width_1);
      return new Table(this.data, this.typeName, newOptions);
    }
  }, {
    key: "cssClassName",
    value: function (headerRow, tableRow, oddTableRow, selectedTableRow, hoverTableRow, headerCell, tableCell, rowNumberCell) {
      var o = this.options.cssClassName;
      var newNested = new CssClassNames(Helpers.right(o, "headerRow", headerRow), Helpers.right(o, "tableRow", tableRow), Helpers.right(o, "oddTableRow", oddTableRow), Helpers.right(o, "selectedTableRow", selectedTableRow), Helpers.right(o, "hoverTableRow", hoverTableRow), Helpers.right(o, "headerCell", headerCell), Helpers.right(o, "tableCell", tableCell), Helpers.right(o, "rowNumberCell", rowNumberCell));
      var options = new TableOptions(this.options.allowHtml, this.options.alternatingRowStyle, newNested, this.options.firstRowNumber, this.options.height, this.options.page, this.options.pageSize, this.options.rtlTable, this.options.scrollLeftStartPosition, this.options.showRowNumber, this.options.sort, this.options.sortAscending, this.options.sortColumn, this.options.startPage, this.options.width);
      return new Table(this.data, this.typeName, options);
    }
  }]);

  return Table;
}();
setType("TheGamma.GoogleCharts.Extensions.Table", Table);
var Timeline = function () {
  function Timeline(data, typeName, options) {
    _classCallCheck(this, Timeline);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Timeline, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Timeline",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: TimelineOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (avoidOverlappingGridLines, backgroundColor, colors, enableInteractivity, forceIFrame, height, width) {
      var newOptions = void 0;
      var avoidOverlappingGridLines_1 = Helpers.right(this.options, "avoidOverlappingGridLines", avoidOverlappingGridLines);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var forceIFrame_1 = Helpers.right(this.options, "forceIFrame", forceIFrame);
      var height_1 = Helpers.right(this.options, "height", height);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new TimelineOptions(avoidOverlappingGridLines_1, backgroundColor_1, colors_1, enableInteractivity_1, forceIFrame_1, height_1, this.options.timeline, width_1);
      return new Timeline(this.data, this.typeName, newOptions);
    }
  }, {
    key: "timeline",
    value: function (colorByRowLabel, groupByRowLabel, showRowLabels, singleColor) {
      var o = this.options.timeline;
      var newNested = void 0;
      var colorByRowLabel_1 = Helpers.right(o, "colorByRowLabel", colorByRowLabel);
      var groupByRowLabel_1 = Helpers.right(o, "groupByRowLabel", groupByRowLabel);
      var showRowLabels_1 = Helpers.right(o, "showRowLabels", showRowLabels);
      var singleColor_1 = Helpers.right(o, "singleColor", singleColor);
      newNested = new TimelineTimeline(Helpers.copy(o, "barLabelStyle"), colorByRowLabel_1, groupByRowLabel_1, Helpers.copy(o, "rowLabelStyle"), showRowLabels_1, singleColor_1);
      var options = new TimelineOptions(this.options.avoidOverlappingGridLines, this.options.backgroundColor, this.options.colors, this.options.enableInteractivity, this.options.forceIFrame, this.options.height, newNested, this.options.width);
      return new Timeline(this.data, this.typeName, options);
    }
  }]);

  return Timeline;
}();
setType("TheGamma.GoogleCharts.Extensions.Timeline", Timeline);
var Candlestick = function () {
  function Candlestick(data, typeName, options) {
    _classCallCheck(this, Candlestick);

    this.data = data;
    this.typeName = typeName;
    this.options = options;
  }

  _createClass(Candlestick, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.Candlestick",
        interfaces: ["FSharpRecord", "TheGamma.GoogleCharts.Chart"],
        properties: {
          data: ChartData,
          typeName: "string",
          options: CandlestickChartOptions
        }
      };
    }
  }, {
    key: "show",
    value: function (outputId) {
      Helpers.showChart(this, outputId);
    }
  }, {
    key: "set",
    value: function (aggregationTarget, axisTitlesPosition, backgroundColor, colors, enableInteractivity, focusTarget, fontSize, fontName, height, orientation, reverseCategories, selectionMode, series, theme, title, titlePosition, vAxes, width) {
      var newOptions = void 0;
      var aggregationTarget_1 = Helpers.right(this.options, "aggregationTarget", aggregationTarget);
      var axisTitlesPosition_1 = Helpers.right(this.options, "axisTitlesPosition", axisTitlesPosition);
      var backgroundColor_1 = Helpers.right(this.options, "backgroundColor", backgroundColor);
      var colors_1 = Helpers.right(this.options, "colors", defaultArg(colors, null, function (source) {
        return _Array$from(source);
      }));
      var enableInteractivity_1 = Helpers.right(this.options, "enableInteractivity", enableInteractivity);
      var focusTarget_1 = Helpers.right(this.options, "focusTarget", focusTarget);
      var fontSize_1 = Helpers.right(this.options, "fontSize", fontSize);
      var fontName_1 = Helpers.right(this.options, "fontName", fontName);
      var height_1 = Helpers.right(this.options, "height", height);
      var orientation_1 = Helpers.right(this.options, "orientation", orientation);
      var reverseCategories_1 = Helpers.right(this.options, "reverseCategories", reverseCategories);
      var selectionMode_1 = Helpers.right(this.options, "selectionMode", selectionMode);
      var series_1 = Helpers.right(this.options, "series", series);
      var theme_1 = Helpers.right(this.options, "theme", theme);
      var title_1 = Helpers.right(this.options, "title", title);
      var titlePosition_1 = Helpers.right(this.options, "titlePosition", titlePosition);
      var vAxes_1 = Helpers.right(this.options, "vAxes", vAxes);
      var width_1 = Helpers.right(this.options, "width", width);
      newOptions = new CandlestickChartOptions(aggregationTarget_1, this.options.animation, axisTitlesPosition_1, backgroundColor_1, this.options.bar, this.options.candlestick, this.options.chartArea, colors_1, enableInteractivity_1, focusTarget_1, fontSize_1, fontName_1, this.options.hAxis, height_1, this.options.legend, orientation_1, reverseCategories_1, selectionMode_1, series_1, theme_1, title_1, titlePosition_1, this.options.titleTextStyle, this.options.tooltip, vAxes_1, this.options.vAxis, width_1);
      return new Candlestick(this.data, this.typeName, newOptions);
    }
  }, {
    key: "animation",
    value: function (duration, easing) {
      var o = this.options.animation;
      var newNested = new TransitionAnimation(Helpers.right(o, "duration", duration), Helpers.right(o, "easing", easing));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, newNested, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "bar",
    value: function (groupWidth) {
      var o = this.options.bar;
      var newNested = new GroupWidth(Helpers.right(o, "groupWidth", groupWidth));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, newNested, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "candlestick",
    value: function (hollowIsRising) {
      var o = this.options.candlestick;
      var newNested = new CandlestickCandlestick(Helpers.right(o, "hollowIsRising", hollowIsRising), Helpers.copy(o, "fallingColor"), Helpers.copy(o, "risingColor"));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, newNested, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      var o = this.options.chartArea;
      var newNested = new ChartArea(Helpers.right(o, "top", top), Helpers.right(o, "left", left), Helpers.right(o, "width", width), Helpers.right(o, "height", height));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, newNested, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "hAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.hAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, newNested, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "legend",
    value: function (alignment, maxLines, position, numberFormat) {
      var o = this.options.legend;
      var newNested = void 0;
      var alignment_1 = Helpers.right(o, "alignment", alignment);
      var maxLines_1 = Helpers.right(o, "maxLines", maxLines);
      var position_1 = Helpers.right(o, "position", position);
      var numberFormat_1 = Helpers.right(o, "numberFormat", numberFormat);
      newNested = new ChartLegend(alignment_1, maxLines_1, position_1, Helpers.copy(o, "textStyle"), numberFormat_1);
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, newNested, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "titleTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      var o = this.options.titleTextStyle;
      var newNested = new ChartTextStyle(Helpers.right(o, "fontName", fontName), Helpers.right(o, "fontSize", fontSize), Helpers.right(o, "bold", bold), Helpers.right(o, "italic", italic), Helpers.right(o, "color", color), Helpers.right(o, "auraColor", auraColor), Helpers.right(o, "opacity", opacity));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, newNested, this.options.tooltip, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "tooltip",
    value: function (isHtml, showColorCode, trigger) {
      var o = this.options.tooltip;
      var newNested = void 0;
      var isHtml_1 = Helpers.right(o, "isHtml", isHtml);
      var showColorCode_1 = Helpers.right(o, "showColorCode", showColorCode);
      var trigger_1 = Helpers.right(o, "trigger", trigger);
      newNested = new ChartTooltip(isHtml_1, showColorCode_1, Helpers.copy(o, "textStyle"), trigger_1);
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, newNested, this.options.vAxes, this.options.vAxis, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }, {
    key: "vAxis",
    value: function (baseline, baselineColor, direction, format, logScale, textPosition, ticks, title, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode) {
      var o = this.options.vAxis;
      var newNested = void 0;
      var baseline_1 = Helpers.right(o, "baseline", baseline);
      var baselineColor_1 = Helpers.right(o, "baselineColor", baselineColor);
      var direction_1 = Helpers.right(o, "direction", direction);
      var format_1 = Helpers.right(o, "format", format);
      var logScale_1 = Helpers.right(o, "logScale", logScale);
      var textPosition_1 = Helpers.right(o, "textPosition", textPosition);
      var ticks_1 = Helpers.right(o, "ticks", defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      }));
      var title_1 = Helpers.right(o, "title", title);
      var allowContainerBoundaryTextCufoff_1 = Helpers.right(o, "allowContainerBoundaryTextCufoff", allowContainerBoundaryTextCufoff);
      var slantedText_1 = Helpers.right(o, "slantedText", slantedText);
      var slantedTextAngle_1 = Helpers.right(o, "slantedTextAngle", slantedTextAngle);
      var maxAlternation_1 = Helpers.right(o, "maxAlternation", maxAlternation);
      var maxTextLines_1 = Helpers.right(o, "maxTextLines", maxTextLines);
      var minTextSpacing_1 = Helpers.right(o, "minTextSpacing", minTextSpacing);
      var showTextEvery_1 = Helpers.right(o, "showTextEvery", showTextEvery);
      var maxValue_1 = Helpers.right(o, "maxValue", maxValue);
      var minValue_1 = Helpers.right(o, "minValue", minValue);
      var viewWindowMode_1 = Helpers.right(o, "viewWindowMode", viewWindowMode);
      newNested = new ChartAxis(baseline_1, baselineColor_1, direction_1, format_1, Helpers.copy(o, "gridlines"), Helpers.copy(o, "minorGridlines"), logScale_1, textPosition_1, Helpers.copy(o, "textStyle"), ticks_1, title_1, Helpers.copy(o, "titleTextStyle"), allowContainerBoundaryTextCufoff_1, slantedText_1, slantedTextAngle_1, maxAlternation_1, maxTextLines_1, minTextSpacing_1, showTextEvery_1, maxValue_1, minValue_1, viewWindowMode_1, Helpers.copy(o, "viewWindow"));
      var options = new CandlestickChartOptions(this.options.aggregationTarget, this.options.animation, this.options.axisTitlesPosition, this.options.backgroundColor, this.options.bar, this.options.candlestick, this.options.chartArea, this.options.colors, this.options.enableInteractivity, this.options.focusTarget, this.options.fontSize, this.options.fontName, this.options.hAxis, this.options.height, this.options.legend, this.options.orientation, this.options.reverseCategories, this.options.selectionMode, this.options.series, this.options.theme, this.options.title, this.options.titlePosition, this.options.titleTextStyle, this.options.tooltip, this.options.vAxes, newNested, this.options.width);
      return new Candlestick(this.data, this.typeName, options);
    }
  }]);

  return Candlestick;
}();
setType("TheGamma.GoogleCharts.Extensions.Candlestick", Candlestick);

function GeoChartOptions_get_empty_Static() {
  return new GeoChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

function ScatterChartOptions_get_empty_Static() {
  return new ScatterChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

function ColumnChartOptions_get_empty_Static() {
  return new ColumnChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

function LineChartOptions_get_empty_Static() {
  return new LineChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

function BarChartOptions_get_empty_Static() {
  return new BarChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

function AreaChartOptions_get_empty_Static() {
  return new AreaChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

function PieChartOptions_get_empty_Static() {
  return new PieChartOptions(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
}

var options$1 = function () {
  function options() {
    _classCallCheck(this, options);
  }

  _createClass(options, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.Extensions.options",
        properties: {}
      };
    }
  }], [{
    key: "chartSizeAxis",
    value: function (maxSize, maxValue, minSize, minValue) {
      return new ChartSizeAxis(Helpers.orDefault(maxSize), Helpers.orDefault(maxValue), Helpers.orDefault(minSize), Helpers.orDefault(minValue));
    }
  }, {
    key: "chartTextStyle",
    value: function (fontName, fontSize, bold, italic, color, auraColor, opacity) {
      return new ChartTextStyle(Helpers.orDefault(fontName), Helpers.orDefault(fontSize), Helpers.orDefault(bold), Helpers.orDefault(italic), Helpers.orDefault(color), Helpers.orDefault(auraColor), Helpers.orDefault(opacity));
    }
  }, {
    key: "chartTooltip",
    value: function (isHtml, showColorCode, textStyle, trigger) {
      return new ChartTooltip(Helpers.orDefault(isHtml), Helpers.orDefault(showColorCode), Helpers.orDefault(textStyle), Helpers.orDefault(trigger));
    }
  }, {
    key: "chartLegend",
    value: function (alignment, maxLines, position, textStyle, numberFormat) {
      return new ChartLegend(Helpers.orDefault(alignment), Helpers.orDefault(maxLines), Helpers.orDefault(position), Helpers.orDefault(textStyle), Helpers.orDefault(numberFormat));
    }
  }, {
    key: "chartColorAxis",
    value: function (minValue, maxValue, values, colors, legend) {
      return new ChartColorAxis(Helpers.orDefault(minValue), Helpers.orDefault(maxValue), Helpers.orDefault(defaultArg(values, null, function (source) {
        return Float64Array.from(source);
      })), Helpers.orDefault(defaultArg(colors, null, function (source_1) {
        return _Array$from(source_1);
      })), Helpers.orDefault(legend));
    }
  }, {
    key: "geoChartMagnifyingGlass",
    value: function (enable, zoomFactor) {
      return new GeoChartMagnifyingGlass(Helpers.orDefault(enable), Helpers.orDefault(zoomFactor));
    }
  }, {
    key: "chartBoxStyleGradient",
    value: function (color1, color2, x1, y1, x2, y2, useObjectBoundingBoxUnits) {
      return new ChartBoxStyleGradient(Helpers.orDefault(color1), Helpers.orDefault(color2), Helpers.orDefault(x1), Helpers.orDefault(y1), Helpers.orDefault(x2), Helpers.orDefault(y2), Helpers.orDefault(useObjectBoundingBoxUnits));
    }
  }, {
    key: "chartBoxStyle",
    value: function (stroke, strokeWidth, rx, ry, gradient) {
      return new ChartBoxStyle(Helpers.orDefault(stroke), Helpers.orDefault(strokeWidth), Helpers.orDefault(rx), Helpers.orDefault(ry), Helpers.orDefault(gradient));
    }
  }, {
    key: "chartAnnotations",
    value: function (boxStyle, textStyle) {
      return new ChartAnnotations(Helpers.orDefault(boxStyle), Helpers.orDefault(textStyle));
    }
  }, {
    key: "chartCrosshairFocused",
    value: function (color, opacity) {
      return new ChartCrosshairFocused(Helpers.orDefault(color), Helpers.orDefault(opacity));
    }
  }, {
    key: "chartCrosshairSelected",
    value: function (color, opacity) {
      return new ChartCrosshairSelected(Helpers.orDefault(color), Helpers.orDefault(opacity));
    }
  }, {
    key: "chartCrosshair",
    value: function (color, focused, opacity, orientation, selected, trigger) {
      return new ChartCrosshair(Helpers.orDefault(color), Helpers.orDefault(focused), Helpers.orDefault(opacity), Helpers.orDefault(orientation), Helpers.orDefault(selected), Helpers.orDefault(trigger));
    }
  }, {
    key: "chartExplorer",
    value: function (actions, axis, keepInBounds, maxZoomIn, maxZoomOut, zoomDelta) {
      return new ChartExplorer(Helpers.orDefault(defaultArg(actions, null, function (source) {
        return _Array$from(source);
      })), Helpers.orDefault(axis), Helpers.orDefault(keepInBounds), Helpers.orDefault(maxZoomIn), Helpers.orDefault(maxZoomOut), Helpers.orDefault(zoomDelta));
    }
  }, {
    key: "chartStroke",
    value: function (stroke, strokeWidth, fill) {
      return new ChartStroke(Helpers.orDefault(stroke), Helpers.orDefault(strokeWidth), Helpers.orDefault(fill));
    }
  }, {
    key: "chartArea",
    value: function (top, left, width, height) {
      return new ChartArea(Helpers.orDefault(top), Helpers.orDefault(left), Helpers.orDefault(width), Helpers.orDefault(height));
    }
  }, {
    key: "transitionAnimation",
    value: function (duration, easing) {
      return new TransitionAnimation(Helpers.orDefault(duration), Helpers.orDefault(easing));
    }
  }, {
    key: "chartGridlines",
    value: function (color, count) {
      return new ChartGridlines(Helpers.orDefault(color), Helpers.orDefault(count));
    }
  }, {
    key: "chartViewWindow",
    value: function (max, min) {
      return new ChartViewWindow(Helpers.orDefault(max), Helpers.orDefault(min));
    }
  }, {
    key: "chartAxis",
    value: function (baseline, baselineColor, direction, format, gridlines, minorGridlines, logScale, textPosition, textStyle, ticks, title, titleTextStyle, allowContainerBoundaryTextCufoff, slantedText, slantedTextAngle, maxAlternation, maxTextLines, minTextSpacing, showTextEvery, maxValue, minValue, viewWindowMode, viewWindow) {
      return new ChartAxis(Helpers.orDefault(baseline), Helpers.orDefault(baselineColor), Helpers.orDefault(direction), Helpers.orDefault(format), Helpers.orDefault(gridlines), Helpers.orDefault(minorGridlines), Helpers.orDefault(logScale), Helpers.orDefault(textPosition), Helpers.orDefault(textStyle), Helpers.orDefault(defaultArg(ticks, null, function (source) {
        return _Array$from(source);
      })), Helpers.orDefault(title), Helpers.orDefault(titleTextStyle), Helpers.orDefault(allowContainerBoundaryTextCufoff), Helpers.orDefault(slantedText), Helpers.orDefault(slantedTextAngle), Helpers.orDefault(maxAlternation), Helpers.orDefault(maxTextLines), Helpers.orDefault(minTextSpacing), Helpers.orDefault(showTextEvery), Helpers.orDefault(maxValue), Helpers.orDefault(minValue), Helpers.orDefault(viewWindowMode), Helpers.orDefault(viewWindow));
    }
  }, {
    key: "chartBoundingBox",
    value: function (left, top, width, height) {
      return new ChartBoundingBox(Helpers.orDefault(left), Helpers.orDefault(top), Helpers.orDefault(width), Helpers.orDefault(height));
    }
  }, {
    key: "groupWidth",
    value: function (_groupWidth) {
      return new GroupWidth(Helpers.orDefault(_groupWidth));
    }
  }, {
    key: "trendline",
    value: function (color, lineWidth, labelInLegend, opacity, pointSize, pointsVisible, showR2, type, visibleInLegend) {
      return new Trendline(Helpers.orDefault(color), Helpers.orDefault(lineWidth), Helpers.orDefault(labelInLegend), Helpers.orDefault(opacity), Helpers.orDefault(pointSize), Helpers.orDefault(pointsVisible), Helpers.orDefault(showR2), Helpers.orDefault(type), Helpers.orDefault(visibleInLegend));
    }
  }, {
    key: "histogramHistogram",
    value: function (bucketSize, hideBucketItems, lastBucketPercentile) {
      return new HistogramHistogram(Helpers.orDefault(bucketSize), Helpers.orDefault(hideBucketItems), Helpers.orDefault(lastBucketPercentile));
    }
  }, {
    key: "chartBubble",
    value: function (opacity, stroke, textStyle) {
      return new ChartBubble(Helpers.orDefault(opacity), Helpers.orDefault(stroke), Helpers.orDefault(textStyle));
    }
  }, {
    key: "cssClassNames",
    value: function (headerRow, tableRow, oddTableRow, selectedTableRow, hoverTableRow, headerCell, tableCell, rowNumberCell) {
      return new CssClassNames(Helpers.orDefault(headerRow), Helpers.orDefault(tableRow), Helpers.orDefault(oddTableRow), Helpers.orDefault(selectedTableRow), Helpers.orDefault(hoverTableRow), Helpers.orDefault(headerCell), Helpers.orDefault(tableCell), Helpers.orDefault(rowNumberCell));
    }
  }, {
    key: "labelStyle",
    value: function (color, fontName, fontSize) {
      return new LabelStyle(Helpers.orDefault(color), Helpers.orDefault(fontName), Helpers.orDefault(fontSize));
    }
  }, {
    key: "timelineTimeline",
    value: function (barLabelStyle, colorByRowLabel, groupByRowLabel, rowLabelStyle, showRowLabels, singleColor) {
      return new TimelineTimeline(Helpers.orDefault(barLabelStyle), Helpers.orDefault(colorByRowLabel), Helpers.orDefault(groupByRowLabel), Helpers.orDefault(rowLabelStyle), Helpers.orDefault(showRowLabels), Helpers.orDefault(singleColor));
    }
  }, {
    key: "candlestickCandlestick",
    value: function (hollowIsRising, fallingColor, risingColor) {
      return new CandlestickCandlestick(Helpers.orDefault(hollowIsRising), Helpers.orDefault(fallingColor), Helpers.orDefault(risingColor));
    }
  }]);

  return options;
}();

setType("TheGamma.GoogleCharts.Extensions.options", options$1);

var chart = function () {
  function chart() {
    _classCallCheck(this, chart);
  }

  _createClass(chart, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.GoogleCharts.chart",
        properties: {}
      };
    }
  }], [{
    key: "scatter",
    value: function (xval, yval) {
      return new Scatter(ChartDataOperations.twoValues(xval, yval), "ScatterChart", ScatterChartOptions_get_empty_Static());
    }
  }, {
    key: "geo",
    value: function (data) {
      return new Geo(ChartDataOperations.oneKeyValue("string", data), "GeoChart", GeoChartOptions_get_empty_Static());
    }
  }, {
    key: "pie",
    value: function (data) {
      return new Pie(ChartDataOperations.oneKeyValue("string", data), "PieChart", PieChartOptions_get_empty_Static());
    }
  }, {
    key: "bar",
    value: function (data) {
      return new Bar(ChartDataOperations.oneKeyValue("string", data), "BarChart", BarChartOptions_get_empty_Static());
    }
  }, {
    key: "column",
    value: function (data) {
      return new Column(ChartDataOperations.oneKeyValue("string", data), "ColumnChart", ColumnChartOptions_get_empty_Static());
    }
  }, {
    key: "columns",
    value: function (data, colors) {
      return new Line(ChartDataOperations.oneKeyAppendValues("string", data, colors), "ColumnChart", LineChartOptions_get_empty_Static());
    }
  }, {
    key: "line",
    value: function (data) {
      return new Line(ChartDataOperations.oneKeyValue("number", data), "LineChart", LineChartOptions_get_empty_Static());
    }
  }, {
    key: "lines",
    value: function (data) {
      return new Line(ChartDataOperations.oneKeyNValues("number", data), "LineChart", LineChartOptions_get_empty_Static());
    }
  }, {
    key: "area",
    value: function (data) {
      return new Area(ChartDataOperations.oneKeyValue("number", data), "AreaChart", AreaChartOptions_get_empty_Static());
    }
  }, {
    key: "areas",
    value: function (data, names) {
      var i = {
        contents: 0
      };
      var data_1 = names == null ? data : data.map(function (s) {
        void i.contents++;
        return s.setProperties(null, null, names[i.contents - 1]);
      });
      return new Area(ChartDataOperations.oneKeyNValues("number", data_1), "AreaChart", AreaChartOptions_get_empty_Static());
    }
  }, {
    key: "show",
    value: function (chart_1) {
      return function (outputId) {
        Helpers.showChart(chart_1, outputId);
      };
    }
  }]);

  return chart;
}();
setType("TheGamma.GoogleCharts.chart", chart);

var nativeIsArray = Array.isArray;
var toString$3 = Object.prototype.toString;

var index$4 = nativeIsArray || isArray$4;

function isArray$4(obj) {
    return toString$3.call(obj) === "[object Array]"
}

var version$2 = "2";

var version$1 = version$2;

VirtualPatch.NONE = 0;
VirtualPatch.VTEXT = 1;
VirtualPatch.VNODE = 2;
VirtualPatch.WIDGET = 3;
VirtualPatch.PROPS = 4;
VirtualPatch.ORDER = 5;
VirtualPatch.INSERT = 6;
VirtualPatch.REMOVE = 7;
VirtualPatch.THUNK = 8;

var vpatch = VirtualPatch;

function VirtualPatch(type, vNode, patch) {
    this.type = Number(type);
    this.vNode = vNode;
    this.patch = patch;
}

VirtualPatch.prototype.version = version$1;
VirtualPatch.prototype.type = "VirtualPatch";

var version$4 = version$2;

var isVnode = isVirtualNode;

function isVirtualNode(x) {
    return x && x.type === "VirtualNode" && x.version === version$4
}

var version$5 = version$2;

var isVtext = isVirtualText;

function isVirtualText(x) {
    return x && x.type === "VirtualText" && x.version === version$5
}

var isWidget_1 = isWidget$1;

function isWidget$1(w) {
    return w && w.type === "Widget"
}

var isThunk_1 = isThunk$1;

function isThunk$1(t) {
    return t && t.type === "Thunk"
}

var isVNode$1 = isVnode;
var isVText$1 = isVtext;
var isWidget$2 = isWidget_1;
var isThunk$2 = isThunk_1;

var handleThunk_1 = handleThunk$1;

function handleThunk$1(a, b) {
    var renderedA = a;
    var renderedB = b;

    if (isThunk$2(b)) {
        renderedB = renderThunk(b, a);
    }

    if (isThunk$2(a)) {
        renderedA = renderThunk(a, null);
    }

    return {
        a: renderedA,
        b: renderedB
    }
}

function renderThunk(thunk, previous) {
    var renderedThunk = thunk.vnode;

    if (!renderedThunk) {
        renderedThunk = thunk.vnode = thunk.render(previous);
    }

    if (!(isVNode$1(renderedThunk) ||
            isVText$1(renderedThunk) ||
            isWidget$2(renderedThunk))) {
        throw new Error("thunk did not return a valid node");
    }

    return renderedThunk
}

var index$6 = function isObject(x) {
	return typeof x === "object" && x !== null;
};

var isVhook = isHook$1;

function isHook$1(hook) {
    return hook &&
      (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") ||
       typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"))
}

var isObject$5 = index$6;
var isHook = isVhook;

var diffProps_1 = diffProps$1;

function diffProps$1(a, b) {
    var diff;

    for (var aKey in a) {
        if (!(aKey in b)) {
            diff = diff || {};
            diff[aKey] = undefined;
        }

        var aValue = a[aKey];
        var bValue = b[aKey];

        if (aValue === bValue) {
            continue
        } else if (isObject$5(aValue) && isObject$5(bValue)) {
            if (getPrototype(bValue) !== getPrototype(aValue)) {
                diff = diff || {};
                diff[aKey] = bValue;
            } else if (isHook(bValue)) {
                 diff = diff || {};
                 diff[aKey] = bValue;
            } else {
                var objectDiff = diffProps$1(aValue, bValue);
                if (objectDiff) {
                    diff = diff || {};
                    diff[aKey] = objectDiff;
                }
            }
        } else {
            diff = diff || {};
            diff[aKey] = bValue;
        }
    }

    for (var bKey in b) {
        if (!(bKey in a)) {
            diff = diff || {};
            diff[bKey] = b[bKey];
        }
    }

    return diff
}

function getPrototype(value) {
  if (Object.getPrototypeOf) {
    return Object.getPrototypeOf(value)
  } else if (value.__proto__) {
    return value.__proto__
  } else if (value.constructor) {
    return value.constructor.prototype
  }
}

var isArray$3 = index$4;

var VPatch = vpatch;
var isVNode = isVnode;
var isVText = isVtext;
var isWidget = isWidget_1;
var isThunk = isThunk_1;
var handleThunk = handleThunk_1;

var diffProps = diffProps_1;

var diff_1$2 = diff$2;

function diff$2(a, b) {
    var patch = { a: a };
    walk(a, b, patch, 0);
    return patch
}

function walk(a, b, patch, index) {
    if (a === b) {
        return
    }

    var apply = patch[index];
    var applyClear = false;

    if (isThunk(a) || isThunk(b)) {
        thunks(a, b, patch, index);
    } else if (b == null) {

        // If a is a widget we will add a remove patch for it
        // Otherwise any child widgets/hooks must be destroyed.
        // This prevents adding two remove patches for a widget.
        if (!isWidget(a)) {
            clearState(a, patch, index);
            apply = patch[index];
        }

        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b));
    } else if (isVNode(b)) {
        if (isVNode(a)) {
            if (a.tagName === b.tagName &&
                a.namespace === b.namespace &&
                a.key === b.key) {
                var propsPatch = diffProps(a.properties, b.properties);
                if (propsPatch) {
                    apply = appendPatch(apply,
                        new VPatch(VPatch.PROPS, a, propsPatch));
                }
                apply = diffChildren(a, b, patch, apply, index);
            } else {
                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
                applyClear = true;
            }
        } else {
            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
            applyClear = true;
        }
    } else if (isVText(b)) {
        if (!isVText(a)) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
            applyClear = true;
        } else if (a.text !== b.text) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
        }
    } else if (isWidget(b)) {
        if (!isWidget(a)) {
            applyClear = true;
        }

        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b));
    }

    if (apply) {
        patch[index] = apply;
    }

    if (applyClear) {
        clearState(a, patch, index);
    }
}

function diffChildren(a, b, patch, apply, index) {
    var aChildren = a.children;
    var orderedSet = reorder(aChildren, b.children);
    var bChildren = orderedSet.children;

    var aLen = aChildren.length;
    var bLen = bChildren.length;
    var len = aLen > bLen ? aLen : bLen;

    for (var i = 0; i < len; i++) {
        var leftNode = aChildren[i];
        var rightNode = bChildren[i];
        index += 1;

        if (!leftNode) {
            if (rightNode) {
                // Excess nodes in b need to be added
                apply = appendPatch(apply,
                    new VPatch(VPatch.INSERT, null, rightNode));
            }
        } else {
            walk(leftNode, rightNode, patch, index);
        }

        if (isVNode(leftNode) && leftNode.count) {
            index += leftNode.count;
        }
    }

    if (orderedSet.moves) {
        // Reorder nodes last
        apply = appendPatch(apply, new VPatch(
            VPatch.ORDER,
            a,
            orderedSet.moves
        ));
    }

    return apply
}

function clearState(vNode, patch, index) {
    // TODO: Make this a single walk, not two
    unhook(vNode, patch, index);
    destroyWidgets(vNode, patch, index);
}

// Patch records for all destroyed widgets must be added because we need
// a DOM node reference for the destroy function
function destroyWidgets(vNode, patch, index) {
    if (isWidget(vNode)) {
        if (typeof vNode.destroy === "function") {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(VPatch.REMOVE, vNode, null)
            );
        }
    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
        var children = vNode.children;
        var len = children.length;
        for (var i = 0; i < len; i++) {
            var child = children[i];
            index += 1;

            destroyWidgets(child, patch, index);

            if (isVNode(child) && child.count) {
                index += child.count;
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index);
    }
}

// Create a sub-patch for thunks
function thunks(a, b, patch, index) {
    var nodes = handleThunk(a, b);
    var thunkPatch = diff$2(nodes.a, nodes.b);
    if (hasPatches(thunkPatch)) {
        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch);
    }
}

function hasPatches(patch) {
    for (var index in patch) {
        if (index !== "a") {
            return true
        }
    }

    return false
}

// Execute hooks when two nodes are identical
function unhook(vNode, patch, index) {
    if (isVNode(vNode)) {
        if (vNode.hooks) {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(
                    VPatch.PROPS,
                    vNode,
                    undefinedKeys(vNode.hooks)
                )
            );
        }

        if (vNode.descendantHooks || vNode.hasThunks) {
            var children = vNode.children;
            var len = children.length;
            for (var i = 0; i < len; i++) {
                var child = children[i];
                index += 1;

                unhook(child, patch, index);

                if (isVNode(child) && child.count) {
                    index += child.count;
                }
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index);
    }
}

function undefinedKeys(obj) {
    var result = {};

    for (var key in obj) {
        result[key] = undefined;
    }

    return result
}

// List diff, naive left to right reordering
function reorder(aChildren, bChildren) {
    // O(M) time, O(M) memory
    var bChildIndex = keyIndex(bChildren);
    var bKeys = bChildIndex.keys;
    var bFree = bChildIndex.free;

    if (bFree.length === bChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(N) time, O(N) memory
    var aChildIndex = keyIndex(aChildren);
    var aKeys = aChildIndex.keys;
    var aFree = aChildIndex.free;

    if (aFree.length === aChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(MAX(N, M)) memory
    var newChildren = [];

    var freeIndex = 0;
    var freeCount = bFree.length;
    var deletedItems = 0;

    // Iterate through a and match a node in b
    // O(N) time,
    for (var i = 0 ; i < aChildren.length; i++) {
        var aItem = aChildren[i];
        var itemIndex;

        if (aItem.key) {
            if (bKeys.hasOwnProperty(aItem.key)) {
                // Match up the old keys
                itemIndex = bKeys[aItem.key];
                newChildren.push(bChildren[itemIndex]);

            } else {
                // Remove old keyed items
                itemIndex = i - deletedItems++;
                newChildren.push(null);
            }
        } else {
            // Match the item in a with the next free item in b
            if (freeIndex < freeCount) {
                itemIndex = bFree[freeIndex++];
                newChildren.push(bChildren[itemIndex]);
            } else {
                // There are no free items in b to match with
                // the free items in a, so the extra free nodes
                // are deleted.
                itemIndex = i - deletedItems++;
                newChildren.push(null);
            }
        }
    }

    var lastFreeIndex = freeIndex >= bFree.length ?
        bChildren.length :
        bFree[freeIndex];

    // Iterate through b and append any new keys
    // O(M) time
    for (var j = 0; j < bChildren.length; j++) {
        var newItem = bChildren[j];

        if (newItem.key) {
            if (!aKeys.hasOwnProperty(newItem.key)) {
                // Add any new keyed items
                // We are adding new items to the end and then sorting them
                // in place. In future we should insert new items in place.
                newChildren.push(newItem);
            }
        } else if (j >= lastFreeIndex) {
            // Add any leftover non-keyed items
            newChildren.push(newItem);
        }
    }

    var simulate = newChildren.slice();
    var simulateIndex = 0;
    var removes = [];
    var inserts = [];
    var simulateItem;

    for (var k = 0; k < bChildren.length;) {
        var wantedItem = bChildren[k];
        simulateItem = simulate[simulateIndex];

        // remove items
        while (simulateItem === null && simulate.length) {
            removes.push(remove$3(simulate, simulateIndex, null));
            simulateItem = simulate[simulateIndex];
        }

        if (!simulateItem || simulateItem.key !== wantedItem.key) {
            // if we need a key in this position...
            if (wantedItem.key) {
                if (simulateItem && simulateItem.key) {
                    // if an insert doesn't put this key in place, it needs to move
                    if (bKeys[simulateItem.key] !== k + 1) {
                        removes.push(remove$3(simulate, simulateIndex, simulateItem.key));
                        simulateItem = simulate[simulateIndex];
                        // if the remove didn't put the wanted item in place, we need to insert it
                        if (!simulateItem || simulateItem.key !== wantedItem.key) {
                            inserts.push({key: wantedItem.key, to: k});
                        }
                        // items are matching, so skip ahead
                        else {
                            simulateIndex++;
                        }
                    }
                    else {
                        inserts.push({key: wantedItem.key, to: k});
                    }
                }
                else {
                    inserts.push({key: wantedItem.key, to: k});
                }
                k++;
            }
            // a key in simulate has no matching wanted key, remove it
            else if (simulateItem && simulateItem.key) {
                removes.push(remove$3(simulate, simulateIndex, simulateItem.key));
            }
        }
        else {
            simulateIndex++;
            k++;
        }
    }

    // remove all the remaining nodes from simulate
    while(simulateIndex < simulate.length) {
        simulateItem = simulate[simulateIndex];
        removes.push(remove$3(simulate, simulateIndex, simulateItem && simulateItem.key));
    }

    // If the only moves we have are deletes then we can just
    // let the delete patch remove these items.
    if (removes.length === deletedItems && !inserts.length) {
        return {
            children: newChildren,
            moves: null
        }
    }

    return {
        children: newChildren,
        moves: {
            removes: removes,
            inserts: inserts
        }
    }
}

function remove$3(arr, index, key) {
    arr.splice(index, 1);

    return {
        from: index,
        key: key
    }
}

function keyIndex(children) {
    var keys = {};
    var free = [];
    var length = children.length;

    for (var i = 0; i < length; i++) {
        var child = children[i];

        if (child.key) {
            keys[child.key] = i;
        } else {
            free.push(i);
        }
    }

    return {
        keys: keys,     // A hash of key name to index
        free: free      // An array of unkeyed item indices
    }
}

function appendPatch(apply, patch) {
    if (apply) {
        if (isArray$3(apply)) {
            apply.push(patch);
        } else {
            apply = [apply, patch];
        }

        return apply
    } else {
        return patch
    }
}

var diff$1 = diff_1$2;

var diff_1 = diff$1;

var slice$1 = Array.prototype.slice;

var index$10 = iterativelyWalk;

function iterativelyWalk(nodes, cb) {
    if (!('length' in nodes)) {
        nodes = [nodes];
    }
    
    nodes = slice$1.call(nodes);

    while(nodes.length) {
        var node = nodes.shift(),
            ret = cb(node);

        if (ret) {
            return ret
        }

        if (node.childNodes && node.childNodes.length) {
            nodes = slice$1.call(node.childNodes).concat(nodes);
        }
    }
}

var domComment = Comment$1;

function Comment$1(data, owner) {
    if (!(this instanceof Comment$1)) {
        return new Comment$1(data, owner)
    }

    this.data = data;
    this.nodeValue = data;
    this.length = data.length;
    this.ownerDocument = owner || null;
}

Comment$1.prototype.nodeType = 8;
Comment$1.prototype.nodeName = "#comment";

Comment$1.prototype.toString = function _Comment_toString() {
    return "[object Comment]"
};

var domText = DOMText$1;

function DOMText$1(value, owner) {
    if (!(this instanceof DOMText$1)) {
        return new DOMText$1(value)
    }

    this.data = value || "";
    this.length = this.data.length;
    this.ownerDocument = owner || null;
}

DOMText$1.prototype.type = "DOMTextNode";
DOMText$1.prototype.nodeType = 3;
DOMText$1.prototype.nodeName = "#text";

DOMText$1.prototype.toString = function _Text_toString() {
    return this.data
};

DOMText$1.prototype.replaceData = function replaceData(index, length, value) {
    var current = this.data;
    var left = current.substring(0, index);
    var right = current.substring(index + length, current.length);
    this.data = left + value + right;
    this.length = this.data.length;
};

var dispatchEvent_1 = dispatchEvent$2;

function dispatchEvent$2(ev) {
    var elem = this;
    var type = ev.type;

    if (!ev.target) {
        ev.target = elem;
    }

    if (!elem.listeners) {
        elem.listeners = {};
    }

    var listeners = elem.listeners[type];

    if (listeners) {
        return listeners.forEach(function (listener) {
            ev.currentTarget = elem;
            if (typeof listener === 'function') {
                listener(ev);
            } else {
                listener.handleEvent(ev);
            }
        })
    }

    if (elem.parentNode) {
        elem.parentNode.dispatchEvent(ev);
    }
}

var addEventListener_1 = addEventListener$2;

function addEventListener$2(type, listener) {
    var elem = this;

    if (!elem.listeners) {
        elem.listeners = {};
    }

    if (!elem.listeners[type]) {
        elem.listeners[type] = [];
    }

    if (elem.listeners[type].indexOf(listener) === -1) {
        elem.listeners[type].push(listener);
    }
}

var removeEventListener_1 = removeEventListener$2;

function removeEventListener$2(type, listener) {
    var elem = this;

    if (!elem.listeners) {
        return
    }

    if (!elem.listeners[type]) {
        return
    }

    var list = elem.listeners[type];
    var index = list.indexOf(listener);
    if (index !== -1) {
        list.splice(index, 1);
    }
}

var serialize = serializeNode$1;

var voidElements = ["area","base","br","col","embed","hr","img","input","keygen","link","menuitem","meta","param","source","track","wbr"];

function serializeNode$1(node) {
    switch (node.nodeType) {
        case 3:
            return escapeText(node.data)
        case 8:
            return "<!--" + node.data + "-->"
        default:
            return serializeElement(node)
    }
}

function serializeElement(elem) {
    var strings = [];

    var tagname = elem.tagName;

    if (elem.namespaceURI === "http://www.w3.org/1999/xhtml") {
        tagname = tagname.toLowerCase();
    }

    strings.push("<" + tagname + properties(elem) + datasetify(elem));

    if (voidElements.indexOf(tagname) > -1) {
        strings.push(" />");
    } else {
        strings.push(">");

        if (elem.childNodes.length) {
            strings.push.apply(strings, elem.childNodes.map(serializeNode$1));
        } else if (elem.textContent || elem.innerText) {
            strings.push(escapeText(elem.textContent || elem.innerText));
        } else if (elem.innerHTML) {
            strings.push(elem.innerHTML);
        }

        strings.push("</" + tagname + ">");
    }

    return strings.join("")
}

function isProperty(elem, key) {
    var type = typeof elem[key];

    if (key === "style" && Object.keys(elem.style).length > 0) {
      return true
    }

    return elem.hasOwnProperty(key) &&
        (type === "string" || type === "boolean" || type === "number") &&
        key !== "nodeName" && key !== "className" && key !== "tagName" &&
        key !== "textContent" && key !== "innerText" && key !== "namespaceURI" &&  key !== "innerHTML"
}

function stylify(styles) {
    if (typeof styles === 'string') return styles
    var attr = "";
    Object.keys(styles).forEach(function (key) {
        var value = styles[key];
        key = key.replace(/[A-Z]/g, function(c) {
            return "-" + c.toLowerCase();
        });
        attr += key + ":" + value + ";";
    });
    return attr
}

function datasetify(elem) {
    var ds = elem.dataset;
    var props = [];

    for (var key in ds) {
        props.push({ name: "data-" + key, value: ds[key] });
    }

    return props.length ? stringify(props) : ""
}

function stringify(list) {
    var attributes = [];
    list.forEach(function (tuple) {
        var name = tuple.name;
        var value = tuple.value;

        if (name === "style") {
            value = stylify(value);
        }

        attributes.push(name + "=" + "\"" + escapeAttributeValue(value) + "\"");
    });

    return attributes.length ? " " + attributes.join(" ") : ""
}

function properties(elem) {
    var props = [];
    for (var key in elem) {
        if (isProperty(elem, key)) {
            props.push({ name: key, value: elem[key] });
        }
    }

    for (var ns in elem._attributes) {
      for (var attribute in elem._attributes[ns]) {
        var prop = elem._attributes[ns][attribute];
        var name = (prop.prefix ? prop.prefix + ":" : "") + attribute;
        props.push({ name: name, value: prop.value });
      }
    }

    if (elem.className) {
        props.push({ name: "class", value: elem.className });
    }

    return props.length ? stringify(props) : ""
}

function escapeText(s) {
    var str = '';

    if (typeof(s) === 'string') { 
        str = s; 
    } else if (s) {
        str = s.toString();
    }

    return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
}

function escapeAttributeValue(str) {
    return escapeText(str).replace(/"/g, "&quot;")
}

var domWalk$1 = index$10;
var dispatchEvent$1 = dispatchEvent_1;
var addEventListener$1 = addEventListener_1;
var removeEventListener$1 = removeEventListener_1;
var serializeNode = serialize;

var htmlns = "http://www.w3.org/1999/xhtml";

var domElement = DOMElement$1;

function DOMElement$1(tagName, owner, namespace) {
    if (!(this instanceof DOMElement$1)) {
        return new DOMElement$1(tagName)
    }

    var ns = namespace === undefined ? htmlns : (namespace || null);

    this.tagName = ns === htmlns ? String(tagName).toUpperCase() : tagName;
    this.nodeName = this.tagName;
    this.className = "";
    this.dataset = {};
    this.childNodes = [];
    this.parentNode = null;
    this.style = {};
    this.ownerDocument = owner || null;
    this.namespaceURI = ns;
    this._attributes = {};

    if (this.tagName === 'INPUT') {
      this.type = 'text';
    }
}

DOMElement$1.prototype.type = "DOMElement";
DOMElement$1.prototype.nodeType = 1;

DOMElement$1.prototype.appendChild = function _Element_appendChild(child) {
    if (child.parentNode) {
        child.parentNode.removeChild(child);
    }

    this.childNodes.push(child);
    child.parentNode = this;

    return child
};

DOMElement$1.prototype.replaceChild =
    function _Element_replaceChild(elem, needle) {
        // TODO: Throw NotFoundError if needle.parentNode !== this

        if (elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }

        var index = this.childNodes.indexOf(needle);

        needle.parentNode = null;
        this.childNodes[index] = elem;
        elem.parentNode = this;

        return needle
    };

DOMElement$1.prototype.removeChild = function _Element_removeChild(elem) {
    // TODO: Throw NotFoundError if elem.parentNode !== this

    var index = this.childNodes.indexOf(elem);
    this.childNodes.splice(index, 1);

    elem.parentNode = null;
    return elem
};

DOMElement$1.prototype.insertBefore =
    function _Element_insertBefore(elem, needle) {
        // TODO: Throw NotFoundError if referenceElement is a dom node
        // and parentNode !== this

        if (elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }

        var index = needle === null || needle === undefined ?
            -1 :
            this.childNodes.indexOf(needle);

        if (index > -1) {
            this.childNodes.splice(index, 0, elem);
        } else {
            this.childNodes.push(elem);
        }

        elem.parentNode = this;
        return elem
    };

DOMElement$1.prototype.setAttributeNS =
    function _Element_setAttributeNS(namespace, name, value) {
        var prefix = null;
        var localName = name;
        var colonPosition = name.indexOf(":");
        if (colonPosition > -1) {
            prefix = name.substr(0, colonPosition);
            localName = name.substr(colonPosition + 1);
        }
        if (this.tagName === 'INPUT' && name === 'type') {
          this.type = value;
        }
        else {
          var attributes = this._attributes[namespace] || (this._attributes[namespace] = {});
          attributes[localName] = {value: value, prefix: prefix};
        }
    };

DOMElement$1.prototype.getAttributeNS =
    function _Element_getAttributeNS(namespace, name) {
        var attributes = this._attributes[namespace];
        var value = attributes && attributes[name] && attributes[name].value;
        if (this.tagName === 'INPUT' && name === 'type') {
          return this.type;
        }
        if (typeof value !== "string") {
            return null
        }
        return value
    };

DOMElement$1.prototype.removeAttributeNS =
    function _Element_removeAttributeNS(namespace, name) {
        var attributes = this._attributes[namespace];
        if (attributes) {
            delete attributes[name];
        }
    };

DOMElement$1.prototype.hasAttributeNS =
    function _Element_hasAttributeNS(namespace, name) {
        var attributes = this._attributes[namespace];
        return !!attributes && name in attributes;
    };

DOMElement$1.prototype.setAttribute = function _Element_setAttribute(name, value) {
    return this.setAttributeNS(null, name, value)
};

DOMElement$1.prototype.getAttribute = function _Element_getAttribute(name) {
    return this.getAttributeNS(null, name)
};

DOMElement$1.prototype.removeAttribute = function _Element_removeAttribute(name) {
    return this.removeAttributeNS(null, name)
};

DOMElement$1.prototype.hasAttribute = function _Element_hasAttribute(name) {
    return this.hasAttributeNS(null, name)
};

DOMElement$1.prototype.removeEventListener = removeEventListener$1;
DOMElement$1.prototype.addEventListener = addEventListener$1;
DOMElement$1.prototype.dispatchEvent = dispatchEvent$1;

// Un-implemented
DOMElement$1.prototype.focus = function _Element_focus() {
    return void 0
};

DOMElement$1.prototype.toString = function _Element_toString() {
    return serializeNode(this)
};

DOMElement$1.prototype.getElementsByClassName = function _Element_getElementsByClassName(classNames) {
    var classes = classNames.split(" ");
    var elems = [];

    domWalk$1(this, function (node) {
        if (node.nodeType === 1) {
            var nodeClassName = node.className || "";
            var nodeClasses = nodeClassName.split(" ");

            if (classes.every(function (item) {
                return nodeClasses.indexOf(item) !== -1
            })) {
                elems.push(node);
            }
        }
    });

    return elems
};

DOMElement$1.prototype.getElementsByTagName = function _Element_getElementsByTagName(tagName) {
    tagName = tagName.toLowerCase();
    var elems = [];

    domWalk$1(this.childNodes, function (node) {
        if (node.nodeType === 1 && (tagName === '*' || node.tagName.toLowerCase() === tagName)) {
            elems.push(node);
        }
    });

    return elems
};

DOMElement$1.prototype.contains = function _Element_contains(element) {
    return domWalk$1(this, function (node) {
        return element === node
    }) || false
};

var DOMElement$2 = domElement;

var domFragment = DocumentFragment$1;

function DocumentFragment$1(owner) {
    if (!(this instanceof DocumentFragment$1)) {
        return new DocumentFragment$1()
    }

    this.childNodes = [];
    this.parentNode = null;
    this.ownerDocument = owner || null;
}

DocumentFragment$1.prototype.type = "DocumentFragment";
DocumentFragment$1.prototype.nodeType = 11;
DocumentFragment$1.prototype.nodeName = "#document-fragment";

DocumentFragment$1.prototype.appendChild  = DOMElement$2.prototype.appendChild;
DocumentFragment$1.prototype.replaceChild = DOMElement$2.prototype.replaceChild;
DocumentFragment$1.prototype.removeChild  = DOMElement$2.prototype.removeChild;

DocumentFragment$1.prototype.toString =
    function _DocumentFragment_toString() {
        return this.childNodes.map(function (node) {
            return String(node)
        }).join("")
    };

var event$1 = Event$1;

function Event$1(family) {}

Event$1.prototype.initEvent = function _Event_initEvent(type, bubbles, cancelable) {
    this.type = type;
    this.bubbles = bubbles;
    this.cancelable = cancelable;
};

Event$1.prototype.preventDefault = function _Event_preventDefault() {
    
};

var domWalk = index$10;

var Comment = domComment;
var DOMText = domText;
var DOMElement = domElement;
var DocumentFragment = domFragment;
var Event = event$1;
var dispatchEvent = dispatchEvent_1;
var addEventListener = addEventListener_1;
var removeEventListener = removeEventListener_1;

var document$3 = Document$1;

function Document$1() {
    if (!(this instanceof Document$1)) {
        return new Document$1();
    }

    this.head = this.createElement("head");
    this.body = this.createElement("body");
    this.documentElement = this.createElement("html");
    this.documentElement.appendChild(this.head);
    this.documentElement.appendChild(this.body);
    this.childNodes = [this.documentElement];
    this.nodeType = 9;
}

var proto$1 = Document$1.prototype;
proto$1.createTextNode = function createTextNode(value) {
    return new DOMText(value, this)
};

proto$1.createElementNS = function createElementNS(namespace, tagName) {
    var ns = namespace === null ? null : String(namespace);
    return new DOMElement(tagName, this, ns)
};

proto$1.createElement = function createElement(tagName) {
    return new DOMElement(tagName, this)
};

proto$1.createDocumentFragment = function createDocumentFragment() {
    return new DocumentFragment(this)
};

proto$1.createEvent = function createEvent(family) {
    return new Event(family)
};

proto$1.createComment = function createComment(data) {
    return new Comment(data, this)
};

proto$1.getElementById = function getElementById(id) {
    id = String(id);

    var result = domWalk(this.childNodes, function (node) {
        if (String(node.id) === id) {
            return node
        }
    });

    return result || null
};

proto$1.getElementsByClassName = DOMElement.prototype.getElementsByClassName;
proto$1.getElementsByTagName = DOMElement.prototype.getElementsByTagName;
proto$1.contains = DOMElement.prototype.contains;

proto$1.removeEventListener = removeEventListener;
proto$1.addEventListener = addEventListener;
proto$1.dispatchEvent = dispatchEvent;

var Document = document$3;

var index$8 = new Document();

var document_1 = createCommonjsModule(function (module) {
var topLevel = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal :
    typeof window !== 'undefined' ? window : {};
var minDoc = index$8;

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}
});

var isObject$6 = index$6;
var isHook$2 = isVhook;

var applyProperties_1 = applyProperties$1;

function applyProperties$1(node, props, previous) {
    for (var propName in props) {
        var propValue = props[propName];

        if (propValue === undefined) {
            removeProperty(node, propName, propValue, previous);
        } else if (isHook$2(propValue)) {
            removeProperty(node, propName, propValue, previous);
            if (propValue.hook) {
                propValue.hook(node,
                    propName,
                    previous ? previous[propName] : undefined);
            }
        } else {
            if (isObject$6(propValue)) {
                patchObject(node, props, previous, propName, propValue);
            } else {
                node[propName] = propValue;
            }
        }
    }
}

function removeProperty(node, propName, propValue, previous) {
    if (previous) {
        var previousValue = previous[propName];

        if (!isHook$2(previousValue)) {
            if (propName === "attributes") {
                for (var attrName in previousValue) {
                    node.removeAttribute(attrName);
                }
            } else if (propName === "style") {
                for (var i in previousValue) {
                    node.style[i] = "";
                }
            } else if (typeof previousValue === "string") {
                node[propName] = "";
            } else {
                node[propName] = null;
            }
        } else if (previousValue.unhook) {
            previousValue.unhook(node, propName, propValue);
        }
    }
}

function patchObject(node, props, previous, propName, propValue) {
    var previousValue = previous ? previous[propName] : undefined;

    // Set attributes
    if (propName === "attributes") {
        for (var attrName in propValue) {
            var attrValue = propValue[attrName];

            if (attrValue === undefined) {
                node.removeAttribute(attrName);
            } else {
                node.setAttribute(attrName, attrValue);
            }
        }

        return
    }

    if(previousValue && isObject$6(previousValue) &&
        getPrototype$1(previousValue) !== getPrototype$1(propValue)) {
        node[propName] = propValue;
        return
    }

    if (!isObject$6(node[propName])) {
        node[propName] = {};
    }

    var replacer = propName === "style" ? "" : undefined;

    for (var k in propValue) {
        var value = propValue[k];
        node[propName][k] = (value === undefined) ? replacer : value;
    }
}

function getPrototype$1(value) {
    if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(value)
    } else if (value.__proto__) {
        return value.__proto__
    } else if (value.constructor) {
        return value.constructor.prototype
    }
}

var document$5 = document_1;

var applyProperties = applyProperties_1;

var isVNode$2 = isVnode;
var isVText$2 = isVtext;
var isWidget$3 = isWidget_1;
var handleThunk$2 = handleThunk_1;

var createElement_1 = createElement;

function createElement(vnode, opts) {
    var doc = opts ? opts.document || document$5 : document$5;
    var warn = opts ? opts.warn : null;

    vnode = handleThunk$2(vnode).a;

    if (isWidget$3(vnode)) {
        return vnode.init()
    } else if (isVText$2(vnode)) {
        return doc.createTextNode(vnode.text)
    } else if (!isVNode$2(vnode)) {
        if (warn) {
            warn("Item is not a valid virtual dom node", vnode);
        }
        return null
    }

    var node = (vnode.namespace === null) ?
        doc.createElement(vnode.tagName) :
        doc.createElementNS(vnode.namespace, vnode.tagName);

    var props = vnode.properties;
    applyProperties(node, props);

    var children = vnode.children;

    for (var i = 0; i < children.length; i++) {
        var childNode = createElement(children[i], opts);
        if (childNode) {
            node.appendChild(childNode);
        }
    }

    return node
}

// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.
// We don't want to read all of the DOM nodes in the tree so we use
// the in-order tree indexing to eliminate recursion down certain branches.
// We only recurse into a DOM node if we know that it contains a child of
// interest.

var noChild = {};

var domIndex_1 = domIndex$1;

function domIndex$1(rootNode, tree, indices, nodes) {
    if (!indices || indices.length === 0) {
        return {}
    } else {
        indices.sort(ascending);
        return recurse(rootNode, tree, indices, nodes, 0)
    }
}

function recurse(rootNode, tree, indices, nodes, rootIndex) {
    nodes = nodes || {};


    if (rootNode) {
        if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = rootNode;
        }

        var vChildren = tree.children;

        if (vChildren) {

            var childNodes = rootNode.childNodes;

            for (var i = 0; i < tree.children.length; i++) {
                rootIndex += 1;

                var vChild = vChildren[i] || noChild;
                var nextIndex = rootIndex + (vChild.count || 0);

                // skip recursion down the tree if there are no nodes down here
                if (indexInRange(indices, rootIndex, nextIndex)) {
                    recurse(childNodes[i], vChild, indices, nodes, rootIndex);
                }

                rootIndex = nextIndex;
            }
        }
    }

    return nodes
}

// Binary search for an index in the interval [left, right]
function indexInRange(indices, left, right) {
    if (indices.length === 0) {
        return false
    }

    var minIndex = 0;
    var maxIndex = indices.length - 1;
    var currentIndex;
    var currentItem;

    while (minIndex <= maxIndex) {
        currentIndex = ((maxIndex + minIndex) / 2) >> 0;
        currentItem = indices[currentIndex];

        if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right
        } else if (currentItem < left) {
            minIndex = currentIndex + 1;
        } else  if (currentItem > right) {
            maxIndex = currentIndex - 1;
        } else {
            return true
        }
    }

    return false;
}

function ascending(a, b) {
    return a > b ? 1 : -1
}

var isWidget$5 = isWidget_1;

var updateWidget_1 = updateWidget$1;

function updateWidget$1(a, b) {
    if (isWidget$5(a) && isWidget$5(b)) {
        if ("name" in a && "name" in b) {
            return a.id === b.id
        } else {
            return a.init === b.init
        }
    }

    return false
}

var applyProperties$2 = applyProperties_1;

var isWidget$4 = isWidget_1;
var VPatch$1 = vpatch;

var updateWidget = updateWidget_1;

var patchOp$1 = applyPatch$1;

function applyPatch$1(vpatch$$1, domNode, renderOptions) {
    var type = vpatch$$1.type;
    var vNode = vpatch$$1.vNode;
    var patch = vpatch$$1.patch;

    switch (type) {
        case VPatch$1.REMOVE:
            return removeNode(domNode, vNode)
        case VPatch$1.INSERT:
            return insertNode(domNode, patch, renderOptions)
        case VPatch$1.VTEXT:
            return stringPatch(domNode, vNode, patch, renderOptions)
        case VPatch$1.WIDGET:
            return widgetPatch(domNode, vNode, patch, renderOptions)
        case VPatch$1.VNODE:
            return vNodePatch(domNode, vNode, patch, renderOptions)
        case VPatch$1.ORDER:
            reorderChildren(domNode, patch);
            return domNode
        case VPatch$1.PROPS:
            applyProperties$2(domNode, patch, vNode.properties);
            return domNode
        case VPatch$1.THUNK:
            return replaceRoot(domNode,
                renderOptions.patch(domNode, patch, renderOptions))
        default:
            return domNode
    }
}

function removeNode(domNode, vNode) {
    var parentNode = domNode.parentNode;

    if (parentNode) {
        parentNode.removeChild(domNode);
    }

    destroyWidget(domNode, vNode);

    return null
}

function insertNode(parentNode, vNode, renderOptions) {
    var newNode = renderOptions.render(vNode, renderOptions);

    if (parentNode) {
        parentNode.appendChild(newNode);
    }

    return parentNode
}

function stringPatch(domNode, leftVNode, vText, renderOptions) {
    var newNode;

    if (domNode.nodeType === 3) {
        domNode.replaceData(0, domNode.length, vText.text);
        newNode = domNode;
    } else {
        var parentNode = domNode.parentNode;
        newNode = renderOptions.render(vText, renderOptions);

        if (parentNode && newNode !== domNode) {
            parentNode.replaceChild(newNode, domNode);
        }
    }

    return newNode
}

function widgetPatch(domNode, leftVNode, widget, renderOptions) {
    var updating = updateWidget(leftVNode, widget);
    var newNode;

    if (updating) {
        newNode = widget.update(leftVNode, domNode) || domNode;
    } else {
        newNode = renderOptions.render(widget, renderOptions);
    }

    var parentNode = domNode.parentNode;

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode);
    }

    if (!updating) {
        destroyWidget(domNode, leftVNode);
    }

    return newNode
}

function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
    var parentNode = domNode.parentNode;
    var newNode = renderOptions.render(vNode, renderOptions);

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode);
    }

    return newNode
}

function destroyWidget(domNode, w) {
    if (typeof w.destroy === "function" && isWidget$4(w)) {
        w.destroy(domNode);
    }
}

function reorderChildren(domNode, moves) {
    var childNodes = domNode.childNodes;
    var keyMap = {};
    var node;
    var remove;
    var insert;

    for (var i = 0; i < moves.removes.length; i++) {
        remove = moves.removes[i];
        node = childNodes[remove.from];
        if (remove.key) {
            keyMap[remove.key] = node;
        }
        domNode.removeChild(node);
    }

    var length = childNodes.length;
    for (var j = 0; j < moves.inserts.length; j++) {
        insert = moves.inserts[j];
        node = keyMap[insert.key];
        // this is the weirdest bug i've ever seen in webkit
        domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to]);
    }
}

function replaceRoot(oldRoot, newRoot) {
    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
        oldRoot.parentNode.replaceChild(newRoot, oldRoot);
    }

    return newRoot;
}

var document$2 = document_1;
var isArray$5 = index$4;

var render$1 = createElement_1;
var domIndex = domIndex_1;
var patchOp = patchOp$1;
var patch_1$2 = patch$2;

function patch$2(rootNode, patches, renderOptions) {
    renderOptions = renderOptions || {};
    renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch$2
        ? renderOptions.patch
        : patchRecursive;
    renderOptions.render = renderOptions.render || render$1;

    return renderOptions.patch(rootNode, patches, renderOptions)
}

function patchRecursive(rootNode, patches, renderOptions) {
    var indices = patchIndices(patches);

    if (indices.length === 0) {
        return rootNode
    }

    var index = domIndex(rootNode, patches.a, indices);
    var ownerDocument = rootNode.ownerDocument;

    if (!renderOptions.document && ownerDocument !== document$2) {
        renderOptions.document = ownerDocument;
    }

    for (var i = 0; i < indices.length; i++) {
        var nodeIndex = indices[i];
        rootNode = applyPatch(rootNode,
            index[nodeIndex],
            patches[nodeIndex],
            renderOptions);
    }

    return rootNode
}

function applyPatch(rootNode, domNode, patchList, renderOptions) {
    if (!domNode) {
        return rootNode
    }

    var newNode;

    if (isArray$5(patchList)) {
        for (var i = 0; i < patchList.length; i++) {
            newNode = patchOp(patchList[i], domNode, renderOptions);

            if (domNode === rootNode) {
                rootNode = newNode;
            }
        }
    } else {
        newNode = patchOp(patchList, domNode, renderOptions);

        if (domNode === rootNode) {
            rootNode = newNode;
        }
    }

    return rootNode
}

function patchIndices(patches) {
    var indices = [];

    for (var key in patches) {
        if (key !== "a") {
            indices.push(Number(key));
        }
    }

    return indices
}

var patch$1 = patch_1$2;

var patch_1 = patch$1;

var version$6 = version$2;
var isVNode$4 = isVnode;
var isWidget$7 = isWidget_1;
var isThunk$3 = isThunk_1;
var isVHook = isVhook;

var vnode = VirtualNode;

var noProperties = {};
var noChildren = [];

function VirtualNode(tagName, properties, children, key, namespace) {
    this.tagName = tagName;
    this.properties = properties || noProperties;
    this.children = children || noChildren;
    this.key = key != null ? String(key) : undefined;
    this.namespace = (typeof namespace === "string") ? namespace : null;

    var count = (children && children.length) || 0;
    var descendants = 0;
    var hasWidgets = false;
    var hasThunks = false;
    var descendantHooks = false;
    var hooks;

    for (var propName in properties) {
        if (properties.hasOwnProperty(propName)) {
            var property = properties[propName];
            if (isVHook(property) && property.unhook) {
                if (!hooks) {
                    hooks = {};
                }

                hooks[propName] = property;
            }
        }
    }

    for (var i = 0; i < count; i++) {
        var child = children[i];
        if (isVNode$4(child)) {
            descendants += child.count || 0;

            if (!hasWidgets && child.hasWidgets) {
                hasWidgets = true;
            }

            if (!hasThunks && child.hasThunks) {
                hasThunks = true;
            }

            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
                descendantHooks = true;
            }
        } else if (!hasWidgets && isWidget$7(child)) {
            if (typeof child.destroy === "function") {
                hasWidgets = true;
            }
        } else if (!hasThunks && isThunk$3(child)) {
            hasThunks = true;
        }
    }

    this.count = count + descendants;
    this.hasWidgets = hasWidgets;
    this.hasThunks = hasThunks;
    this.hooks = hooks;
    this.descendantHooks = descendantHooks;
}

VirtualNode.prototype.version = version$6;
VirtualNode.prototype.type = "VirtualNode";

var version$7 = version$2;

var vtext = VirtualText;

function VirtualText(text) {
    this.text = String(text);
}

VirtualText.prototype.version = version$7;
VirtualText.prototype.type = "VirtualText";

/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
var index$14 = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

var split$2 = index$14;

var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
var notClassId = /^\.|#/;

var parseTag_1 = parseTag$1;

function parseTag$1(tag, props) {
    if (!tag) {
        return 'DIV';
    }

    var noId = !(props.hasOwnProperty('id'));

    var tagParts = split$2(tag, classIdSplit);
    var tagName = null;

    if (notClassId.test(tagParts[1])) {
        tagName = 'DIV';
    }

    var classes, part, type, i;

    for (i = 0; i < tagParts.length; i++) {
        part = tagParts[i];

        if (!part) {
            continue;
        }

        type = part.charAt(0);

        if (!tagName) {
            tagName = part;
        } else if (type === '.') {
            classes = classes || [];
            classes.push(part.substring(1, part.length));
        } else if (type === '#' && noId) {
            props.id = part.substring(1, part.length);
        }
    }

    if (classes) {
        if (props.className) {
            classes.push(props.className);
        }

        props.className = classes.join(' ');
    }

    return props.namespace ? tagName : tagName.toUpperCase();
}

var softSetHook$1 = SoftSetHook;

function SoftSetHook(value) {
    if (!(this instanceof SoftSetHook)) {
        return new SoftSetHook(value);
    }

    this.value = value;
}

SoftSetHook.prototype.hook = function (node, propertyName) {
    if (node[propertyName] !== this.value) {
        node[propertyName] = this.value;
    }
};

/*global window, global*/

var root = typeof window !== 'undefined' ?
    window : typeof commonjsGlobal !== 'undefined' ?
    commonjsGlobal : {};

var index$18 = Individual$1;

function Individual$1(key, value) {
    if (key in root) {
        return root[key];
    }

    root[key] = value;

    return value;
}

var Individual = index$18;

var oneVersion = OneVersion;

function OneVersion(moduleName, version, defaultValue) {
    var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;
    var enforceKey = key + '_ENFORCE_SINGLETON';

    var versionValue = Individual(enforceKey, version);

    if (versionValue !== version) {
        throw new Error('Can only have one copy of ' +
            moduleName + '.\n' +
            'You already have version ' + versionValue +
            ' installed.\n' +
            'This means you cannot install version ' + version);
    }

    return Individual(key, defaultValue);
}

var OneVersionConstraint = oneVersion;

var MY_VERSION = '7';
OneVersionConstraint('ev-store', MY_VERSION);

var hashKey = '__EV_STORE_KEY@' + MY_VERSION;

var index$16 = EvStore$1;

function EvStore$1(elem) {
    var hash = elem[hashKey];

    if (!hash) {
        hash = elem[hashKey] = {};
    }

    return hash;
}

var EvStore = index$16;

var evHook$1 = EvHook;

function EvHook(value) {
    if (!(this instanceof EvHook)) {
        return new EvHook(value);
    }

    this.value = value;
}

EvHook.prototype.hook = function (node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = this.value;
};

EvHook.prototype.unhook = function(node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = undefined;
};

var isArray$6 = index$4;

var VNode$1 = vnode;
var VText$1 = vtext;
var isVNode$3 = isVnode;
var isVText$3 = isVtext;
var isWidget$6 = isWidget_1;
var isHook$3 = isVhook;
var isVThunk = isThunk_1;

var parseTag = parseTag_1;
var softSetHook = softSetHook$1;
var evHook = evHook$1;

var index$12 = h$3;

function h$3(tagName, properties, children) {
    var childNodes = [];
    var tag, props, key, namespace;

    if (!children && isChildren(properties)) {
        children = properties;
        props = {};
    }

    props = props || properties || {};
    tag = parseTag(tagName, props);

    // support keys
    if (props.hasOwnProperty('key')) {
        key = props.key;
        props.key = undefined;
    }

    // support namespace
    if (props.hasOwnProperty('namespace')) {
        namespace = props.namespace;
        props.namespace = undefined;
    }

    // fix cursor bug
    if (tag === 'INPUT' &&
        !namespace &&
        props.hasOwnProperty('value') &&
        props.value !== undefined &&
        !isHook$3(props.value)
    ) {
        props.value = softSetHook(props.value);
    }

    transformProperties(props);

    if (children !== undefined && children !== null) {
        addChild(children, childNodes, tag, props);
    }


    return new VNode$1(tag, props, childNodes, key, namespace);
}

function addChild(c, childNodes, tag, props) {
    if (typeof c === 'string') {
        childNodes.push(new VText$1(c));
    } else if (typeof c === 'number') {
        childNodes.push(new VText$1(String(c)));
    } else if (isChild(c)) {
        childNodes.push(c);
    } else if (isArray$6(c)) {
        for (var i = 0; i < c.length; i++) {
            addChild(c[i], childNodes, tag, props);
        }
    } else if (c === null || c === undefined) {
        return;
    } else {
        throw UnexpectedVirtualElement({
            foreignObject: c,
            parentVnode: {
                tagName: tag,
                properties: props
            }
        });
    }
}

function transformProperties(props) {
    for (var propName in props) {
        if (props.hasOwnProperty(propName)) {
            var value = props[propName];

            if (isHook$3(value)) {
                continue;
            }

            if (propName.substr(0, 3) === 'ev-') {
                // add ev-foo support
                props[propName] = evHook(value);
            }
        }
    }
}

function isChild(x) {
    return isVNode$3(x) || isVText$3(x) || isWidget$6(x) || isVThunk(x);
}

function isChildren(x) {
    return typeof x === 'string' || isArray$6(x) || isChild(x);
}

function UnexpectedVirtualElement(data) {
    var err = new Error();

    err.type = 'virtual-hyperscript.unexpected.virtual-element';
    err.message = 'Unexpected virtual child passed to h().\n' +
        'Expected a VNode / Vthunk / VWidget / string but:\n' +
        'got:\n' +
        errorString(data.foreignObject) +
        '.\n' +
        'The parent vnode is:\n' +
        errorString(data.parentVnode);
        '\n' +
        'Suggested fix: change your `h(..., [ ... ])` callsite.';
    err.foreignObject = data.foreignObject;
    err.parentVnode = data.parentVnode;

    return err;
}

function errorString(obj) {
    try {
        return JSON.stringify(obj, null, '    ');
    } catch (e) {
        return String(obj);
    }
}

var h$2 = index$12;

var h_1 = h$2;

var createElement$1 = createElement_1;

var createElement_1$2 = createElement$1;

var diff = diff_1;
var patch = patch_1;
var h$1 = h_1;
var create$7 = createElement_1$2;
var VNode = vnode;
var VText = vtext;

var index$2 = {
    diff: diff,
    patch: patch,
    h: h$1,
    create: create$7,
    VNode: VNode,
    VText: VText
};

var h$1 = index$2.h;
var create$7 = index$2.create;
var diff = index$2.diff;
var patch = index$2.patch;

var Observer = (function () {
    function Observer(onNext, onError, onCompleted) {
        this.OnNext = onNext;
        this.OnError = onError || (function (e) { });
        this.OnCompleted = onCompleted || function () { };
    }
    Observer.prototype[_Symbol.reflection] = function () {
        return { interfaces: ["System.IObserver"] };
    };
    return Observer;
}());

function add$5(callback, source) {
    source.Subscribe(new Observer(callback));
}

var Event$2 = (function () {
    function Event(_subscriber, delegates) {
        this._subscriber = _subscriber;
        this.delegates = delegates || new Array();
    }
    Event.prototype.Add = function (f) {
        this._addHandler(f);
    };
    Object.defineProperty(Event.prototype, "Publish", {
        get: function () {
            return this;
        },
        enumerable: true,
        configurable: true
    });
    Event.prototype.Trigger = function (value) {
        iterate(function (f) { return f(value); }, this.delegates);
    };
    Event.prototype._addHandler = function (f) {
        this.delegates.push(f);
    };
    Event.prototype._removeHandler = function (f) {
        var index = this.delegates.indexOf(f);
        if (index > -1)
            this.delegates.splice(index, 1);
    };
    Event.prototype.AddHandler = function (handler) {
        if (this._dotnetDelegates == null) {
            this._dotnetDelegates = new Map();
        }
        var f = function (x) { handler(null, x); };
        this._dotnetDelegates.set(handler, f);
        this._addHandler(f);
    };
    Event.prototype.RemoveHandler = function (handler) {
        if (this._dotnetDelegates != null) {
            var f = this._dotnetDelegates.get(handler);
            if (f != null) {
                this._dotnetDelegates.delete(handler);
                this._removeHandler(f);
            }
        }
    };
    Event.prototype._subscribeFromObserver = function (observer) {
        var _this = this;
        if (this._subscriber)
            return this._subscriber(observer);
        var callback = observer.OnNext;
        this._addHandler(callback);
        return createDisposable(function () { return _this._removeHandler(callback); });
    };
    Event.prototype._subscribeFromCallback = function (callback) {
        var _this = this;
        this._addHandler(callback);
        return createDisposable(function () { return _this._removeHandler(callback); });
    };
    Event.prototype.Subscribe = function (arg) {
        return typeof arg == "function"
            ? this._subscribeFromCallback(arg)
            : this._subscribeFromObserver(arg);
    };
    return Event;
}());

var DomAttribute = function () {
  function DomAttribute(caseName, fields) {
    _classCallCheck(this, DomAttribute);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(DomAttribute, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Html.DomAttribute",
        interfaces: ["FSharpUnion"],
        cases: {
          Attribute: ["string"],
          Event: ["function"],
          Property: [Any]
        }
      };
    }
  }]);

  return DomAttribute;
}();
setType("TheGamma.Html.DomAttribute", DomAttribute);
var DomNode = function () {
  function DomNode(caseName, fields) {
    _classCallCheck(this, DomNode);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(DomNode, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Html.DomNode",
        interfaces: ["FSharpUnion"],
        cases: {
          Delayed: ["string", DomNode, "function"],
          Element: ["string", "string", FableArray(Tuple(["string", DomAttribute])), FableArray(DomNode), Option("function")],
          Part: ["function"],
          Text: ["string"]
        }
      };
    }
  }]);

  return DomNode;
}();
setType("TheGamma.Html.DomNode", DomNode);
function createTree(ns, tag, args, children) {
  var attrs = [];
  var props = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(args), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var forLoopVar = _step.value;
      var matchValue = [forLoopVar[0], forLoopVar[1]];

      if (matchValue[1].Case === "Property") {
        var o = matchValue[1].Fields[0];
        props.push([matchValue[0], o]);
      } else if (matchValue[1].Case === "Event") {
        (function () {
          var f = matchValue[1].Fields[0];
          props.push(["on" + matchValue[0], function (o_1) {
            f(o_1["target"])(event);
          }]);
        })();
      } else {
        var v = matchValue[1].Fields[0];
        attrs.push([matchValue[0], v]);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var attrs_1 = createObj(attrs);
  var ns_1 = (ns == null ? true : ns === "") ? new List$1() : ofArray$1([["namespace", ns]]);
  var props_1 = createObj(append(append$1(ns_1, ofArray$1([["attributes", attrs_1]])), props));
  var elem = h$1(tag, props_1, children);
  return elem;
}
var counter = 0;
function renderVirtual(node) {
  if (node.Case === "Element") {
    if (node.Fields[4] == null) {
      return createTree(node.Fields[0], node.Fields[1], node.Fields[2], node.Fields[3].map(function (node_1) {
        return renderVirtual(node_1);
      }));
    } else {
      throw new Error("renderVirtual: Does not support elements with after-render handlers");
    }
  } else if (node.Case === "Delayed") {
    var _ret2 = function () {
      counter = counter + 1;
      var id = fsFormat("delayed_%d")(function (x) {
        return x;
      })(counter);

      var waitForAdded = function waitForAdded(n) {
        return function (el) {
          if (el.parentElement != null) {
            el.dataset.renderedSymbol = node.Fields[0];
            el.id = id;
            node.Fields[2](id);
          } else if (n > 0) {
            window.setTimeout(function () {
              waitForAdded(n - 1)(el);
            }, 1);
          } else {
            Log.error("html", "Delayed element was not created in time");
          }
        };
      };

      var Hook = function Hook() {};

      Hook.prototype.hook = function (node_2, propertyName, previousValue) {
        if (node_2.dataset.renderedSymbol !== node.Fields[0]) {
          waitForAdded(10)(node_2);
        }
      };

      var h$$1 = new Hook();
      return {
        v: createTree(null, "div", ofArray$1([["renderhk", new DomAttribute("Property", [h$$1])]]), [renderVirtual(node.Fields[1])])
      };
    }();

    if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
  } else if (node.Case === "Part") {
    throw new Error("renderVirtual: Does not support parts");
  } else {
    return node.Fields[0];
  }
}
function render(node) {
  if (node.Case === "Delayed") {
    var _ret3 = function () {
      counter = counter + 1;
      var el = document.createElement("div");
      el.id = fsFormat("delayed_%d")(function (x) {
        return x;
      })(counter);
      return {
        v: [el, function () {
          node.Fields[2](el.id);
        }]
      };
    }();

    if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
  } else if (node.Case === "Part") {
    var _ret4 = function () {
      var el_1 = document.createElement("div");
      return {
        v: [el_1, function () {
          node.Fields[0](el_1);
        }]
      };
    }();

    if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
  } else if (node.Case === "Element") {
    var _ret5 = function () {
      var el_2 = (node.Fields[0] == null ? true : node.Fields[0] === "") ? document.createElement(node.Fields[1]) : document.createElementNS(node.Fields[0], node.Fields[1]);
      var rc = node.Fields[3].map(function (node_1) {
        return render(node_1);
      });

      for (var idx = 0; idx <= rc.length - 1; idx++) {
        var forLoopVar = rc[idx];
        el_2.appendChild(forLoopVar[0]);
      }

      var _loop = function _loop(idx_1) {
        var forLoopVar_1 = node.Fields[2][idx_1];

        if (forLoopVar_1[1].Case === "Attribute") {
          el_2.setAttribute(forLoopVar_1[0], forLoopVar_1[1].Fields[0]);
        } else if (forLoopVar_1[1].Case === "Event") {
          el_2.addEventListener(forLoopVar_1[0], function (delegateArg0) {
            forLoopVar_1[1].Fields[0](el_2)(delegateArg0);
          });
        } else {
          el_2[forLoopVar_1[0]] = forLoopVar_1[1].Fields[0];
        }
      };

      for (var idx_1 = 0; idx_1 <= node.Fields[2].length - 1; idx_1++) {
        _loop(idx_1);
      }

      var onRender = function onRender() {
        for (var idx_2 = 0; idx_2 <= rc.length - 1; idx_2++) {
          var forLoopVar_2 = rc[idx_2];
          forLoopVar_2[1](null);
        }

        iterate(function (f) {
          f(el_2);
        }, defaultArg(node.Fields[4], [], function (x) {
          return [x];
        }));
      };

      return {
        v: [el_2, onRender]
      };
    }();

    if ((typeof _ret5 === "undefined" ? "undefined" : _typeof(_ret5)) === "object") return _ret5.v;
  } else {
    return [document.createTextNode(node.Fields[0]), function () {}];
  }
}
function renderTo(node, dom) {
  while (node.lastChild != null) {
    node.removeChild(node.lastChild);
  }

  var patternInput = render(dom);
  node.appendChild(patternInput[0]);
  patternInput[1](null);
}
function text(s) {
  return new DomNode("Text", [s]);
}
function op_EqualsGreater(k, v) {
  return [k, new DomAttribute("Attribute", [v])];
}
function op_EqualsBangGreater(k, f) {
  return [k, new DomAttribute("Event", [f])];
}
var El = function () {
  _createClass(El, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Html.El",
        properties: {
          Namespace: "string"
        }
      };
    }
  }]);

  function El(ns) {
    _classCallCheck(this, El);

    this.ns = ns;
  }

  _createClass(El, [{
    key: "delayed",
    value: function (sym, body, f) {
      return new DomNode("Delayed", [sym, body, f]);
    }
  }, {
    key: "part",
    value: function (initial, fold$$1) {
      var evt = new Event$2();
      var state = initial;
      var container = null;
      var renderer = null;

      var render_1 = function render_1() {
        var matchValue = [container, renderer];
        var $var4 = matchValue[0] != null ? matchValue[1] != null ? [0, matchValue[0], matchValue[1]] : [1] : [1];

        switch ($var4[0]) {
          case 0:
            (function (dom) {
              renderTo($var4[1], dom);
            })($var4[2](state));

            break;

          case 1:
            break;
        }
      };

      add$5(function (e) {
        state = fold$$1(state)(e);
        render_1(null);
      }, evt.Publish);
      return [function (arg00) {
        evt.Trigger(arg00);
      }, function (r) {
        renderer = r;
        return new DomNode("Part", [function (el) {
          container = el;
          render_1(null);
        }]);
      }];
    }
  }, {
    key: "Namespace",
    get: function () {
      return this.ns;
    }
  }], [{
    key: "op_Dynamic",
    value: function (el, n) {
      return function (a) {
        return function (b) {
          var patternInput = n !== "chosen" ? [n, null] : ["select", function (el_1) {
            jQuery(el_1).chosen();
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = _getIterator(a), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var forLoopVar = _step2.value;

                if (forLoopVar[1].Case === "Event") {
                  jQuery(el_1).on(forLoopVar[0], function () {
                    forLoopVar[1].Fields[0](el_1)(event);
                  });
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }];
          return new DomNode("Element", [el.Namespace, patternInput[0], _Array$from(a), _Array$from(b), patternInput[1]]);
        };
      };
    }
  }]);

  return El;
}();
setType("TheGamma.Html.El", El);
var h$$1 = new El(null);
var s = new El("http://www.w3.org/2000/svg");

var html = function () {
  function html() {
    _classCallCheck(this, html);
  }

  _createClass(html, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.html",
        properties: {}
      };
    }
  }], [{
    key: "img",
    value: function (url) {
      return function (arg0) {
        return function (arg1) {
          return El.op_Dynamic(arg0, arg1);
        };
      }(h$$1)("img")(ofArray$1([op_EqualsGreater("src", url)]))(new List$1());
    }
  }]);

  return html;
}();
setType("TheGamma.html", html);
var table = function () {
  function table(data, showKey, emptyText, hiddenColumns, addedColumns) {
    _classCallCheck(this, table);

    this.data = data;
    this.showKey = showKey;
    this.emptyText = emptyText;
    this.hiddenColumns = hiddenColumns;
    this.addedColumns = addedColumns;
  }

  _createClass(table, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.table",
        interfaces: ["FSharpRecord"],
        properties: {
          data: makeGeneric(series, {
            k: GenericParam("k"),
            v: GenericParam("v")
          }),
          showKey: Option("boolean"),
          emptyText: "string",
          hiddenColumns: makeGeneric(FableSet, {
            T: "string"
          }),
          addedColumns: makeGeneric(List$1, {
            T: Tuple(["string", "function"])
          })
        }
      };
    }
  }, {
    key: "set",
    value: function (title, showKey, emptyText) {
      var data = this.data.set(this.data.data, null, null, title != null ? title : this.data.seriesName);
      var emptyText_1 = emptyText != null ? emptyText : this.emptyText;
      return new table(data, showKey == null ? this.showKey : showKey, emptyText_1, this.hiddenColumns, this.addedColumns);
    }
  }, {
    key: "hideColumns",
    value: function (names) {
      var hiddenColumns = create$5(names, new GenericComparer(compare));

      return new table(this.data, this.showKey, this.emptyText, hiddenColumns, this.addedColumns);
    }
  }, {
    key: "addColumn",
    value: function (name, f) {
      var addedColumns = new List$1([name, f], this.addedColumns);
      return new table(this.data, this.showKey, this.emptyText, this.hiddenColumns, addedColumns);
    }
  }, {
    key: "render",
    value: function () {
      var _this = this;

      var row = function row(showKey) {
        return function (el) {
          return function (k) {
            return function (things) {
              return function (arg0) {
                return function (arg1) {
                  return El.op_Dynamic(arg0, arg1);
                };
              }(h$$1)("tr")(new List$1())(toList(delay(function () {
                return append(showKey ? singleton(function (arg0_1) {
                  return function (arg1_1) {
                    return El.op_Dynamic(arg0_1, arg1_1);
                  };
                }(h$$1)(el)(new List$1())(ofArray$1([text(k)]))) : empty(), delay(function () {
                  return map$3(function (t) {
                    return function (arg0_2) {
                      return function (arg1_2) {
                        return El.op_Dynamic(arg0_2, arg1_2);
                      };
                    }(h$$1)(el)(new List$1())(ofArray$1([t]));
                  }, things);
                }));
              })));
            };
          };
        };
      };

      var makeTable = function makeTable(showKey_1) {
        return function (k_1) {
          return function (header) {
            return function (body) {
              return function (arg0_3) {
                return function (arg1_3) {
                  return El.op_Dynamic(arg0_3, arg1_3);
                };
              }(h$$1)("table")(ofArray$1([op_EqualsGreater("class", "thegamma-table")]))(toList(delay(function () {
                return append(!isNullOrWhiteSpace(_this.data.seriesName) ? singleton(function (arg0_4) {
                  return function (arg1_4) {
                    return El.op_Dynamic(arg0_4, arg1_4);
                  };
                }(h$$1)("caption")(new List$1())(ofArray$1([text(_this.data.seriesName)]))) : empty(), delay(function () {
                  return append(singleton(function (arg0_5) {
                    return function (arg1_5) {
                      return El.op_Dynamic(arg0_5, arg1_5);
                    };
                  }(h$$1)("thead")(new List$1())(ofArray$1([row(showKey_1)("th")(k_1)(header)]))), delay(function () {
                    return singleton(function (arg0_6) {
                      return function (arg1_6) {
                        return El.op_Dynamic(arg0_6, arg1_6);
                      };
                    }(h$$1)("tbody")(new List$1())(body));
                  }));
                }));
              })));
            };
          };
        };
      };

      var formatAdded = function formatAdded(o) {
        var isSeries = toList(delay(function () {
          return map$3(function (kv) {
            return kv.key;
          }, function (o) {
            return _Object$keys(o).map(function (k) {
              return {
                "key": k,
                "value": o[k]
              };
            });
          }(o));
        })).Equals(ofArray$1(["data", "keyName", "valueName", "seriesName"]));

        if (isSeries) {
          var result = null;
          o.data.Then(function (r) {
            result = r;
          });
          return function (arg0_7) {
            return function (arg1_7) {
              return El.op_Dynamic(arg0_7, arg1_7);
            };
          }(h$$1)("span")(new List$1())(ofArray$1(result.map(function (tuple) {
            return tuple[1];
          })));
        } else {
          return text(toString$2(o));
        }
      };

      return function (builder_) {
        return builder_.Delay(function () {
          return builder_.TryWith(builder_.Delay(function () {
            return builder_.Bind(Async_AwaitFuture_Static(_this.data.data), function (_arg25) {
              if (_arg25.length === 0) {
                return builder_.Return(function (arg0_8) {
                  return function (arg1_8) {
                    return El.op_Dynamic(arg0_8, arg1_8);
                  };
                }(h$$1)("div")(ofArray$1([op_EqualsGreater("class", "placeholder")]))(ofArray$1([function (arg0_9) {
                  return function (arg1_9) {
                    return El.op_Dynamic(arg0_9, arg1_9);
                  };
                }(h$$1)("p")(new List$1())(ofArray$1([text(_this.emptyText)]))])));
              } else {
                var _ret = function () {
                  var filteredProperties = function filteredProperties(o_1) {
                    return function (o) {
                      return _Object$keys(o).map(function (k) {
                        return {
                          "key": k,
                          "value": o[k]
                        };
                      });
                    }(o_1).filter(function (kv_1) {
                      return !_this.hiddenColumns.has(kv_1.key);
                    });
                  };

                  var patternInput = head(_arg25);
                  var headers = toList(delay(function () {
                    return append(_typeof(patternInput[1]) == 'object' ? map$3(function (kv_2) {
                      return text(kv_2.key);
                    }, filteredProperties(patternInput[1])) : singleton(text(_this.data.valueName)), delay(function () {
                      return collect(function (matchValue) {
                        return singleton(text(matchValue[0]));
                      }, _this.addedColumns);
                    }));
                  }));
                  var showKey_2 = _this.showKey != null ? _this.showKey : !(_typeof(patternInput[1]) == 'object');
                  return {
                    v: builder_.Return(function (arg00) {
                      var clo1 = makeTable(arg00);
                      return function (arg10) {
                        var clo2 = clo1(arg10);
                        return function (arg20) {
                          var clo3 = clo2(arg20);
                          return function (arg30) {
                            return clo3(arg30);
                          };
                        };
                      };
                    }(showKey_2)(_this.data.keyName)(headers)(toList(delay(function () {
                      return collect(function (matchValue_1) {
                        return singleton(function () {
                          var formattedVals = toList(delay(function () {
                            return append(_typeof(matchValue_1[1]) == 'object' ? collect(function (kv_3) {
                              return kv_3.value instanceof Date ? singleton(text(kv_3.value.toLocaleString("en-US", {
                                hour: "numeric",
                                minute: "numeric",
                                second: "numeric"
                              }) + ", " + kv_3.value.toLocaleString("en-US", {
                                day: "numeric",
                                year: "numeric",
                                month: "short"
                              }))) : !(typeof kv_3.value == 'number') ? singleton(text(toString$2(kv_3.value))) : isNaN(kv_3.value) ? singleton(text("")) : singleton(text(niceNumber(kv_3.value, 2)));
                            }, filteredProperties(matchValue_1[1])) : matchValue_1[1] instanceof Date ? singleton(text(matchValue_1[1].toLocaleString("en-US", {
                              hour: "numeric",
                              minute: "numeric",
                              second: "numeric"
                            }) + ", " + matchValue_1[1].toLocaleString("en-US", {
                              day: "numeric",
                              year: "numeric",
                              month: "short"
                            }))) : !(typeof matchValue_1[1] == 'number') ? singleton(text(toString$2(matchValue_1[1]))) : isNaN(matchValue_1[1]) ? singleton(text("")) : singleton(text(niceNumber(matchValue_1[1], 2))), delay(function () {
                              return collect(function (matchValue_2) {
                                return singleton(formatAdded(matchValue_2[1](matchValue_1[1])));
                              }, _this.addedColumns);
                            }));
                          }));
                          return function (arg00_1) {
                            var clo1_1 = row(arg00_1);
                            return function (arg10_1) {
                              var clo2_1 = clo1_1(arg10_1);
                              return function (arg20_1) {
                                var clo3_1 = clo2_1(arg20_1);
                                return function (arg30_1) {
                                  return clo3_1(arg30_1);
                                };
                              };
                            };
                          }(showKey_2)("td")(matchValue_1[0])(formattedVals);
                        }());
                      }, _arg25);
                    }))))
                  };
                }();

                if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
              }
            });
          }), function (_arg32) {
            Log.exn("live", "Getting data for table failed: %O", _arg32);
            return builder_.Return(function () {
              throw _arg32;
            }());
          });
        });
      }(singleton$2);
    }
  }, {
    key: "show",
    value: function (outputId) {
      var _this2 = this;

      (function (arg00) {
        startImmediate(arg00);
      })(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(_this2.render(), function (_arg33) {
            renderTo(document.getElementById(outputId), _arg33);
            return builder_.Zero();
          });
        });
      }(singleton$2));
    }
  }], [{
    key: "create",
    value: function (data) {
      var emptyText = "No data available";

      var hiddenColumns = create$5(null, new GenericComparer(compare));

      var addedColumns = new List$1();
      return new table(data, null, emptyText, hiddenColumns, addedColumns);
    }
  }]);

  return table;
}();
setType("TheGamma.table", table);
var placeholder = function () {
  _createClass(placeholder, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.placeholder",
        properties: {}
      };
    }
  }]);

  function placeholder(message) {
    _classCallCheck(this, placeholder);

    this.message = message;
  }

  _createClass(placeholder, [{
    key: "show",
    value: function (outputId) {
      renderTo(document.getElementById(outputId), function (arg0) {
        return function (arg1) {
          return El.op_Dynamic(arg0, arg1);
        };
      }(h$$1)("div")(ofArray$1([op_EqualsGreater("class", "placeholder")]))(ofArray$1([function (arg0_1) {
        return function (arg1_1) {
          return El.op_Dynamic(arg0_1, arg1_1);
        };
      }(h$$1)("p")(new List$1())(ofArray$1([text(this.message)]))])));
    }
  }], [{
    key: "create",
    value: function (message) {
      return new placeholder(message);
    }
  }]);

  return placeholder;
}();
setType("TheGamma.placeholder", placeholder);

var math = function () {
  function math() {
    _classCallCheck(this, math);
  }

  _createClass(math, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.General.math",
        properties: {}
      };
    }
  }], [{
    key: "sqrt",
    value: function (f) {
      return Math.sqrt(f);
    }
  }, {
    key: "pow",
    value: function (f, k) {
      return Math.pow(f, k);
    }
  }, {
    key: "log",
    value: function (f, b) {
      if (b != null) {
        return Math.log(f, b);
      } else {
        return Math.log(f);
      }
    }
  }, {
    key: "min",
    value: function (f1, f2) {
      if (f1 < f2) {
        return f1;
      } else {
        return f2;
      }
    }
  }, {
    key: "max",
    value: function (f1, f2) {
      if (f1 > f2) {
        return f1;
      } else {
        return f2;
      }
    }
  }]);

  return math;
}();
setType("TheGamma.General.math", math);
var date$1 = function () {
  function date$$1() {
    _classCallCheck(this, date$$1);
  }

  _createClass(date$$1, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.General.date",
        properties: {}
      };
    }
  }], [{
    key: "now",
    value: function () {
      return now();
    }
  }, {
    key: "date",
    value: function (year$$1, month$$1, day$$1) {
      return create$3(year$$1, month$$1, day$$1);
    }
  }, {
    key: "time",
    value: function (year$$1, month$$1, day$$1, hour$$1, minute$$1, second$$1) {
      return create$3(year$$1, month$$1, day$$1, hour$$1, minute$$1, second$$1);
    }
  }]);

  return date$$1;
}();
setType("TheGamma.General.date", date$1);

// 20.2.2.21 Math.log10(x)
var $export$8 = _export;

$export$8($export$8.S, 'Math', {
  log10: function log10(x){
    return Math.log(x) / Math.LN10;
  }
});

var log10$1 = _core.Math.log10;

var log10 = createCommonjsModule(function (module) {
module.exports = { "default": log10$1, __esModule: true };
});

var _Math$log = unwrapExports(log10);

var Color = function () {
  function Color(caseName, fields) {
    _classCallCheck(this, Color);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Color, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Color",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          HTML: ["string"],
          RGB: ["number", "number", "number"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Color;
}();
setType("TheGamma.Interactive.Compost.Color", Color);
var Width = function () {
  function Width(caseName, fields) {
    _classCallCheck(this, Width);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Width, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Width",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Pixels: ["number"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Width;
}();
setType("TheGamma.Interactive.Compost.Width", Width);
var FillStyle = function () {
  function FillStyle(caseName, fields) {
    _classCallCheck(this, FillStyle);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(FillStyle, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.FillStyle",
        interfaces: ["FSharpUnion", "System.IEquatable"],
        cases: {
          LinearGradient: [Interface("System.Collections.Generic.IEnumerable")],
          Solid: [Tuple(["number", Color])]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }]);

  return FillStyle;
}();
setType("TheGamma.Interactive.Compost.FillStyle", FillStyle);

var _Number = function () {
  function _Number(caseName, fields) {
    _classCallCheck(this, _Number);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(_Number, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Number",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Integer: ["number"],
          Percentage: ["number"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return _Number;
}();

setType("TheGamma.Interactive.Compost.Number", _Number);
var HorizontalAlign = function () {
  function HorizontalAlign(caseName, fields) {
    _classCallCheck(this, HorizontalAlign);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(HorizontalAlign, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.HorizontalAlign",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Center: [],
          End: [],
          Start: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return HorizontalAlign;
}();
setType("TheGamma.Interactive.Compost.HorizontalAlign", HorizontalAlign);
var VerticalAlign = function () {
  function VerticalAlign(caseName, fields) {
    _classCallCheck(this, VerticalAlign);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(VerticalAlign, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.VerticalAlign",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Baseline: [],
          Hanging: [],
          Middle: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return VerticalAlign;
}();
setType("TheGamma.Interactive.Compost.VerticalAlign", VerticalAlign);
var continuous = function () {
  function continuous(caseName, fields) {
    _classCallCheck(this, continuous);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(continuous, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.continuous",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          CO: ["number"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return continuous;
}();
setType("TheGamma.Interactive.Compost.continuous", continuous);
var categorical = function () {
  function categorical(caseName, fields) {
    _classCallCheck(this, categorical);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(categorical, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.categorical",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          CA: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return categorical;
}();
setType("TheGamma.Interactive.Compost.categorical", categorical);
var Value = function () {
  function Value(caseName, fields) {
    _classCallCheck(this, Value);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Value, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Value",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          CAR: [makeGeneric(categorical, {
            u: GenericParam("u")
          }), "number"],
          COV: [makeGeneric(continuous, {
            u: GenericParam("u")
          })]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Value;
}();
setType("TheGamma.Interactive.Compost.Value", Value);
var Scale = function () {
  function Scale(caseName, fields) {
    _classCallCheck(this, Scale);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Scale, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Scale",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Categorical: [FableArray(makeGeneric(categorical, {
            u: GenericParam("v")
          }))],
          Continuous: [makeGeneric(continuous, {
            u: GenericParam("v")
          }), makeGeneric(continuous, {
            u: GenericParam("v")
          })]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Scale;
}();
setType("TheGamma.Interactive.Compost.Scale", Scale);
var Style = function () {
  function Style(strokeColor, strokeWidth, strokeDashArray, fill, animation, font, cursor, formatAxisXLabel, formatAxisYLabel) {
    _classCallCheck(this, Style);

    this.StrokeColor = strokeColor;
    this.StrokeWidth = strokeWidth;
    this.StrokeDashArray = strokeDashArray;
    this.Fill = fill;
    this.Animation = animation;
    this.Font = font;
    this.Cursor = cursor;
    this.FormatAxisXLabel = formatAxisXLabel;
    this.FormatAxisYLabel = formatAxisYLabel;
  }

  _createClass(Style, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Style",
        interfaces: ["FSharpRecord"],
        properties: {
          StrokeColor: Tuple(["number", Color]),
          StrokeWidth: Width,
          StrokeDashArray: Interface("System.Collections.Generic.IEnumerable"),
          Fill: FillStyle,
          Animation: Option(Tuple(["number", "string", "function"])),
          Font: "string",
          Cursor: "string",
          FormatAxisXLabel: "function",
          FormatAxisYLabel: "function"
        }
      };
    }
  }]);

  return Style;
}();
setType("TheGamma.Interactive.Compost.Style", Style);
var EventHandler = function () {
  function EventHandler(caseName, fields) {
    _classCallCheck(this, EventHandler);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(EventHandler, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.EventHandler",
        interfaces: ["FSharpUnion"],
        cases: {
          Click: ["function"],
          MouseDown: ["function"],
          MouseLeave: ["function"],
          MouseMove: ["function"],
          MouseUp: ["function"],
          TouchEnd: ["function"],
          TouchMove: ["function"],
          TouchStart: ["function"]
        }
      };
    }
  }]);

  return EventHandler;
}();
setType("TheGamma.Interactive.Compost.EventHandler", EventHandler);
var Orientation = function () {
  function Orientation(caseName, fields) {
    _classCallCheck(this, Orientation);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Orientation, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Orientation",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Horizontal: [],
          Vertical: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Orientation;
}();
setType("TheGamma.Interactive.Compost.Orientation", Orientation);
var Shape = function () {
  function Shape(caseName, fields) {
    _classCallCheck(this, Shape);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Shape, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.Compost.Shape",
        interfaces: ["FSharpUnion"],
        cases: {
          Area: [Interface("System.Collections.Generic.IEnumerable")],
          AutoScale: ["boolean", "boolean", makeGeneric(Shape, {
            vx: GenericParam("vx"),
            vy: GenericParam("vy")
          })],
          Axes: ["boolean", "boolean", makeGeneric(Shape, {
            vx: GenericParam("vx"),
            vy: GenericParam("vy")
          })],
          Bar: [makeGeneric(continuous, {
            u: GenericParam("vx")
          }), makeGeneric(categorical, {
            u: GenericParam("vy")
          })],
          Bubble: [makeGeneric(Value, {
            u: GenericParam("vx")
          }), makeGeneric(Value, {
            u: GenericParam("vy")
          }), "number", "number"],
          Column: [makeGeneric(categorical, {
            u: GenericParam("vx")
          }), makeGeneric(continuous, {
            u: GenericParam("vy")
          })],
          InnerScale: [Option(Tuple([makeGeneric(continuous, {
            u: GenericParam("vx")
          }), makeGeneric(continuous, {
            u: GenericParam("vx")
          })])), Option(Tuple([makeGeneric(continuous, {
            u: GenericParam("vy")
          }), makeGeneric(continuous, {
            u: GenericParam("vy")
          })])), makeGeneric(Shape, {
            vx: GenericParam("vx"),
            vy: GenericParam("vy")
          })],
          Interactive: [Interface("System.Collections.Generic.IEnumerable"), makeGeneric(Shape, {
            vx: GenericParam("vx"),
            vy: GenericParam("vy")
          })],
          Layered: [Interface("System.Collections.Generic.IEnumerable")],
          Line: [Interface("System.Collections.Generic.IEnumerable")],
          Offset: [Tuple(["number", "number"]), makeGeneric(Shape, {
            vx: GenericParam("vx"),
            vy: GenericParam("vy")
          })],
          OuterScale: [Option(makeGeneric(Scale, {
            v: GenericParam("vx")
          })), Option(makeGeneric(Scale, {
            v: GenericParam("vy")
          })), makeGeneric(Shape, {
            vx: GenericParam("vx"),
            vy: GenericParam("vy")
          })],
          Padding: [Tuple(["number", "number", "number", "number"]), makeGeneric(Shape, {
            vx: GenericParam("vx"),
            vy: GenericParam("vy")
          })],
          Stack: [Orientation, Interface("System.Collections.Generic.IEnumerable")],
          Style: ["function", makeGeneric(Shape, {
            vx: GenericParam("vx"),
            vy: GenericParam("vy")
          })],
          Text: [makeGeneric(Value, {
            u: GenericParam("vx")
          }), makeGeneric(Value, {
            u: GenericParam("vy")
          }), VerticalAlign, HorizontalAlign, "number", "string"]
        }
      };
    }
  }]);

  return Shape;
}();
setType("TheGamma.Interactive.Compost.Shape", Shape);
var Svg = function (__exports) {
  var StringBuilder = __exports.StringBuilder = function () {
    _createClass(StringBuilder, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Svg.StringBuilder",
          properties: {}
        };
      }
    }]);

    function StringBuilder() {
      _classCallCheck(this, StringBuilder);

      this.strs = new List$1();
    }

    _createClass(StringBuilder, [{
      key: "Append",
      value: function (s$$1) {
        this.strs = new List$1(s$$1, this.strs);
      }
    }, {
      key: "ToString",
      value: function () {
        return join("", reverse$1(this.strs));
      }
    }]);

    return StringBuilder;
  }();

  setType("TheGamma.Interactive.Compost.Svg.StringBuilder", StringBuilder);

  var PathSegment = __exports.PathSegment = function () {
    function PathSegment(caseName, fields) {
      _classCallCheck(this, PathSegment);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(PathSegment, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Svg.PathSegment",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            LineTo: [Tuple(["number", "number"])],
            MoveTo: [Tuple(["number", "number"])]
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return PathSegment;
  }();

  setType("TheGamma.Interactive.Compost.Svg.PathSegment", PathSegment);

  var Svg = __exports.Svg = function () {
    function Svg(caseName, fields) {
      _classCallCheck(this, Svg);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(Svg, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Svg.Svg",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            Combine: [FableArray(Svg)],
            Ellipse: [Tuple(["number", "number"]), Tuple(["number", "number"]), "string"],
            Empty: [],
            Path: [FableArray(PathSegment), "string"],
            Rect: [Tuple(["number", "number"]), Tuple(["number", "number"]), "string"],
            Text: [Tuple(["number", "number"]), "string", "number", "string"]
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return Svg;
  }();

  setType("TheGamma.Interactive.Compost.Svg.Svg", Svg);

  var mapSvg = __exports.mapSvg = function (f, _arg1) {
    if (_arg1.Case === "Combine") {
      return new Svg("Combine", [_arg1.Fields[0].map(function (_arg1_1) {
        return mapSvg(f, _arg1_1);
      })]);
    } else {
      return f(_arg1);
    }
  };

  var formatPath = __exports.formatPath = function (path) {
    var sb = new StringBuilder();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(path), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var ps = _step.value;

        if (ps.Case === "LineTo") {
          var y = ps.Fields[0][1];
          var x = ps.Fields[0][0];
          sb.Append("L" + String(x) + " " + String(y) + " ");
        } else {
          var y_1 = ps.Fields[0][1];
          var x_1 = ps.Fields[0][0];
          sb.Append("M" + String(x_1) + " " + String(y_1) + " ");
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return toString$2(sb);
  };

  var RenderingContext = __exports.RenderingContext = function () {
    function RenderingContext(definitions) {
      _classCallCheck(this, RenderingContext);

      this.Definitions = definitions;
    }

    _createClass(RenderingContext, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Svg.RenderingContext",
          interfaces: ["FSharpRecord", "System.IEquatable"],
          properties: {
            Definitions: FableArray(DomNode)
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }]);

    return RenderingContext;
  }();

  setType("TheGamma.Interactive.Compost.Svg.RenderingContext", RenderingContext);

  var renderSvg = __exports.renderSvg = function (ctx, svg) {
    return delay(function () {
      if (svg.Case === "Text") {
        var _ret = function () {
          var y = svg.Fields[0][1];
          var x = svg.Fields[0][0];
          var attrs = toList(delay(function () {
            return append(singleton(op_EqualsGreater("style", svg.Fields[3])), delay(function () {
              return svg.Fields[2] === 0 ? append(singleton(op_EqualsGreater("x", String(x))), delay(function () {
                return singleton(op_EqualsGreater("y", String(y)));
              })) : append(singleton(op_EqualsGreater("x", "0")), delay(function () {
                return append(singleton(op_EqualsGreater("y", "0")), delay(function () {
                  return singleton(op_EqualsGreater("transform", fsFormat("translate(%f,%f) rotate(%f)")(function (x) {
                    return x;
                  })(x)(y)(svg.Fields[2])));
                }));
              }));
            }));
          }));
          return {
            v: singleton(function (arg0) {
              return function (arg1) {
                return El.op_Dynamic(arg0, arg1);
              };
            }(s)("text")(attrs)(ofArray$1([text(svg.Fields[1])])))
          };
        }();

        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
      } else if (svg.Case === "Combine") {
        return collect(function (s$$1) {
          return renderSvg(ctx, s$$1);
        }, svg.Fields[0]);
      } else if (svg.Case === "Ellipse") {
        var ry = svg.Fields[1][1];
        var rx = svg.Fields[1][0];
        var cy = svg.Fields[0][1];
        var cx = svg.Fields[0][0];
        var attrs_1 = ofArray$1([op_EqualsGreater("cx", String(cx)), op_EqualsGreater("cy", String(cy)), op_EqualsGreater("rx", String(rx)), op_EqualsGreater("ry", String(ry)), op_EqualsGreater("style", svg.Fields[2])]);
        return singleton(function (arg0_1) {
          return function (arg1_1) {
            return El.op_Dynamic(arg0_1, arg1_1);
          };
        }(s)("ellipse")(attrs_1)(new List$1()));
      } else if (svg.Case === "Rect") {
        var y2 = svg.Fields[1][1];
        var y1 = svg.Fields[0][1];
        var x2 = svg.Fields[1][0];
        var x1 = svg.Fields[0][0];
        var patternInput = [x1 < x2 ? x1 : x2, y1 < y2 ? y1 : y2];
        var patternInput_1 = [Math.abs(x1 - x2), Math.abs(y1 - y2)];
        var attrs_2 = ofArray$1([op_EqualsGreater("x", String(patternInput[0])), op_EqualsGreater("y", String(patternInput[1])), op_EqualsGreater("width", String(patternInput_1[0])), op_EqualsGreater("height", String(patternInput_1[1])), op_EqualsGreater("style", svg.Fields[2])]);
        return singleton(function (arg0_2) {
          return function (arg1_2) {
            return El.op_Dynamic(arg0_2, arg1_2);
          };
        }(s)("rect")(attrs_2)(new List$1()));
      } else if (svg.Case === "Path") {
        var attrs_3 = ofArray$1([op_EqualsGreater("d", formatPath(svg.Fields[0])), op_EqualsGreater("style", svg.Fields[1])]);
        return singleton(function (arg0_3) {
          return function (arg1_3) {
            return El.op_Dynamic(arg0_3, arg1_3);
          };
        }(s)("path")(attrs_3)(new List$1()));
      } else {
        return empty();
      }
    });
  };

  var formatColor = __exports.formatColor = function (_arg1) {
    if (_arg1.Case === "HTML") {
      return _arg1.Fields[0];
    } else {
      return fsFormat("rgb(%d, %d, %d)")(function (x) {
        return x;
      })(_arg1.Fields[0])(_arg1.Fields[1])(_arg1.Fields[2]);
    }
  };

  var formatNumber = __exports.formatNumber = function (_arg1) {
    if (_arg1.Case === "Percentage") {
      return String(_arg1.Fields[0]) + "%";
    } else {
      return String(_arg1.Fields[0]);
    }
  };

  var formatStyle = __exports.formatStyle = function (defs, style) {
    var patternInput = void 0;

    if (style.Animation == null) {
      patternInput = [style, ""];
    } else {
      (function () {
        var ms = style.Animation[0];
        var ease = style.Animation[1];
        var anim = style.Animation[2];
        var id = "anim_" + replace$$1(function () {
          var copyOfStruct = newGuid();
          return copyOfStruct;
        }(), "-", "");
        var fromstyle = formatStyle(defs, function () {
          var Animation = null;
          return new Style(style.StrokeColor, style.StrokeWidth, style.StrokeDashArray, style.Fill, Animation, style.Font, style.Cursor, style.FormatAxisXLabel, style.FormatAxisYLabel);
        }());
        var tostyle = formatStyle(defs, function () {
          var inputRecord = anim(style);
          var Animation_1 = null;
          return new Style(inputRecord.StrokeColor, inputRecord.StrokeWidth, inputRecord.StrokeDashArray, inputRecord.Fill, Animation_1, inputRecord.Font, inputRecord.Cursor, inputRecord.FormatAxisXLabel, inputRecord.FormatAxisYLabel);
        }());

        (function (arg00) {
          defs.push(arg00);
        })(function (arg0) {
          return function (arg1) {
            return El.op_Dynamic(arg0, arg1);
          };
        }(h$$1)("style")(new List$1())(ofArray$1([text(fsFormat("@keyframes %s { from { %s } to { %s } }")(function (x) {
          return x;
        })(id)(fromstyle)(tostyle))])));

        patternInput = [anim(style), fsFormat("animation: %s %dms %s; ")(function (x) {
          return x;
        })(id)(ms)(ease)];
      })();
    }

    return patternInput[1] + ("cursor:" + patternInput[0].Cursor + ";") + ("font:" + patternInput[0].Font + ";") + fsFormat("stroke-opacity:%f; stroke-width:%dpx; stroke:%s; ")(function (x) {
      return x;
    })(patternInput[0].StrokeColor[0])(patternInput[0].StrokeWidth.Fields[0])(formatColor(patternInput[0].StrokeColor[1])) + (isEmpty(patternInput[0].StrokeDashArray) ? "" : "stroke-dasharray:" + join(",", map$3(function (_arg1) {
      return formatNumber(_arg1);
    }, patternInput[0].StrokeDashArray)) + ";") + (patternInput[0].Fill.Case === "Solid" ? function () {
      var fo = patternInput[0].Fill.Fields[0][0];
      var clr = patternInput[0].Fill.Fields[0][1];
      return fsFormat("fill-opacity:%f; fill:%s; ")(function (x) {
        return x;
      })(fo)(formatColor(clr));
    }() : function () {
      var id_1 = "gradient_" + replace$$1(function () {
        var copyOfStruct_1 = newGuid();
        return copyOfStruct_1;
      }(), "-", "");

      (function (arg00_1) {
        defs.push(arg00_1);
      })(function (arg0_1) {
        return function (arg1_1) {
          return El.op_Dynamic(arg0_1, arg1_1);
        };
      }(s)("linearGradient")(ofArray$1([op_EqualsGreater("id", id_1)]))(toList(delay(function () {
        return collect(function (matchValue) {
          var o = matchValue[1][0];
          var clr_1 = matchValue[1][1];
          return singleton(function (arg0_2) {
            return function (arg1_2) {
              return El.op_Dynamic(arg0_2, arg1_2);
            };
          }(s)("stop")(ofArray$1([op_EqualsGreater("offset", String(matchValue[0]) + "%"), op_EqualsGreater("stop-color", formatColor(clr_1)), op_EqualsGreater("stop-opacity", String(o))]))(new List$1()));
        }, patternInput[0].Fill.Fields[0]);
      }))));

      return fsFormat("fill:url(#%s)")(function (x) {
        return x;
      })(id_1);
    }());
  };

  return __exports;
}({});
var Scales = function (__exports) {
  var ScaledShapeInner = __exports.ScaledShapeInner = function () {
    function ScaledShapeInner(caseName, fields) {
      _classCallCheck(this, ScaledShapeInner);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(ScaledShapeInner, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Scales.ScaledShapeInner",
          interfaces: ["FSharpUnion"],
          cases: {
            ScaledArea: [FableArray(Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })]))],
            ScaledBar: [makeGeneric(continuous, {
              u: GenericParam("vx")
            }), makeGeneric(categorical, {
              u: GenericParam("vy")
            })],
            ScaledBubble: [makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            }), "number", "number"],
            ScaledColumn: [makeGeneric(categorical, {
              u: GenericParam("vx")
            }), makeGeneric(continuous, {
              u: GenericParam("vy")
            })],
            ScaledInteractive: [Interface("System.Collections.Generic.IEnumerable"), makeGeneric(ScaledShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ScaledLayered: [FableArray(makeGeneric(ScaledShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            }))],
            ScaledLine: [FableArray(Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })]))],
            ScaledOffset: [Tuple(["number", "number"]), makeGeneric(ScaledShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ScaledOuterScale: [Option(makeGeneric(Scale, {
              v: GenericParam("vx")
            })), Option(makeGeneric(Scale, {
              v: GenericParam("vy")
            })), makeGeneric(ScaledShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ScaledPadding: [Tuple(["number", "number", "number", "number"]), makeGeneric(ScaledShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ScaledStack: [Orientation, FableArray(makeGeneric(ScaledShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            }))],
            ScaledStyle: ["function", makeGeneric(ScaledShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ScaledText: [makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            }), VerticalAlign, HorizontalAlign, "number", "string"]
          }
        };
      }
    }]);

    return ScaledShapeInner;
  }();

  setType("TheGamma.Interactive.Compost.Scales.ScaledShapeInner", ScaledShapeInner);

  var ScaledShape = __exports.ScaledShape = function () {
    function ScaledShape(caseName, fields) {
      _classCallCheck(this, ScaledShape);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(ScaledShape, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Scales.ScaledShape",
          interfaces: ["FSharpUnion"],
          cases: {
            Scaled: [Tuple([makeGeneric(Scale, {
              v: GenericParam("vx")
            }), makeGeneric(Scale, {
              v: GenericParam("vy")
            })]), Tuple([makeGeneric(Scale, {
              v: GenericParam("vx")
            }), makeGeneric(Scale, {
              v: GenericParam("vy")
            })]), makeGeneric(ScaledShapeInner, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })]
          }
        };
      }
    }]);

    return ScaledShape;
  }();

  setType("TheGamma.Interactive.Compost.Scales.ScaledShape", ScaledShape);

  var getExtremes = __exports.getExtremes = function (_arg1) {
    if (_arg1.Case === "Categorical") {
      return [new Value("CAR", [_arg1.Fields[0][0], 0]), new Value("CAR", [_arg1.Fields[0][_arg1.Fields[0].length - 1], 1])];
    } else {
      return [new Value("COV", [_arg1.Fields[0]]), new Value("COV", [_arg1.Fields[1]])];
    }
  };

  var calculateMagnitudeAndRange = __exports.calculateMagnitudeAndRange = function (lo, hi) {
    var magnitude = Math.pow(10, round(_Math$log(hi - lo)));
    var magnitude_1 = magnitude / 2;
    return [magnitude_1, [Math.floor(lo / magnitude_1) * magnitude_1, Math.ceil(hi / magnitude_1) * magnitude_1]];
  };

  var decimalPoints = __exports.decimalPoints = function (range_0, range_1) {
    var range$$1 = [range_0, range_1];
    var patternInput = calculateMagnitudeAndRange(range$$1[0], range$$1[1]);

    if (0 > -_Math$log(patternInput[0] * 2)) {
      return 0;
    } else {
      return -_Math$log(patternInput[0] * 2);
    }
  };

  var adjustRange = __exports.adjustRange = function (range_0, range_1) {
    var range$$1 = [range_0, range_1];
    return calculateMagnitudeAndRange(range$$1[0], range$$1[1])[1];
  };

  var adjustRangeUnits = __exports.adjustRangeUnits = function (l, h$$2) {
    var patternInput = adjustRange(l, h$$2);
    return [patternInput[0], patternInput[1]];
  };

  var toArray = __exports.toArray = function (s$$1) {
    return _Array$from(s$$1);
  };

  var generateSteps = __exports.generateSteps = function (count$$1, k, lo, hi) {
    var patternInput = calculateMagnitudeAndRange(lo, hi);
    var nlo = patternInput[1][0];
    var nhi = patternInput[1][1];
    var dividers = ofArray$1([0.2, 0.5, 1, 2, 5, 10, 20, 40, 50, 60, 80, 100]);
    var magnitudes = map$3(function (d) {
      return patternInput[0] / d;
    }, dividers);
    var step = tryHead(filter(function (m) {
      return (hi - lo) / m >= count$$1;
    }, magnitudes));
    var step_1 = step != null ? step : patternInput[0] / 100;
    return toArray(delay(function () {
      return collect(function (v) {
        return (v >= lo ? v <= hi : false) ? singleton(v) : empty();
      }, rangeStep(nlo, step_1 * k, nhi));
    }));
  };

  var generateAxisSteps = __exports.generateAxisSteps = function (s$$1) {
    if (s$$1.Case === "Categorical") {
      return _Array$from(delay(function () {
        return collect(function (matchValue) {
          return singleton(new Value("CAR", [new categorical("CA", [matchValue.Fields[0]]), 0.5]));
        }, s$$1.Fields[0]);
      }));
    } else {
      var l = s$$1.Fields[0].Fields[0];
      var h$$2 = s$$1.Fields[1].Fields[0];
      return _Array$from(map$3(function (f) {
        return new Value("COV", [new continuous("CO", [f])]);
      }, generateSteps(6, 1, l, h$$2)));
    }
  };

  var generateAxisLabels = __exports.generateAxisLabels = function (fmt, s$$1) {
    var sunit = s$$1;

    if (s$$1.Case === "Categorical") {
      return _Array$from(delay(function () {
        return collect(function (matchValue) {
          return singleton([new Value("CAR", [new categorical("CA", [matchValue.Fields[0]]), 0.5]), fmt(sunit)(new Value("CAR", [new categorical("CA", [matchValue.Fields[0]]), 0.5]))]);
        }, s$$1.Fields[0]);
      }));
    } else {
      var l = s$$1.Fields[0].Fields[0];
      var h$$2 = s$$1.Fields[1].Fields[0];
      return _Array$from(map$3(function (f) {
        return [new Value("COV", [new continuous("CO", [f])]), fmt(sunit)(new Value("COV", [new continuous("CO", [f])]))];
      }, generateSteps(6, 2, l, h$$2)));
    }
  };

  var unionScales = __exports.unionScales = function (s1, s2) {
    var matchValue = [s1, s2];
    var $var24 = matchValue[0].Case === "Categorical" ? matchValue[1].Case === "Categorical" ? [1, matchValue[0].Fields[0], matchValue[1].Fields[0]] : [2] : matchValue[1].Case === "Continuous" ? [0, matchValue[0].Fields[1], matchValue[1].Fields[1], matchValue[0].Fields[0], matchValue[1].Fields[0]] : [2];

    switch ($var24[0]) {
      case 0:
        return new Scale("Continuous", [$var24[3].CompareTo($var24[4]) < 0 ? $var24[3] : $var24[4], $var24[1].CompareTo($var24[2]) > 0 ? $var24[1] : $var24[2]]);

      case 1:
        return new Scale("Categorical", [_Array$from(distinct($var24[1].concat($var24[2])))]);

      case 2:
        throw new Error("Cannot union continuous with categorical");
    }
  };

  var replaceScales = __exports.replaceScales = function (outer_0, outer_1, _arg1) {
    var outer = [outer_0, outer_1];
    var $var25 = _arg1.Fields[2].Case === "ScaledText" ? [0] : _arg1.Fields[2].Case === "ScaledColumn" ? [0] : _arg1.Fields[2].Case === "ScaledBar" ? [0] : _arg1.Fields[2].Case === "ScaledBubble" ? [0] : _arg1.Fields[2].Case === "ScaledArea" ? [0] : _arg1.Fields[2].Case === "ScaledOuterScale" ? [1] : _arg1.Fields[2].Case === "ScaledOffset" ? [2] : _arg1.Fields[2].Case === "ScaledStyle" ? [3] : _arg1.Fields[2].Case === "ScaledPadding" ? [4] : _arg1.Fields[2].Case === "ScaledInteractive" ? [5] : _arg1.Fields[2].Case === "ScaledLayered" ? [6] : _arg1.Fields[2].Case === "ScaledStack" ? [7] : [0];

    switch ($var25[0]) {
      case 0:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], _arg1.Fields[2]]);

      case 1:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], _arg1.Fields[2]]);

      case 2:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], new ScaledShapeInner("ScaledOffset", [_arg1.Fields[2].Fields[0], replaceScales(outer[0], outer[1], _arg1.Fields[2].Fields[1])])]);

      case 3:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], new ScaledShapeInner("ScaledStyle", [_arg1.Fields[2].Fields[0], replaceScales(outer[0], outer[1], _arg1.Fields[2].Fields[1])])]);

      case 4:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], new ScaledShapeInner("ScaledPadding", [_arg1.Fields[2].Fields[0], replaceScales(outer[0], outer[1], _arg1.Fields[2].Fields[1])])]);

      case 5:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], new ScaledShapeInner("ScaledInteractive", [_arg1.Fields[2].Fields[0], replaceScales(outer[0], outer[1], _arg1.Fields[2].Fields[1])])]);

      case 6:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], new ScaledShapeInner("ScaledLayered", [_arg1.Fields[2].Fields[0].map(function (arg10_) {
          return replaceScales(outer[0], outer[1], arg10_);
        })])]);

      case 7:
        return new ScaledShape("Scaled", [outer, _arg1.Fields[1], new ScaledShapeInner("ScaledStack", [_arg1.Fields[2].Fields[0], _arg1.Fields[2].Fields[1].map(function (arg10__1) {
          return replaceScales(outer[0], outer[1], arg10__1);
        })])]);
    }
  };

  var calculateLineOrAreaScale = __exports.calculateLineOrAreaScale = function (vals) {
    var scales = fold(function (state, value) {
      var matchValue = [state, value];
      var $var26 = matchValue[0].Case === "Choice2Of3" ? matchValue[1].Case === "COV" ? [1, matchValue[1].Fields[0].Fields[0], matchValue[0].Fields[0]] : [4] : matchValue[0].Case === "Choice3Of3" ? matchValue[1].Case === "CAR" ? [3, matchValue[1].Fields[0].Fields[0], matchValue[0].Fields[0]] : [4] : matchValue[1].Case === "CAR" ? [2, matchValue[1].Fields[0].Fields[0]] : [0, matchValue[1].Fields[0].Fields[0]];

      switch ($var26[0]) {
        case 0:
          return new Choice("Choice2Of3", [ofArray$1([$var26[1]])]);

        case 1:
          return new Choice("Choice2Of3", [new List$1($var26[1], $var26[2])]);

        case 2:
          return new Choice("Choice3Of3", [ofArray$1([$var26[1]])]);

        case 3:
          return new Choice("Choice3Of3", [new List$1($var26[1], $var26[2])]);

        case 4:
          throw new Error("Values with mismatching scales");
      }
    }, new Choice("Choice1Of3", [null]), vals);

    if (scales.Case === "Choice2Of3") {
      return new Scale("Continuous", [new continuous("CO", [reduce(function (x, y) {
        return Math.min(x, y);
      }, scales.Fields[0])]), new continuous("CO", [reduce(function (x, y) {
        return Math.max(x, y);
      }, scales.Fields[0])])]);
    } else if (scales.Case === "Choice3Of3") {
      return new Scale("Categorical", [_Array$from(distinct(_Array$from(delay(function () {
        return map$3(function (x) {
          return new categorical("CA", [x]);
        }, reverse$1(scales.Fields[0]));
      }))))]);
    } else {
      throw new Error("No values for calculating a scale");
    }
  };

  var calculateLineOrAreaScales = __exports.calculateLineOrAreaScales = function (line) {
    var xs = line.map(function (tuple) {
      return tuple[0];
    });
    var ys = line.map(function (tuple_1) {
      return tuple_1[1];
    });
    return [calculateLineOrAreaScale(xs), calculateLineOrAreaScale(ys)];
  };

  var calculateScales = __exports.calculateScales = function (style, shape) {
    var calculateScalesStyle = function calculateScalesStyle(style_1) {
      return function (shape_1) {
        return calculateScales(style_1, shape_1);
      };
    };

    var calculateScales_1 = function calculateScales_1(shape_2) {
      return calculateScales(style, shape_2);
    };

    if (shape.Case === "InnerScale") {
      var patternInput = calculateScales_1(shape.Fields[2]);
      var asy = patternInput.Fields[0][1];
      var asx = patternInput.Fields[0][0];
      var scales = [shape.Fields[0] != null ? function (tupledArg) {
        return new Scale("Continuous", [tupledArg[0], tupledArg[1]]);
      }(shape.Fields[0]) : asx, shape.Fields[1] != null ? function (tupledArg_1) {
        return new Scale("Continuous", [tupledArg_1[0], tupledArg_1[1]]);
      }(shape.Fields[1]) : asy];
      return replaceScales(scales[0], scales[1], new ScaledShape("Scaled", [scales, scales, patternInput.Fields[2]]));
    } else if (shape.Case === "AutoScale") {
      var patternInput_1 = calculateScales_1(shape.Fields[2]);
      var asy_1 = patternInput_1.Fields[0][1];
      var asx_1 = patternInput_1.Fields[0][0];

      var autoScale = function autoScale(_arg1) {
        if (_arg1.Case === "Continuous") {
          var l = _arg1.Fields[0].Fields[0];
          var h$$2 = _arg1.Fields[1].Fields[0];
          var patternInput_2 = adjustRangeUnits(l, h$$2);
          return new Scale("Continuous", [new continuous("CO", [patternInput_2[0]]), new continuous("CO", [patternInput_2[1]])]);
        } else {
          return _arg1;
        }
      };

      var scales_1 = [shape.Fields[0] ? autoScale(asx_1) : asx_1, shape.Fields[1] ? autoScale(asy_1) : asy_1];
      return replaceScales(scales_1[0], scales_1[1], new ScaledShape("Scaled", [scales_1, scales_1, patternInput_1.Fields[2]]));
    } else if (shape.Case === "Offset") {
      var patternInput_3 = calculateScales_1(shape.Fields[1]);
      return new ScaledShape("Scaled", [patternInput_3.Fields[0], patternInput_3.Fields[0], new ScaledShapeInner("ScaledOffset", [shape.Fields[0], new ScaledShape("Scaled", [patternInput_3.Fields[0], patternInput_3.Fields[0], patternInput_3.Fields[2]])])]);
    } else if (shape.Case === "Style") {
      var patternInput_4 = calculateScalesStyle(shape.Fields[0](style))(shape.Fields[1]);
      return new ScaledShape("Scaled", [patternInput_4.Fields[0], patternInput_4.Fields[0], new ScaledShapeInner("ScaledStyle", [shape.Fields[0], new ScaledShape("Scaled", [patternInput_4.Fields[0], patternInput_4.Fields[0], patternInput_4.Fields[2]])])]);
    } else if (shape.Case === "Padding") {
      var patternInput_5 = calculateScales_1(shape.Fields[1]);
      return new ScaledShape("Scaled", [patternInput_5.Fields[0], patternInput_5.Fields[0], new ScaledShapeInner("ScaledPadding", [shape.Fields[0], new ScaledShape("Scaled", [patternInput_5.Fields[0], patternInput_5.Fields[0], patternInput_5.Fields[2]])])]);
    } else if (shape.Case === "Bubble") {
      var makeSingletonScale = function makeSingletonScale(_arg2) {
        if (_arg2.Case === "CAR") {
          return new Scale("Categorical", [[_arg2.Fields[0]]]);
        } else {
          return new Scale("Continuous", [_arg2.Fields[0], _arg2.Fields[0]]);
        }
      };

      var scales_2 = [makeSingletonScale(shape.Fields[0]), makeSingletonScale(shape.Fields[1])];
      return new ScaledShape("Scaled", [scales_2, scales_2, new ScaledShapeInner("ScaledBubble", [shape.Fields[0], shape.Fields[1], shape.Fields[2], shape.Fields[3]])]);
    } else if (shape.Case === "Column") {
      var scales_3 = [new Scale("Categorical", [[shape.Fields[0]]]), new Scale("Continuous", [new continuous("CO", [0]), shape.Fields[1]])];
      return new ScaledShape("Scaled", [scales_3, scales_3, new ScaledShapeInner("ScaledColumn", [shape.Fields[0], shape.Fields[1]])]);
    } else if (shape.Case === "Bar") {
      var scales_4 = [new Scale("Continuous", [new continuous("CO", [0]), shape.Fields[0]]), new Scale("Categorical", [[shape.Fields[1]]])];
      return new ScaledShape("Scaled", [scales_4, scales_4, new ScaledShapeInner("ScaledBar", [shape.Fields[0], shape.Fields[1]])]);
    } else if (shape.Case === "Text") {
      var makeSingletonScale_1 = function makeSingletonScale_1(_arg3) {
        if (_arg3.Case === "CAR") {
          return new Scale("Categorical", [[_arg3.Fields[0]]]);
        } else {
          return new Scale("Continuous", [_arg3.Fields[0], _arg3.Fields[0]]);
        }
      };

      var scales_5 = [makeSingletonScale_1(shape.Fields[0]), makeSingletonScale_1(shape.Fields[1])];
      return new ScaledShape("Scaled", [scales_5, scales_5, new ScaledShapeInner("ScaledText", [shape.Fields[0], shape.Fields[1], shape.Fields[2], shape.Fields[3], shape.Fields[4], shape.Fields[5]])]);
    } else if (shape.Case === "Line") {
      var line = _Array$from(shape.Fields[0]);

      var scales_6 = calculateLineOrAreaScales(line);
      return new ScaledShape("Scaled", [scales_6, scales_6, new ScaledShapeInner("ScaledLine", [line])]);
    } else if (shape.Case === "Area") {
      var area = _Array$from(shape.Fields[0]);

      var scales_7 = calculateLineOrAreaScales(area);
      return new ScaledShape("Scaled", [scales_7, scales_7, new ScaledShapeInner("ScaledArea", [area])]);
    } else if (shape.Case === "Axes") {
      var _ret3 = function () {
        var patternInput_6 = calculateScales_1(shape.Fields[2]);
        var sy = patternInput_6.Fields[0][1];
        var sx = patternInput_6.Fields[0][0];
        var patternInput_7 = [getExtremes(sx), getExtremes(sy)];
        var ly = patternInput_7[1][0];
        var lx = patternInput_7[0][0];
        var hy = patternInput_7[1][1];
        var hx = patternInput_7[0][1];

        var LineStyle = function LineStyle(clr) {
          return function (alpha) {
            return function (width) {
              return function (shape_3) {
                return new Shape("Style", [function (s$$1) {
                  var Fill = new FillStyle("Solid", [[1, new Color("HTML", ["transparent"])]]);
                  var StrokeWidth = new Width("Pixels", [width]);
                  return new Style([alpha, new Color("HTML", [clr])], StrokeWidth, s$$1.StrokeDashArray, Fill, s$$1.Animation, s$$1.Font, s$$1.Cursor, s$$1.FormatAxisXLabel, s$$1.FormatAxisYLabel);
                }, shape_3]);
              };
            };
          };
        };

        var FontStyle = function FontStyle(style_2) {
          return function (shape_4) {
            return new Shape("Style", [function (s_1) {
              var Fill_1 = new FillStyle("Solid", [[1, new Color("HTML", ["black"])]]);
              return new Style([0, new Color("HTML", ["transparent"])], s_1.StrokeWidth, s_1.StrokeDashArray, Fill_1, s_1.Animation, style_2, s_1.Cursor, s_1.FormatAxisXLabel, s_1.FormatAxisYLabel);
            }, shape_4]);
          };
        };

        var shape_5 = calculateScales_1(new Shape("Layered", [toList(delay(function () {
          return append(map$3(function (x) {
            return LineStyle("#e4e4e4")(1)(1)(new Shape("Line", [ofArray$1([[x, ly], [x, hy]])]));
          }, generateAxisSteps(sx)), delay(function () {
            return append(map$3(function (y) {
              return LineStyle("#e4e4e4")(1)(1)(new Shape("Line", [ofArray$1([[lx, y], [hx, y]])]));
            }, generateAxisSteps(sy)), delay(function () {
              return append(singleton(LineStyle("black")(1)(2)(new Shape("Line", [ofArray$1([[lx, hy], [lx, ly], [hx, ly]])]))), delay(function () {
                return append(shape.Fields[0] ? collect(function (matchValue) {
                  return singleton(FontStyle("9pt sans-serif")(new Shape("Offset", [[0, 10], new Shape("Text", [matchValue[0], ly, new VerticalAlign("Hanging", []), new HorizontalAlign("Center", []), 0, matchValue[1]])])));
                }, generateAxisLabels(style.FormatAxisXLabel, sx)) : empty(), delay(function () {
                  return append(shape.Fields[1] ? collect(function (matchValue_1) {
                    return singleton(FontStyle("9pt sans-serif")(new Shape("Offset", [[-10, 0], new Shape("Text", [lx, matchValue_1[0], new VerticalAlign("Middle", []), new HorizontalAlign("End", []), 0, matchValue_1[1]])])));
                  }, generateAxisLabels(style.FormatAxisYLabel, sy)) : empty(), delay(function () {
                    return singleton(shape.Fields[2]);
                  }));
                }));
              }));
            }));
          }));
        }))]));

        if (shape_5.Fields[2].Case === "ScaledLayered") {
          var shapes = shape_5.Fields[2].Fields[0];
          var padding = [0, 0, shape.Fields[0] ? 30 : 0, shape.Fields[1] ? 50 : 0];
          return {
            v: new ScaledShape("Scaled", [patternInput_6.Fields[0], patternInput_6.Fields[0], new ScaledShapeInner("ScaledPadding", [padding, new ScaledShape("Scaled", [patternInput_6.Fields[0], patternInput_6.Fields[0], new ScaledShapeInner("ScaledLayered", [shapes.map(function (arg10_) {
              return replaceScales(patternInput_6.Fields[0][0], patternInput_6.Fields[0][1], arg10_);
            })])])])])
          };
        } else {
          throw new Error("calculateScales: processing layered shape did not return layered shape");
        }
      }();

      if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
    } else if (shape.Case === "Stack") {
      var shapes_1 = _Array$from(shape.Fields[1]);

      var scaled = function (array) {
        return array.map(calculateScales_1);
      }(shapes_1);

      var sxs = scaled.map(function (_arg1_1) {
        var sx_1 = _arg1_1.Fields[0][0];
        return sx_1;
      });
      var sys = scaled.map(function (_arg2_1) {
        var sy_1 = _arg2_1.Fields[0][1];
        return sy_1;
      });
      var scales_8 = [sxs.reduce(function (s1, s2) {
        return unionScales(s1, s2);
      }), sys.reduce(function (s1_1, s2_1) {
        return unionScales(s1_1, s2_1);
      })];
      var matchValue_2 = [shape.Fields[0], scales_8];
      var $var27 = matchValue_2[0].Case === "Vertical" ? matchValue_2[1][1].Case === "Continuous" ? [1] : [2] : matchValue_2[1][0].Case === "Continuous" ? [0] : [2];

      switch ($var27[0]) {
        case 0:
          throw new Error("Horizontal stacking of continuous axes is not supported");
          break;

        case 1:
          throw new Error("Vertical stacking of continuous axes is not supported");
          break;

        case 2:
          break;
      }

      return replaceScales(scales_8[0], scales_8[1], new ScaledShape("Scaled", [scales_8, scales_8, new ScaledShapeInner("ScaledStack", [shape.Fields[0], scaled])]));
    } else if (shape.Case === "Layered") {
      var shapes_2 = _Array$from(shape.Fields[0]);

      var scaled_1 = function (array_1) {
        return array_1.map(calculateScales_1);
      }(shapes_2);

      var sxs_1 = scaled_1.map(function (_arg3_1) {
        var sx_2 = _arg3_1.Fields[0][0];
        return sx_2;
      });
      var sys_1 = scaled_1.map(function (_arg4) {
        var sy_2 = _arg4.Fields[0][1];
        return sy_2;
      });
      var scales_9 = [sxs_1.reduce(function (s1_2, s2_2) {
        return unionScales(s1_2, s2_2);
      }), sys_1.reduce(function (s1_3, s2_3) {
        return unionScales(s1_3, s2_3);
      })];
      return replaceScales(scales_9[0], scales_9[1], new ScaledShape("Scaled", [scales_9, scales_9, new ScaledShapeInner("ScaledLayered", [scaled_1])]));
    } else if (shape.Case === "Interactive") {
      var patternInput_8 = calculateScales_1(shape.Fields[1]);
      return new ScaledShape("Scaled", [patternInput_8.Fields[0], patternInput_8.Fields[0], new ScaledShapeInner("ScaledInteractive", [shape.Fields[0], new ScaledShape("Scaled", [patternInput_8.Fields[0], patternInput_8.Fields[0], patternInput_8.Fields[2]])])]);
    } else {
      var scaled_2 = calculateScales_1(shape.Fields[2]);
      var osy = scaled_2.Fields[0][1];
      var osx = scaled_2.Fields[0][0];
      var scales_10 = [defaultArg(shape.Fields[0], osx), defaultArg(shape.Fields[1], osy)];
      return new ScaledShape("Scaled", [scales_10, scaled_2.Fields[1], new ScaledShapeInner("ScaledOuterScale", [shape.Fields[0], shape.Fields[1], scaled_2])]);
    }
  };

  return __exports;
}({});
var Projections = function (__exports) {
  var Projection = __exports.Projection = function () {
    function Projection(caseName, fields) {
      _classCallCheck(this, Projection);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(Projection, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Projections.Projection",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            Padding: [Tuple(["number", "number", "number", "number"]), Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })]), makeGeneric(Projection, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy"),
              ux: GenericParam("ux"),
              uy: GenericParam("uy")
            })],
            Rescale: [Tuple(["number", "number"]), Tuple(["number", "number"]), makeGeneric(Projection, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy"),
              ux: GenericParam("ux"),
              uy: GenericParam("uy")
            })],
            Scale: [Tuple(["number", "number"]), Tuple(["number", "number"])]
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return Projection;
  }();

  setType("TheGamma.Interactive.Compost.Projections.Projection", Projection);

  var ProjectedShapeInner = __exports.ProjectedShapeInner = function () {
    function ProjectedShapeInner(caseName, fields) {
      _classCallCheck(this, ProjectedShapeInner);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(ProjectedShapeInner, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Projections.ProjectedShapeInner",
          interfaces: ["FSharpUnion"],
          cases: {
            ProjectedArea: [FableArray(Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })]))],
            ProjectedBar: [makeGeneric(continuous, {
              u: GenericParam("vx")
            }), makeGeneric(categorical, {
              u: GenericParam("vy")
            })],
            ProjectedBubble: [makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            }), "number", "number"],
            ProjectedColumn: [makeGeneric(categorical, {
              u: GenericParam("vx")
            }), makeGeneric(continuous, {
              u: GenericParam("vy")
            })],
            ProjectedInteractive: [Interface("System.Collections.Generic.IEnumerable"), makeGeneric(ProjectedShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ProjectedLayered: [FableArray(makeGeneric(ProjectedShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            }))],
            ProjectedLine: [FableArray(Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })]))],
            ProjectedOffset: [Tuple(["number", "number"]), makeGeneric(ProjectedShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ProjectedStack: [Orientation, FableArray(makeGeneric(ProjectedShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            }))],
            ProjectedStyle: ["function", makeGeneric(ProjectedShape, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })],
            ProjectedText: [makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            }), VerticalAlign, HorizontalAlign, "number", "string"]
          }
        };
      }
    }]);

    return ProjectedShapeInner;
  }();

  setType("TheGamma.Interactive.Compost.Projections.ProjectedShapeInner", ProjectedShapeInner);

  var ProjectedShape = __exports.ProjectedShape = function () {
    function ProjectedShape(caseName, fields) {
      _classCallCheck(this, ProjectedShape);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(ProjectedShape, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Projections.ProjectedShape",
          interfaces: ["FSharpUnion"],
          cases: {
            Projected: [makeGeneric(Projection, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy"),
              ux: Any,
              uy: Any
            }), Tuple([makeGeneric(Scale, {
              v: GenericParam("vx")
            }), makeGeneric(Scale, {
              v: GenericParam("vy")
            })]), makeGeneric(ProjectedShapeInner, {
              vx: GenericParam("vx"),
              vy: GenericParam("vy")
            })]
          }
        };
      }
    }]);

    return ProjectedShape;
  }();

  setType("TheGamma.Interactive.Compost.Projections.ProjectedShape", ProjectedShape);

  var scaleOne = __exports.scaleOne = function (tlv, thv, scale, coord) {
    var matchValue = [scale, coord];

    if (matchValue[0].Case === "Continuous") {
      if (matchValue[1].Case === "CAR") {
        throw new Error("Cannot project categorical value on a continuous scale.");
      } else {
        return new continuous("CO", [(matchValue[1].Fields[0].Fields[0] - matchValue[0].Fields[0].Fields[0]) / (matchValue[0].Fields[1].Fields[0] - matchValue[0].Fields[0].Fields[0]) * (thv - tlv) + tlv]);
      }
    } else if (matchValue[1].Case === "COV") {
      throw new Error("Cannot project continuous value on a categorical scale.");
    } else {
      var size = (thv - tlv) / matchValue[0].Fields[0].length;
      var i = matchValue[0].Fields[0].findIndex(function (_arg1) {
        return matchValue[1].Fields[0].Fields[0] === _arg1.Fields[0];
      });
      var i_1 = i + matchValue[1].Fields[1];
      return new continuous("CO", [tlv + i_1 * size]);
    }
  };

  var project = __exports.project = function (sx, sy, point_0, point_1, projection) {
    var point = [point_0, point_1];
    var matchValue = [projection, point];

    if (matchValue[0].Case === "Rescale") {
      var rly = matchValue[0].Fields[1][0];
      var rlx = matchValue[0].Fields[0][0];
      var rhy = matchValue[0].Fields[1][1];
      var rhx = matchValue[0].Fields[0][1];
      var proj = matchValue[0].Fields[2];
      var patternInput = [Scales.getExtremes(sx), Scales.getExtremes(sy)];
      var ly = patternInput[1][0];
      var lx = patternInput[0][0];
      var hy = patternInput[1][1];
      var hx = patternInput[0][1];
      var patternInput_1 = [project(sx, sy, lx, ly, proj), project(sx, sy, hx, hy, proj)];
      var y2 = patternInput_1[1][1].Fields[0];
      var y1 = patternInput_1[0][1].Fields[0];
      var x2 = patternInput_1[1][0].Fields[0];
      var x1 = patternInput_1[0][0].Fields[0];
      var patternInput_2 = [x1 < x2 ? x1 : x2, x1 > x2 ? x1 : x2, y1 < y2 ? y1 : y2, y1 > y2 ? y1 : y2];
      var patternInput_3 = project(sx, sy, matchValue[1][0], matchValue[1][1], proj);
      var y = patternInput_3[1].Fields[0];
      var x = patternInput_3[0].Fields[0];
      var nx = patternInput_2[0] === patternInput_2[1] ? x : patternInput_2[0] + (patternInput_2[1] - patternInput_2[0]) * ((x - patternInput_2[0]) / (patternInput_2[1] - patternInput_2[0]) * (rhx - rlx) + rlx);
      var ny = patternInput_2[2] === patternInput_2[3] ? y : patternInput_2[2] + (patternInput_2[3] - patternInput_2[2]) * ((y - patternInput_2[2]) / (patternInput_2[3] - patternInput_2[2]) * (rhy - rly) + rly);
      return [new continuous("CO", [nx]), new continuous("CO", [ny])];
    } else if (matchValue[0].Case === "Padding") {
      var t = matchValue[0].Fields[0][0];
      var r = matchValue[0].Fields[0][1];
      var projection_1 = matchValue[0].Fields[2];
      var ly_1 = matchValue[0].Fields[1][2];
      var lx_1 = matchValue[0].Fields[1][0];
      var l = matchValue[0].Fields[0][3];
      var hy_1 = matchValue[0].Fields[1][3];
      var hx_1 = matchValue[0].Fields[1][1];
      var b = matchValue[0].Fields[0][2];
      var patternInput_4 = project(sx, sy, lx_1, ly_1, projection_1);
      var y1_1 = patternInput_4[1].Fields[0];
      var x1_1 = patternInput_4[0].Fields[0];
      var patternInput_5 = project(sx, sy, hx_1, hy_1, projection_1);
      var y2_1 = patternInput_5[1].Fields[0];
      var x2_1 = patternInput_5[0].Fields[0];
      var patternInput_6 = [x1_1 < x2_1 ? x1_1 : x2_1, x1_1 > x2_1 ? x1_1 : x2_1, y1_1 < y2_1 ? y1_1 : y2_1, y1_1 > y2_1 ? y1_1 : y2_1];
      var patternInput_7 = project(sx, sy, point[0], point[1], projection_1);
      var y_1 = patternInput_7[1].Fields[0];
      var x_1 = patternInput_7[0].Fields[0];
      var nx_1 = patternInput_6[0] === patternInput_6[1] ? x_1 : patternInput_6[0] + l + (patternInput_6[1] - patternInput_6[0] - l - r) / (patternInput_6[1] - patternInput_6[0]) * (x_1 - patternInput_6[0]);
      var ny_1 = patternInput_6[2] === patternInput_6[3] ? y_1 : patternInput_6[2] + t + (patternInput_6[3] - patternInput_6[2] - t - b) / (patternInput_6[3] - patternInput_6[2]) * (y_1 - patternInput_6[2]);
      return [new continuous("CO", [nx_1]), new continuous("CO", [ny_1])];
    } else {
      var y_2 = matchValue[1][1];
      var x_2 = matchValue[1][0];
      var ty = matchValue[0].Fields[1];
      var tx = matchValue[0].Fields[0];
      return [scaleOne(tx[0], tx[1], sx, x_2), scaleOne(ty[0], ty[1], sy, y_2)];
    }
  };

  var scaleOneInv = __exports.scaleOneInv = function (tlv, thv, scale, coord) {
    var matchValue = [scale, coord];

    if (matchValue[0].Case === "Categorical") {
      var v = matchValue[1].Fields[0];
      var cats = matchValue[0].Fields[0];
      var size = (thv - tlv) / cats.length;
      var i = Math.floor(v / size);
      var f = v / size - i;
      var i_1 = size < 0 ? cats.length + i : i;

      if (~~i_1 < 0 ? true : ~~i_1 >= cats.length) {
        return new Value("CAR", [new categorical("CA", ["<outside-of-range>"]), f]);
      } else {
        return new Value("CAR", [cats[~~i_1], f]);
      }
    } else {
      var v_1 = matchValue[1].Fields[0];
      var slv = matchValue[0].Fields[0].Fields[0];
      var shv = matchValue[0].Fields[1].Fields[0];
      return new Value("COV", [new continuous("CO", [(v_1 - tlv) / (thv - tlv) * (shv - slv) + slv])]);
    }
  };

  var invertProj = __exports.invertProj = function (proj) {
    var $var28 = proj.Case === "Rescale" ? proj.Fields[2].Case === "Padding" ? [0, proj.Fields[2].Fields[1], proj.Fields[2].Fields[0], proj.Fields[2].Fields[2], proj.Fields[0], proj.Fields[1]] : [2] : proj.Case === "Padding" ? proj.Fields[2].Case === "Rescale" ? [1, proj.Fields[1], proj.Fields[0], proj.Fields[2].Fields[2], proj.Fields[2].Fields[0], proj.Fields[2].Fields[1]] : [2] : [2];

    switch ($var28[0]) {
      case 0:
        return new Projection("Padding", [$var28[2], $var28[1], new Projection("Rescale", [$var28[4], $var28[5], $var28[3]])]);

      case 1:
        return new Projection("Rescale", [$var28[4], $var28[5], new Projection("Padding", [$var28[2], $var28[1], $var28[3]])]);

      case 2:
        return proj;
    }
  };

  var projectInv = __exports.projectInv = function (_arg1_0, _arg1_1, point_0, point_1, projection) {
    projectInv: while (true) {
      var _arg1 = [_arg1_0, _arg1_1];
      var point = [point_0, point_1];
      var matchValue = [projection, point];

      if (matchValue[0].Case === "Padding") {
        var y = matchValue[1][1].Fields[0];
        var x = matchValue[1][0].Fields[0];
        var t = matchValue[0].Fields[0][0];
        var r = matchValue[0].Fields[0][1];
        var projection_1 = matchValue[0].Fields[2];
        var ly = matchValue[0].Fields[1][2];
        var lx = matchValue[0].Fields[1][0];
        var l = matchValue[0].Fields[0][3];
        var hy = matchValue[0].Fields[1][3];
        var hx = matchValue[0].Fields[1][1];
        var b = matchValue[0].Fields[0][2];
        var patternInput = project(_arg1[0], _arg1[1], lx, ly, projection_1);
        var y1 = patternInput[1].Fields[0];
        var x1 = patternInput[0].Fields[0];
        var patternInput_1 = project(_arg1[0], _arg1[1], hx, hy, projection_1);
        var y2 = patternInput_1[1].Fields[0];
        var x2 = patternInput_1[0].Fields[0];
        var patternInput_2 = [x1 < x2 ? x1 : x2, x1 > x2 ? x1 : x2, y1 < y2 ? y1 : y2, y1 > y2 ? y1 : y2];
        var oy = point[1].Fields[0];
        var ox = point[0].Fields[0];
        var nx = (ox - patternInput_2[0] - l) / (patternInput_2[1] - patternInput_2[0] - l - r) * (patternInput_2[1] - patternInput_2[0]) + patternInput_2[0];
        var ny = (oy - patternInput_2[2] - t) / (patternInput_2[3] - patternInput_2[2] - t - b) * (patternInput_2[3] - patternInput_2[2]) + patternInput_2[2];
        _arg1_0 = _arg1[0];
        _arg1_1 = _arg1[1];
        point_0 = new continuous("CO", [nx]);
        point_1 = new continuous("CO", [ny]);
        projection = projection_1;
        continue projectInv;
      } else if (matchValue[0].Case === "Scale") {
        var y_1 = matchValue[1][1];
        var x_1 = matchValue[1][0];
        var ty = matchValue[0].Fields[1];
        var tx = matchValue[0].Fields[0];
        return [scaleOneInv(tx[0], tx[1], _arg1[0], x_1), scaleOneInv(ty[0], ty[1], _arg1[1], y_1)];
      } else {
        var y_2 = matchValue[1][1].Fields[0];
        var x_2 = matchValue[1][0].Fields[0];
        var rly = matchValue[0].Fields[1][0];
        var rlx = matchValue[0].Fields[0][0];
        var rhy = matchValue[0].Fields[1][1];
        var rhx = matchValue[0].Fields[0][1];
        var projection_2 = matchValue[0].Fields[2];
        var patternInput_3 = [Scales.getExtremes(_arg1[0]), Scales.getExtremes(_arg1[1])];
        var ly_1 = patternInput_3[1][0];
        var lx_1 = patternInput_3[0][0];
        var hy_1 = patternInput_3[1][1];
        var hx_1 = patternInput_3[0][1];
        var patternInput_4 = [project(_arg1[0], _arg1[1], lx_1, ly_1, projection_2), project(_arg1[0], _arg1[1], hx_1, hy_1, projection_2)];
        var y2_1 = patternInput_4[1][1].Fields[0];
        var y1_1 = patternInput_4[0][1].Fields[0];
        var x2_1 = patternInput_4[1][0].Fields[0];
        var x1_1 = patternInput_4[0][0].Fields[0];
        var patternInput_5 = [x1_1 < x2_1 ? x1_1 : x2_1, x1_1 > x2_1 ? x1_1 : x2_1, y1_1 < y2_1 ? y1_1 : y2_1, y1_1 > y2_1 ? y1_1 : y2_1];
        var oy_1 = point[1].Fields[0];
        var ox_1 = point[0].Fields[0];
        var nx_1 = patternInput_5[0] + ((ox_1 - patternInput_5[0]) / (patternInput_5[1] - patternInput_5[0]) - rlx) / (rhx - rlx) * (patternInput_5[1] - patternInput_5[0]);
        var ny_1 = patternInput_5[2] + ((oy_1 - patternInput_5[2]) / (patternInput_5[3] - patternInput_5[2]) - rly) / (rhy - rly) * (patternInput_5[3] - patternInput_5[2]);
        _arg1_0 = _arg1[0];
        _arg1_1 = _arg1[1];
        point_0 = new continuous("CO", [nx_1]);
        point_1 = new continuous("CO", [ny_1]);
        projection = projection_2;
        continue projectInv;
      }
    }
  };

  var calculateProjections = __exports.calculateProjections = function (shape, projection) {
    calculateProjections: while (true) {
      if (shape.Fields[2].Case === "ScaledStyle") {
        var style = shape.Fields[2].Fields[0];
        var shape_1 = shape.Fields[2].Fields[1];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedStyle", [style, calculateProjections(shape_1, projection)])]);
      } else if (shape.Fields[2].Case === "ScaledOuterScale") {
        var sy = shape.Fields[0][1];
        var sx = shape.Fields[0][0];
        var shape_2 = shape.Fields[2].Fields[2];
        var osy = shape.Fields[2].Fields[1];
        var osx = shape.Fields[2].Fields[0];

        var adaptProjection = function adaptProjection(os) {
          return function (s$$1) {
            if (os != null) {
              var patternInput = Scales.getExtremes(s$$1);
              var patternInput_1 = [scaleOne(0, 1, s$$1, patternInput[0]), scaleOne(0, 1, s$$1, patternInput[1])];
              var patternInput_2 = Scales.getExtremes(os);
              var patternInput_3 = [scaleOne(0, 1, s$$1, patternInput_2[0]), scaleOne(0, 1, s$$1, patternInput_2[1])];
              var lo_ = patternInput_3[0].Fields[0];
              var ho_ = patternInput_3[1].Fields[0];
              return [lo_, ho_];
            } else {
              return [0, 1];
            }
          };
        };

        var px = adaptProjection(osx)(sx);
        var py = adaptProjection(osy)(sy);
        var projection_1 = new Projection("Rescale", [px, py, projection]);
        var patternInput_4 = calculateProjections(shape_2, projection_1);
        return new ProjectedShape("Projected", [patternInput_4.Fields[0], patternInput_4.Fields[1], patternInput_4.Fields[2]]);
      } else if (shape.Fields[2].Case === "ScaledLine") {
        var line = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedLine", [line])]);
      } else if (shape.Fields[2].Case === "ScaledBar") {
        var y = shape.Fields[2].Fields[1];
        var x = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedBar", [x, y])]);
      } else if (shape.Fields[2].Case === "ScaledColumn") {
        var y_1 = shape.Fields[2].Fields[1];
        var x_1 = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedColumn", [x_1, y_1])]);
      } else if (shape.Fields[2].Case === "ScaledText") {
        var y_2 = shape.Fields[2].Fields[1];
        var x_2 = shape.Fields[2].Fields[0];
        var va = shape.Fields[2].Fields[2];
        var t = shape.Fields[2].Fields[5];
        var r = shape.Fields[2].Fields[4];
        var ha = shape.Fields[2].Fields[3];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedText", [x_2, y_2, va, ha, r, t])]);
      } else if (shape.Fields[2].Case === "ScaledBubble") {
        var y_3 = shape.Fields[2].Fields[1];
        var x_3 = shape.Fields[2].Fields[0];
        var ry = shape.Fields[2].Fields[3];
        var rx = shape.Fields[2].Fields[2];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedBubble", [x_3, y_3, rx, ry])]);
      } else if (shape.Fields[2].Case === "ScaledArea") {
        var area = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedArea", [area])]);
      } else if (shape.Fields[2].Case === "ScaledPadding") {
        var t_1 = shape.Fields[2].Fields[0][0];
        var shape_3 = shape.Fields[2].Fields[1];
        var r_1 = shape.Fields[2].Fields[0][1];
        var l = shape.Fields[2].Fields[0][3];
        var b = shape.Fields[2].Fields[0][2];
        var patternInput_5 = void 0;
        var syinner = shape_3.Fields[1][1];
        var sxinner = shape_3.Fields[1][0];
        patternInput_5 = [Scales.getExtremes(sxinner), Scales.getExtremes(syinner)];
        var ly = patternInput_5[1][0];
        var lx = patternInput_5[0][0];
        var hy = patternInput_5[1][1];
        var hx = patternInput_5[0][1];
        var ppad = new Projection("Padding", [[t_1, r_1, b, l], [lx, hx, ly, hy], projection]);
        shape = shape_3;
        projection = ppad;
        continue calculateProjections;
      } else if (shape.Fields[2].Case === "ScaledStack") {
        var shapes = shape.Fields[2].Fields[1];
        var orient = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedStack", [orient, shapes.map(function (s_1) {
          return calculateProjections(s_1, projection);
        })])]);
      } else if (shape.Fields[2].Case === "ScaledLayered") {
        var shapes_1 = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedLayered", [shapes_1.map(function (s_2) {
          return calculateProjections(s_2, projection);
        })])]);
      } else if (shape.Fields[2].Case === "ScaledInteractive") {
        var shape_4 = shape.Fields[2].Fields[1];
        var f = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedInteractive", [f, calculateProjections(shape_4, projection)])]);
      } else {
        var shape_5 = shape.Fields[2].Fields[1];
        var offs = shape.Fields[2].Fields[0];
        return new ProjectedShape("Projected", [projection, shape.Fields[0], new ProjectedShapeInner("ProjectedOffset", [offs, calculateProjections(shape_5, projection)])]);
      }
    }
  };

  return __exports;
}({});
var Drawing = function (__exports) {
  var DrawingContext = __exports.DrawingContext = function () {
    function DrawingContext(style, definitions) {
      _classCallCheck(this, DrawingContext);

      this.Style = style;
      this.Definitions = definitions;
    }

    _createClass(DrawingContext, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Drawing.DrawingContext",
          interfaces: ["FSharpRecord"],
          properties: {
            Style: Style,
            Definitions: FableArray(DomNode)
          }
        };
      }
    }]);

    return DrawingContext;
  }();

  setType("TheGamma.Interactive.Compost.Drawing.DrawingContext", DrawingContext);

  var hideFill = __exports.hideFill = function (style) {
    var Fill = new FillStyle("Solid", [[0, new Color("RGB", [0, 0, 0])]]);
    var Animation = void 0;

    if (style.Animation != null) {
      var n = style.Animation[0];
      var f = style.Animation[2];
      var e = style.Animation[1];
      Animation = [n, e, function ($var29) {
        return function (style_1) {
          return hideFill(style_1);
        }(f($var29));
      }];
    } else {
      Animation = null;
    }

    return new Style(style.StrokeColor, style.StrokeWidth, style.StrokeDashArray, Fill, Animation, style.Font, style.Cursor, style.FormatAxisXLabel, style.FormatAxisYLabel);
  };

  var hideStroke = __exports.hideStroke = function (style) {
    var StrokeColor = [0, style.StrokeColor[1]];
    var Animation = void 0;

    if (style.Animation != null) {
      var n = style.Animation[0];
      var f = style.Animation[2];
      var e = style.Animation[1];
      Animation = [n, e, function ($var30) {
        return function (style_1) {
          return hideStroke(style_1);
        }(f($var30));
      }];
    } else {
      Animation = null;
    }

    return new Style(StrokeColor, style.StrokeWidth, style.StrokeDashArray, style.Fill, Animation, style.Font, style.Cursor, style.FormatAxisXLabel, style.FormatAxisYLabel);
  };

  var drawShape = __exports.drawShape = function (ctx, shape) {
    var _loop = function _loop() {
      var sy = shape.Fields[1][1];
      var sx = shape.Fields[1][0];

      var projectCont = function projectCont(tupledArg) {
        var matchValue = Projections.project(sx, sy, tupledArg[0], tupledArg[1], shape.Fields[0]);
        var y = matchValue[1].Fields[0];
        var x = matchValue[0].Fields[0];
        return [x, y];
      };

      var projectContCov = function projectContCov(tupledArg_1) {
        return projectCont([new Value("COV", [tupledArg_1[0]]), new Value("COV", [tupledArg_1[1]])]);
      };

      var matchValue_1 = [shape.Fields[2], [sx, sy]];
      var $var31 = matchValue_1[0].Case === "ProjectedStyle" ? [1, matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : matchValue_1[0].Case === "ProjectedText" ? [2, matchValue_1[0].Fields[3], matchValue_1[0].Fields[4], matchValue_1[0].Fields[5], matchValue_1[0].Fields[2], matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : matchValue_1[0].Case === "ProjectedBubble" ? [3, matchValue_1[0].Fields[2], matchValue_1[0].Fields[3], matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : matchValue_1[0].Case === "ProjectedLine" ? [4, matchValue_1[0].Fields[0]] : matchValue_1[0].Case === "ProjectedColumn" ? matchValue_1[1][0].Case === "Categorical" ? matchValue_1[1][1].Case === "Continuous" ? [6, matchValue_1[1][1].Fields[1], matchValue_1[1][1].Fields[0], matchValue_1[1][0].Fields[0], matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : [5, matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : [5, matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : matchValue_1[0].Case === "ProjectedBar" ? matchValue_1[1][1].Case === "Categorical" ? matchValue_1[1][0].Case === "Continuous" ? [8, matchValue_1[1][0].Fields[1], matchValue_1[1][0].Fields[0], matchValue_1[1][1].Fields[0], matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : [7, matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : [7, matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : matchValue_1[0].Case === "ProjectedArea" ? matchValue_1[1][0].Case === "Continuous" ? matchValue_1[1][1].Case === "Continuous" ? [10, matchValue_1[1][0].Fields[1], matchValue_1[1][1].Fields[1], matchValue_1[0].Fields[0], matchValue_1[1][0].Fields[0], matchValue_1[1][1].Fields[0]] : [9, matchValue_1[0].Fields[0]] : [9, matchValue_1[0].Fields[0]] : matchValue_1[0].Case === "ProjectedLayered" ? [11, matchValue_1[0].Fields[0]] : matchValue_1[0].Case === "ProjectedStack" ? [12, matchValue_1[0].Fields[1]] : matchValue_1[0].Case === "ProjectedInteractive" ? [13, matchValue_1[0].Fields[0], matchValue_1[0].Fields[1]] : [0, matchValue_1[0].Fields[0][0], matchValue_1[0].Fields[0][1], matchValue_1[0].Fields[1]];

      var _ret5 = function () {
        switch ($var31[0]) {
          case 0:
            return {
              v: {
                v: Svg.mapSvg(function (_arg1) {
                  if (_arg1.Case === "Text") {
                    var y_1 = _arg1.Fields[0][1];
                    var x_1 = _arg1.Fields[0][0];
                    return new Svg.Svg("Text", [[x_1 + $var31[1], y_1 + $var31[2]], _arg1.Fields[1], _arg1.Fields[2], _arg1.Fields[3]]);
                  } else if (_arg1.Case === "Path") {
                    return new Svg.Svg("Path", [_arg1.Fields[0].map(function (_arg2) {
                      if (_arg2.Case === "LineTo") {
                        var y_2 = _arg2.Fields[0][1];
                        var x_2 = _arg2.Fields[0][0];
                        return new Svg.PathSegment("LineTo", [[x_2 + $var31[1], y_2 + $var31[2]]]);
                      } else {
                        var y_3 = _arg2.Fields[0][1];
                        var x_3 = _arg2.Fields[0][0];
                        return new Svg.PathSegment("MoveTo", [[x_3 + $var31[1], y_3 + $var31[2]]]);
                      }
                    }), _arg1.Fields[1]]);
                  } else {
                    return _arg1;
                  }
                }, drawShape(ctx, $var31[3]))
              }
            };

          case 1:
            ctx = new DrawingContext($var31[1](ctx.Style), ctx.Definitions);
            shape = $var31[2];
            return {
              v: "continue|drawShape"
            };

          case 2:
            var va = $var31[4].Case === "Hanging" ? "hanging" : $var31[4].Case === "Middle" ? "middle" : "baseline";
            var ha = $var31[1].Case === "Center" ? "middle" : $var31[1].Case === "End" ? "end" : "start";
            var xy = projectCont([$var31[5], $var31[6]]);
            return {
              v: {
                v: new Svg.Svg("Text", [xy, $var31[3], $var31[2], fsFormat("alignment-baseline:%s; text-anchor:%s;")(function (x) {
                  return x;
                })(va)(ha) + Svg.formatStyle(ctx.Definitions, ctx.Style)])
              }
            };

          case 3:
            return {
              v: {
                v: new Svg.Svg("Ellipse", [projectCont([$var31[3], $var31[4]]), [$var31[1], $var31[2]], Svg.formatStyle(ctx.Definitions, ctx.Style)])
              }
            };

          case 4:
            var path = _Array$from(toList(delay(function () {
              return append(singleton(new Svg.PathSegment("MoveTo", [projectCont(head($var31[1]))])), delay(function () {
                return map$3(function (pt) {
                  return new Svg.PathSegment("LineTo", [projectCont(pt)]);
                }, skip(1, $var31[1]));
              }));
            })));

            return {
              v: {
                v: new Svg.Svg("Path", [path, Svg.formatStyle(ctx.Definitions, hideFill(ctx.Style))])
              }
            };

          case 5:
            throw new Error("Column can be drawn only on matching scales");

          case 6:
            var path_1 = [new Svg.PathSegment("MoveTo", [projectCont([new Value("CAR", [$var31[4], 0]), new Value("COV", [$var31[5]])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("CAR", [$var31[4], 1]), new Value("COV", [$var31[5]])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("CAR", [$var31[4], 1]), new Value("COV", [$var31[2]])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("CAR", [$var31[4], 0]), new Value("COV", [$var31[2]])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("CAR", [$var31[4], 0]), new Value("COV", [$var31[5]])])])];
            return {
              v: {
                v: new Svg.Svg("Path", [path_1, Svg.formatStyle(ctx.Definitions, hideStroke(ctx.Style))])
              }
            };

          case 7:
            throw new Error("Bar can be drawn only on matching scales");

          case 8:
            var path_2 = [new Svg.PathSegment("MoveTo", [projectCont([new Value("COV", [$var31[4]]), new Value("CAR", [$var31[5], 0])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("COV", [$var31[4]]), new Value("CAR", [$var31[5], 1])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("COV", [$var31[2]]), new Value("CAR", [$var31[5], 1])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("COV", [$var31[2]]), new Value("CAR", [$var31[5], 0])])]), new Svg.PathSegment("LineTo", [projectCont([new Value("COV", [$var31[4]]), new Value("CAR", [$var31[5], 0])])])];
            return {
              v: {
                v: new Svg.Svg("Path", [path_2, Svg.formatStyle(ctx.Definitions, hideStroke(ctx.Style))])
              }
            };

          case 9:
            throw new Error("Area can be drawn only on continuous scale");

          case 10:
            var patternInput = [head($var31[3])[0], last($var31[3])[0]];

            var path_3 = _Array$from(toList(delay(function () {
              return append(singleton(new Svg.PathSegment("MoveTo", [projectCont([patternInput[0], new Value("COV", [$var31[5]])])])), delay(function () {
                return append(map$3(function (pt_1) {
                  return new Svg.PathSegment("LineTo", [projectCont(pt_1)]);
                }, $var31[3]), delay(function () {
                  return append(singleton(new Svg.PathSegment("LineTo", [projectCont([patternInput[1], new Value("COV", [$var31[5]])])])), delay(function () {
                    return singleton(new Svg.PathSegment("LineTo", [projectCont([patternInput[0], new Value("COV", [$var31[5]])])]));
                  }));
                }));
              }));
            })));

            return {
              v: {
                v: new Svg.Svg("Path", [path_3, Svg.formatStyle(ctx.Definitions, hideStroke(ctx.Style))])
              }
            };

          case 11:
            return {
              v: {
                v: new Svg.Svg("Combine", [$var31[1].map(function (s$$1) {
                  return drawShape(ctx, s$$1);
                })])
              }
            };

          case 12:
            return {
              v: {
                v: new Svg.Svg("Combine", [$var31[1].map(function (s_1) {
                  return drawShape(ctx, s_1);
                })])
              }
            };

          case 13:
            ctx = ctx;
            shape = $var31[2];
            return {
              v: "continue|drawShape"
            };
        }
      }();

      if ((typeof _ret5 === "undefined" ? "undefined" : _typeof(_ret5)) === "object") return _ret5.v;
    };

    drawShape: while (true) {
      var _ret4 = _loop();

      switch (_ret4) {
        case "continue|drawShape":
          continue drawShape;

        default:
          if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
      }
    }
  };

  return __exports;
}({});
var Events = function (__exports) {
  var MouseEventKind = __exports.MouseEventKind = function () {
    function MouseEventKind(caseName, fields) {
      _classCallCheck(this, MouseEventKind);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(MouseEventKind, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Events.MouseEventKind",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            Click: [],
            Down: [],
            Move: [],
            Up: []
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return MouseEventKind;
  }();

  setType("TheGamma.Interactive.Compost.Events.MouseEventKind", MouseEventKind);

  var TouchEventKind = __exports.TouchEventKind = function () {
    function TouchEventKind(caseName, fields) {
      _classCallCheck(this, TouchEventKind);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(TouchEventKind, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Events.TouchEventKind",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            End: [],
            Move: [],
            Start: []
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return TouchEventKind;
  }();

  setType("TheGamma.Interactive.Compost.Events.TouchEventKind", TouchEventKind);

  var InteractiveEvent = __exports.InteractiveEvent = function () {
    function InteractiveEvent(caseName, fields) {
      _classCallCheck(this, InteractiveEvent);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(InteractiveEvent, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Compost.Events.InteractiveEvent",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            MouseEvent: [MouseEventKind, Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })])],
            MouseLeave: [],
            TouchEvent: [TouchEventKind, Tuple([makeGeneric(Value, {
              u: GenericParam("vx")
            }), makeGeneric(Value, {
              u: GenericParam("vy")
            })])]
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return InteractiveEvent;
  }();

  setType("TheGamma.Interactive.Compost.Events.InteractiveEvent", InteractiveEvent);

  var projectEvent = __exports.projectEvent = function (scales_0, scales_1, projection, event) {
    var scales = [scales_0, scales_1];
    var $var32 = event.Case === "TouchEvent" ? event.Fields[1][0].Case === "COV" ? event.Fields[1][1].Case === "COV" ? [1, event.Fields[0], event.Fields[1][0].Fields[0], event.Fields[1][1].Fields[0]] : [2] : [2] : event.Case === "MouseLeave" ? [3] : event.Fields[1][0].Case === "COV" ? event.Fields[1][1].Case === "COV" ? [0, event.Fields[0], event.Fields[1][0].Fields[0], event.Fields[1][1].Fields[0]] : [2] : [2];

    switch ($var32[0]) {
      case 0:
        return new InteractiveEvent("MouseEvent", [$var32[1], function () {
          var tupledArg = [$var32[2], $var32[3]];
          var projection_1 = Projections.invertProj(projection);
          return Projections.projectInv(scales[0], scales[1], tupledArg[0], tupledArg[1], projection_1);
        }()]);

      case 1:
        return new InteractiveEvent("TouchEvent", [$var32[1], function () {
          var tupledArg_1 = [$var32[2], $var32[3]];
          var projection_2 = Projections.invertProj(projection);
          return Projections.projectInv(scales[0], scales[1], tupledArg_1[0], tupledArg_1[1], projection_2);
        }()]);

      case 2:
        throw new Error("TODO: projectEvent - not continuous");

      case 3:
        return new InteractiveEvent("MouseLeave", []);
    }
  };

  var inScale = __exports.inScale = function (s$$1, v) {
    var matchValue = [s$$1, v];

    if (matchValue[0].Case === "Categorical") {
      if (matchValue[1].Case === "COV") {
        throw new Error("inScale: Cannot test if continuous value is in categorical scale");
      } else {
        return exists(function (y) {
          return matchValue[1].Fields[0].Equals(y);
        }, matchValue[0].Fields[0]);
      }
    } else if (matchValue[1].Case === "CAR") {
      throw new Error("inScale: Cannot test if categorical value is in continuous scale");
    } else if (matchValue[1].Fields[0].Fields[0] >= (matchValue[0].Fields[0].Fields[0] < matchValue[0].Fields[1].Fields[0] ? matchValue[0].Fields[0].Fields[0] : matchValue[0].Fields[1].Fields[0])) {
      return matchValue[1].Fields[0].Fields[0] <= (matchValue[0].Fields[0].Fields[0] > matchValue[0].Fields[1].Fields[0] ? matchValue[0].Fields[0].Fields[0] : matchValue[0].Fields[1].Fields[0]);
    } else {
      return false;
    }
  };

  var inScales = __exports.inScales = function (sx, sy, event) {
    var $var33 = event.Case === "MouseEvent" ? [1, event.Fields[1][0], event.Fields[1][1]] : event.Case === "TouchEvent" ? [1, event.Fields[1][0], event.Fields[1][1]] : [0];

    switch ($var33[0]) {
      case 0:
        return true;

      case 1:
        if (inScale(sx, $var33[1])) {
          return inScale(sy, $var33[2]);
        } else {
          return false;
        }

    }
  };

  var triggerEvent = __exports.triggerEvent = function (shape, jse, event) {
    var $var34 = shape.Fields[2].Case === "ProjectedText" ? [0] : shape.Fields[2].Case === "ProjectedBubble" ? [0] : shape.Fields[2].Case === "ProjectedColumn" ? [0] : shape.Fields[2].Case === "ProjectedBar" ? [0] : shape.Fields[2].Case === "ProjectedArea" ? [0] : shape.Fields[2].Case === "ProjectedStyle" ? [1, shape.Fields[2].Fields[1]] : shape.Fields[2].Case === "ProjectedOffset" ? [1, shape.Fields[2].Fields[1]] : shape.Fields[2].Case === "ProjectedStack" ? [2, shape.Fields[2].Fields[1]] : shape.Fields[2].Case === "ProjectedLayered" ? [2, shape.Fields[2].Fields[0]] : shape.Fields[2].Case === "ProjectedInteractive" ? [3] : [0];

    switch ($var34[0]) {
      case 0:
        break;

      case 1:
        triggerEvent($var34[1], jse, event);
        break;

      case 2:
        for (var idx = 0; idx <= $var34[1].length - 1; idx++) {
          var shape_1 = $var34[1][idx];
          triggerEvent(shape_1, jse, event);
        }

        break;

      case 3:
        var localEvent = projectEvent(shape.Fields[1][0], shape.Fields[1][1], shape.Fields[0], event);

        if (inScales(shape.Fields[1][0], shape.Fields[1][1], localEvent)) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = _getIterator(shape.Fields[2].Fields[0]), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var handler = _step2.value;
              var matchValue = [localEvent, handler];
              var $var35 = matchValue[0].Case === "TouchEvent" ? matchValue[0].Fields[0].Case === "Start" ? matchValue[1].Case === "TouchStart" ? [1, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3] : matchValue[0].Fields[0].Case === "End" ? matchValue[1].Case === "TouchEnd" ? [1, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3] : matchValue[1].Case === "TouchMove" ? [1, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3] : matchValue[0].Case === "MouseLeave" ? matchValue[1].Case === "MouseLeave" ? [2, matchValue[1].Fields[0]] : [3] : matchValue[0].Fields[0].Case === "Move" ? matchValue[1].Case === "MouseMove" ? [0, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3] : matchValue[0].Fields[0].Case === "Up" ? matchValue[1].Case === "MouseUp" ? [0, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3] : matchValue[0].Fields[0].Case === "Down" ? matchValue[1].Case === "MouseDown" ? [0, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3] : matchValue[1].Case === "Click" ? [0, matchValue[1].Fields[0], matchValue[0].Fields[1]] : [3];

              switch ($var35[0]) {
                case 0:
                  if (jse != null) {
                    jse.preventDefault();
                  }

                  $var35[1](jse)($var35[2]);
                  break;

                case 1:
                  if (jse != null) {
                    jse.preventDefault();
                  }

                  $var35[1](jse)($var35[2]);
                  break;

                case 2:
                  $var35[1](jse);
                  break;

                case 3:
                  break;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }

        triggerEvent(shape.Fields[2].Fields[1], jse, event);
        break;
    }
  };

  return __exports;
}({});
var Compost = function (__exports) {
  var app = __exports.app = function (id, initial, r, u) {
    var event = new Event$2();

    var trigger = function trigger(e) {
      event.Trigger(e);
    };

    var container = document.createElement("div");
    document.getElementById(id).innerHTML = "";
    document.getElementById(id).appendChild(container);
    var tree = {};
    var state = initial;

    var handleEvent = function handleEvent(evt) {
      if (evt != null) {
        state = u(state)(evt);
      } else {
        state = state;
      }

      var newTree = renderVirtual(r(trigger)(state));
      var patches = diff(tree, newTree);
      container = patch(container, patches);
      tree = newTree;
    };

    handleEvent(null);
    add$5(function ($var36) {
      return handleEvent(function (arg0) {
        return arg0;
      }($var36));
    }, event.Publish);
  };

  var defaultFormat = __exports.defaultFormat = function (scale, value) {
    if (value.Case === "COV") {
      var v = value.Fields[0].Fields[0];
      var dec = void 0;

      if (scale.Case === "Continuous") {
        var l = scale.Fields[0].Fields[0];
        var h$$2 = scale.Fields[1].Fields[0];
        dec = Scales.decimalPoints(l, h$$2);
      } else {
        dec = 0;
      }

      return niceNumber(v, ~~dec);
    } else {
      var s$$1 = value.Fields[0].Fields[0];
      return s$$1;
    }
  };

  var defstyle = __exports.defstyle = function () {
    var Fill = new FillStyle("Solid", [[1, new Color("RGB", [196, 196, 196])]]);
    var StrokeColor = [1, new Color("RGB", [256, 0, 0])];
    var StrokeDashArray = new List$1();
    var StrokeWidth = new Width("Pixels", [2]);
    var Animation = null;
    var Cursor = "default";
    return new Style(StrokeColor, StrokeWidth, StrokeDashArray, Fill, Animation, "10pt sans-serif", Cursor, function (scale) {
      return function (value) {
        return defaultFormat(scale, value);
      };
    }, function (scale_1) {
      return function (value_1) {
        return defaultFormat(scale_1, value_1);
      };
    });
  }();

  var createSvg = __exports.createSvg = function (width, height, viz) {
    var scaled = Scales.calculateScales(defstyle, viz);
    var master = new Projections.Projection("Scale", [[0, width], [height, 0]]);
    var projected = Projections.calculateProjections(scaled, master);
    var defs = [];
    var svg = Drawing.drawShape(new Drawing.DrawingContext(defstyle, defs), projected);

    var getRelativeLocation = function getRelativeLocation(el) {
      return function (x) {
        return function (y) {
          var getOffset = function getOffset(parent) {
            return function (tupledArg) {
              getOffset: while (true) {
                if (parent == null) {
                  return [tupledArg[0], tupledArg[1]];
                } else {
                  var _var37 = parent.offsetParent;
                  tupledArg = [tupledArg[0] - parent.offsetLeft, tupledArg[1] - parent.offsetTop];
                  parent = _var37;
                  continue getOffset;
                }
              }
            };
          };

          var getParent = function getParent(parent_1) {
            getParent: while (true) {
              if (parent_1.offsetParent != null) {
                return parent_1;
              } else {
                parent_1 = parent_1.parentElement;
                continue getParent;
              }
            }
          };

          return getOffset(getParent(el))([x, y]);
        };
      };
    };

    var mouseHandler = function mouseHandler(kind) {
      return function (el_1) {
        return function (evt) {
          var evt_1 = evt;
          var patternInput = getRelativeLocation(el_1)(evt_1.pageX)(evt_1.pageY);
          Events.triggerEvent(projected, evt_1, new Events.InteractiveEvent("MouseEvent", [kind, [new Value("COV", [new continuous("CO", [patternInput[0]])]), new Value("COV", [new continuous("CO", [patternInput[1]])])]]));
        };
      };
    };

    var touchHandler = function touchHandler(kind_1) {
      return function (el_2) {
        return function (evt_2) {
          var evt_3 = evt_2;
          var touch = evt_3.touches[0];
          var patternInput_1 = getRelativeLocation(el_2)(touch.pageX)(touch.pageY);
          Events.triggerEvent(projected, evt_3, new Events.InteractiveEvent("TouchEvent", [kind_1, [new Value("COV", [new continuous("CO", [patternInput_1[0]])]), new Value("COV", [new continuous("CO", [patternInput_1[1]])])]]));
        };
      };
    };

    var counter$$1 = {
      contents: 0
    };
    var renderCtx = new Svg.RenderingContext(defs);
    return function (arg0) {
      return function (arg1) {
        return El.op_Dynamic(arg0, arg1);
      };
    }(h$$1)("div")(ofArray$1([op_EqualsGreater("style", fsFormat("width:%dpx;height:%dpx;margin:0px auto 0px auto")(function (x) {
      return x;
    })(~~width)(~~height))]))(ofArray$1([function (arg0_1) {
      return function (arg1_1) {
        return El.op_Dynamic(arg0_1, arg1_1);
      };
    }(s)("svg")(ofArray$1([op_EqualsGreater("width", String(~~width)), op_EqualsGreater("height", String(~~height)), op_EqualsBangGreater("click", mouseHandler(new Events.MouseEventKind("Click", []))), op_EqualsBangGreater("mousemove", mouseHandler(new Events.MouseEventKind("Move", []))), op_EqualsBangGreater("mousedown", mouseHandler(new Events.MouseEventKind("Down", []))), op_EqualsBangGreater("mouseup", mouseHandler(new Events.MouseEventKind("Up", []))), op_EqualsBangGreater("mouseleave", function (_arg1) {
      return function (evt_4) {
        Events.triggerEvent(projected, evt_4, new Events.InteractiveEvent("MouseLeave", []));
      };
    }), op_EqualsBangGreater("touchmove", touchHandler(new Events.TouchEventKind("Move", []))), op_EqualsBangGreater("touchdown", touchHandler(new Events.TouchEventKind("Start", []))), op_EqualsBangGreater("touchup", touchHandler(new Events.TouchEventKind("End", [])))]))(toList(delay(function () {
      var body = _Array$from(Svg.renderSvg(renderCtx, svg));

      return append(defs, delay(function () {
        return body;
      }));
    })))]));
  };

  return __exports;
}({});

var InteractiveHelpers = function (__exports) {
  var showAppAsync = __exports.showAppAsync = function (outputId, size_0, size_1, data, initial, render$$1, update) {
    var size = [size_0, size_1];
    return function (builder_) {
      return builder_.Delay(function () {
        var id = "container" + replace$$1(function () {
          var copyOfStruct = newGuid();
          return copyOfStruct;
        }(), "-", "");
        renderTo(document.getElementById(outputId), function (arg0) {
          return function (arg1) {
            return El.op_Dynamic(arg0, arg1);
          };
        }(h$$1)("div")(ofArray$1([op_EqualsGreater("id", id)]))(new List$1()));
        return builder_.Bind(Async_AwaitFuture_Static(data.data), function (_arg4) {
          var i = 10;
          return builder_.Combine(builder_.While(function () {
            return i > 0 ? document.getElementById(id) == null : false;
          }, builder_.Delay(function () {
            return builder_.Bind(sleep(10), function () {
              i = i - 1;
              return builder_.Zero();
            });
          })), builder_.Delay(function () {
            var element = document.getElementById(id);
            var size_2 = [size[0] != null ? function () {
              var w = size[0];
              return w;
            }() : element.clientWidth, size[1] != null ? function () {
              var h$$2 = size[1];
              return h$$2;
            }() : 400 > element.clientWidth / 2 ? 400 : element.clientWidth / 2];

            try {
              Compost.app(outputId, initial(_arg4), render$$1(_arg4)(size_2), update(_arg4));
            } catch (e) {
              Log.exn("GUI", "Interactive rendering failed: %O", e);
            }

            return builder_.Zero();
          }));
        });
      });
    }(singleton$2);
  };

  var showApp = __exports.showApp = function (outputId, size_0, size_1, data, initial, render$$1, update) {
    var size = [size_0, size_1];

    (function (arg00) {
      startImmediate(arg00);
    })(showAppAsync(outputId, size[0], size[1], data, initial, render$$1, update));
  };

  var showStaticAppAsync = __exports.showStaticAppAsync = function (outputId, size_0, size_1, render$$1) {
    var size = [size_0, size_1];
    var data = series.create(singleton$2.Return([]), "", "", "");

    var initial = function initial(_arg1) {};

    var render_1 = function render_1(_arg4) {
      return function (size_2) {
        return function (_arg3) {
          return function () {
            return render$$1(size_2);
          };
        };
      };
    };

    var update = function update(_arg7) {
      return function () {
        return function (_arg5) {};
      };
    };

    return showAppAsync(outputId, size[0], size[1], data, initial, render_1, update);
  };

  var showStaticApp = __exports.showStaticApp = function (outputId, size_0, size_1, data, render$$1) {
    var size = [size_0, size_1];

    var initial = function initial(_arg1) {};

    var render_1 = function render_1(data_1) {
      return function (size_2) {
        return function (_arg3) {
          return function () {
            return render$$1(data_1)(size_2);
          };
        };
      };
    };

    var update = function update(_arg6) {
      return function () {
        return function (_arg4) {};
      };
    };

    showApp(outputId, size[0], size[1], data, initial, render_1, update);
  };

  var calclateMax = __exports.calclateMax = function (maxValue$$1, data) {
    var max$$1 = maxValue$$1 != null ? maxValue$$1 : reduce(function (x, y) {
      return Math.max(x, y);
    }, map$3(function (tuple) {
      return tuple[1];
    }, data));
    return Scales.adjustRange(0, max$$1)[1];
  };

  var createLogger = __exports.createLogger = function (id, logger) {
    if (logger == null) {
      return function (_arg2) {
        return function (_arg1) {};
      };
    } else {
      return function (event) {
        return function (data) {
          logger({
            event: event,
            id: id,
            data: createObj(data)
          });
        };
      };
    }
  };

  return __exports;
}({});
var CompostHelpers = function (__exports) {
  var _Cont_ = __exports["|Cont|"] = function (_arg1) {
    if (_arg1.Case === "COV") {
      var x = _arg1.Fields[0].Fields[0];
      return x;
    } else {
      throw new Error("Expected continuous value");
    }
  };

  var _Cat_ = __exports["|Cat|"] = function (_arg1) {
    if (_arg1.Case === "CAR") {
      var x = _arg1.Fields[0].Fields[0];
      return [x, _arg1.Fields[1]];
    } else {
      throw new Error("Expected categorical value");
    }
  };

  var Cont = __exports.Cont = function (x) {
    return new Value("COV", [new continuous("CO", [x])]);
  };

  var Cat = __exports.Cat = function (x, r) {
    return new Value("CAR", [new categorical("CA", [x]), r]);
  };

  var orElse = __exports.orElse = function (a, b) {
    if (function () {
      return a != null;
    }(null)) {
      return a;
    } else {
      return b;
    }
  };

  var vega10 = __exports.vega10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];

  var infinitely = __exports.infinitely = function (s$$1) {
    if (isEmpty(s$$1)) {
      return delay(function () {
        return enumerateWhile(function () {
          return true;
        }, delay(function () {
          return singleton("black");
        }));
      });
    } else {
      return delay(function () {
        return enumerateWhile(function () {
          return true;
        }, delay(function () {
          return s$$1;
        }));
      });
    }
  };

  return __exports;
}({});
var AxisOptions = function () {
  function AxisOptions(minValue$$1, maxValue$$1, label, labelOffset) {
    _classCallCheck(this, AxisOptions);

    this.minValue = minValue$$1;
    this.maxValue = maxValue$$1;
    this.label = label;
    this.labelOffset = labelOffset;
  }

  _createClass(AxisOptions, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.AxisOptions",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          minValue: Option(Any),
          maxValue: Option(Any),
          label: Option("string"),
          labelOffset: Option("number")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }], [{
    key: "Default",
    get: function () {
      return new AxisOptions(null, null, null, null);
    }
  }]);

  return AxisOptions;
}();
setType("TheGamma.Interactive.AxisOptions", AxisOptions);
var LegendOptions = function () {
  function LegendOptions(position) {
    _classCallCheck(this, LegendOptions);

    this.position = position;
  }

  _createClass(LegendOptions, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.LegendOptions",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          position: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }], [{
    key: "Default",
    get: function () {
      return new LegendOptions("none");
    }
  }]);

  return LegendOptions;
}();
setType("TheGamma.Interactive.LegendOptions", LegendOptions);
var ChartOptions = function () {
  function ChartOptions(size, xAxis, yAxis, title, legend) {
    _classCallCheck(this, ChartOptions);

    this.size = size;
    this.xAxis = xAxis;
    this.yAxis = yAxis;
    this.title = title;
    this.legend = legend;
  }

  _createClass(ChartOptions, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.ChartOptions",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          size: Tuple([Option("number"), Option("number")]),
          xAxis: AxisOptions,
          yAxis: AxisOptions,
          title: Option("string"),
          legend: LegendOptions
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }], [{
    key: "Default",
    get: function () {
      var size = [null, null];
      var title = null;
      var legend = LegendOptions.Default;
      return new ChartOptions(size, AxisOptions.Default, AxisOptions.Default, title, legend);
    }
  }]);

  return ChartOptions;
}();
setType("TheGamma.Interactive.ChartOptions", ChartOptions);
var Internal = function (__exports) {
  var arrayMap = __exports.arrayMap = function (f, s$$1) {
    return _Array$from(map$3(f, s$$1));
  };

  var mapColor = __exports.mapColor = function (f, clr) {
    var r = parseInt(clr.substr(1, 2), 16);
    var g = parseInt(clr.substr(3, 2), 16);
    var b = parseInt(clr.substr(5, 2), 16);
    var patternInput = f([r, g, b]);

    var fi = function fi(n) {
      return padLeft((~~n).toString(16), 2, "0");
    };

    return "#" + fi(patternInput[0]) + fi(patternInput[1]) + fi(patternInput[2]);
  };

  var ScalePoints = __exports.ScalePoints = function () {
    function ScalePoints(minimum, maximum, middle) {
      _classCallCheck(this, ScalePoints);

      this.Minimum = minimum;
      this.Maximum = maximum;
      this.Middle = middle;
    }

    _createClass(ScalePoints, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Internal.ScalePoints",
          interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
          properties: {
            Minimum: makeGeneric(Value, {
              u: Any
            }),
            Maximum: makeGeneric(Value, {
              u: Any
            }),
            Middle: makeGeneric(Value, {
              u: Any
            })
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareRecords(this, other);
      }
    }]);

    return ScalePoints;
  }();

  setType("TheGamma.Interactive.Internal.ScalePoints", ScalePoints);

  var ChartContext = __exports.ChartContext = function () {
    function ChartContext(chart, xPoints, yPoints, xData, yData, padding, chartOptions) {
      _classCallCheck(this, ChartContext);

      this.Chart = chart;
      this.XPoints = xPoints;
      this.YPoints = yPoints;
      this.XData = xData;
      this.YData = yData;
      this.Padding = padding;
      this.ChartOptions = chartOptions;
    }

    _createClass(ChartContext, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.Internal.ChartContext",
          interfaces: ["FSharpRecord"],
          properties: {
            Chart: makeGeneric(Shape, {
              vx: Any,
              vy: Any
            }),
            XPoints: ScalePoints,
            YPoints: ScalePoints,
            XData: FableArray(Any),
            YData: FableArray(Any),
            Padding: Tuple(["number", "number", "number", "number"]),
            ChartOptions: ChartOptions
          }
        };
      }
    }]);

    return ChartContext;
  }();

  setType("TheGamma.Interactive.Internal.ChartContext", ChartContext);

  var calculateScales = __exports.calculateScales = function (chart) {
    var patternInput = Scales.calculateScales(Compost.defstyle, chart);
    var sy = patternInput.Fields[0][1];
    var sx = patternInput.Fields[0][0];

    var getPoints = function getPoints(_arg1) {
      if (_arg1.Case === "Categorical") {
        return new ScalePoints(new Value("CAR", [_arg1.Fields[0][0], 0]), new Value("CAR", [_arg1.Fields[0][_arg1.Fields[0].length - 1], 1]), _arg1.Fields[0].length % 2 === 1 ? new Value("CAR", [_arg1.Fields[0][~~(_arg1.Fields[0].length / 2)], 0.5]) : new Value("CAR", [_arg1.Fields[0][~~(_arg1.Fields[0].length / 2)], 0]));
      } else {
        var lo = _arg1.Fields[0].Fields[0];
        var hi = _arg1.Fields[1].Fields[0];
        return new ScalePoints(new Value("COV", [new continuous("CO", [lo])]), new Value("COV", [new continuous("CO", [hi])]), new Value("COV", [new continuous("CO", [(hi + lo) / 2])]));
      }
    };

    return [getPoints(sx), getPoints(sy)];
  };

  var initChart = __exports.initChart = function (xdata, ydata, options, chart) {
    var patternInput = calculateScales(chart);
    var Padding = [20, 20, 20, 20];
    return new ChartContext(chart, patternInput[0], patternInput[1], xdata, ydata, Padding, options);
  };

  var applyStyle = __exports.applyStyle = function (f, chart) {
    return new Shape("Style", [f, chart]);
  };

  var applyInteractive = __exports.applyInteractive = function (e, chart) {
    return new Shape("Interactive", [e, chart]);
  };

  var applyScales = __exports.applyScales = function (ctx) {
    var getInnerScale = function getInnerScale(axis) {
      return function (sp) {
        if (equals(axis.minValue, null) ? equals(axis.maxValue, null) : false) {
          return null;
        } else {
          var $var38 = sp.Minimum.Case === "COV" ? sp.Maximum.Case === "COV" ? [0, sp.Maximum.Fields[0].Fields[0], sp.Minimum.Fields[0].Fields[0]] : [1] : [1];

          switch ($var38[0]) {
            case 0:
              var patternInput = [defaultArg(axis.minValue, $var38[2]), defaultArg(axis.maxValue, $var38[1])];
              return [new continuous("CO", [patternInput[0]]), new continuous("CO", [patternInput[1]])];

            case 1:
              return null;
          }
        }
      };
    };

    var sx = getInnerScale(ctx.ChartOptions.xAxis)(ctx.XPoints);
    var sy = getInnerScale(ctx.ChartOptions.yAxis)(ctx.YPoints);
    var chart = new Shape("AutoScale", [function () {
      return sx == null;
    }(null), function () {
      return sy == null;
    }(null), new Shape("InnerScale", [sx, sy, ctx.Chart])]);
    var patternInput_1 = calculateScales(chart);
    return new ChartContext(chart, patternInput_1[0], patternInput_1[1], ctx.XData, ctx.YData, ctx.Padding, ctx.ChartOptions);
  };

  var applyAxes = __exports.applyAxes = function (xlab, ylab, ctx) {
    var style = function style(data) {
      var isDate = exists(function (n) {
        return n instanceof Date;
      }, data);

      if (isDate) {
        var _ret = function () {
          var values = arrayMap(function (n_1) {
            return n_1 instanceof Date ? n_1.getTime() : n_1;
          }, data);
          var patternInput = [new Date(reduce(function (x, y) {
            return Math.min(x, y);
          }, values)), new Date(reduce(function (x, y) {
            return Math.max(x, y);
          }, values))];

          if (function () {
            var copyOfStruct = op_Subtraction(patternInput[1], patternInput[0]);
            return totalDays(copyOfStruct);
          }() <= 1) {
            return {
              v: function v(_arg2) {
                return function (_arg1) {
                  var activePatternResult3506 = CompostHelpers["|Cont|"](_arg1);
                  return new Date(activePatternResult3506).toLocaleString("en-US", {
                    hour: "numeric",
                    minute: "numeric",
                    second: "numeric"
                  });
                };
              }
            };
          } else {
            return {
              v: function v(_arg4) {
                return function (_arg3) {
                  var activePatternResult3509 = CompostHelpers["|Cont|"](_arg3);
                  return new Date(activePatternResult3509).toLocaleString("en-US", {
                    day: "numeric",
                    year: "numeric",
                    month: "short"
                  });
                };
              }
            };
          }
        }();

        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
      } else {
        return function (scale) {
          return function (value) {
            return Compost.defaultFormat(scale, value);
          };
        };
      }
    };

    var chart = applyStyle(function (s$$1) {
      var FormatAxisXLabel = style(ctx.XData);
      var FormatAxisYLabel = style(ctx.YData);
      return new Style(s$$1.StrokeColor, s$$1.StrokeWidth, s$$1.StrokeDashArray, s$$1.Fill, s$$1.Animation, s$$1.Font, s$$1.Cursor, FormatAxisXLabel, FormatAxisYLabel);
    }, new Shape("Axes", [xlab, ylab, ctx.Chart]));
    return new ChartContext(new Shape("Padding", [ctx.Padding, chart]), ctx.XPoints, ctx.YPoints, ctx.XData, ctx.YData, ctx.Padding, ctx.ChartOptions);
  };

  var applyLegend = __exports.applyLegend = function (width, height, labels, ctx) {
    if (ctx.ChartOptions.legend.position === "right") {
      var _ret2 = function () {
        var labels_1 = _Array$from(labels);

        var labs = new Shape("InnerScale", [[new continuous("CO", [0]), new continuous("CO", [100])], null, new Shape("Layered", [toList(delay(function () {
          return collect(function (matchValue) {
            var style = function style(clr) {
              var f = function f(s$$1) {
                var Font = "9pt Roboto,sans-serif";
                var Fill = new FillStyle("Solid", [[1, new Color("HTML", [clr])]]);
                return new Style([0, new Color("RGB", [0, 0, 0])], s$$1.StrokeWidth, s$$1.StrokeDashArray, Fill, s$$1.Animation, Font, s$$1.Cursor, s$$1.FormatAxisXLabel, s$$1.FormatAxisYLabel);
              };

              return function (chart) {
                return applyStyle(f, chart);
              };
            };

            return append(singleton(style(matchValue[0])(new Shape("Padding", [[4, 0, 4, 0], new Shape("Bar", [new continuous("CO", [6]), new categorical("CA", [matchValue[1]])])]))), delay(function () {
              return singleton(style("black")(new Shape("Text", [new Value("COV", [new continuous("CO", [8])]), new Value("CAR", [new categorical("CA", [matchValue[1]]), 0.5]), new VerticalAlign("Middle", []), new HorizontalAlign("Start", []), 0, matchValue[1]])));
            }));
          }, labels_1);
        }))])]);
        var patternInput = [(width - 250) / width, (ctx.Padding[0] + labels_1.length * 30) / height];
        var chart_1 = new Shape("Layered", [ofArray$1([new Shape("OuterScale", [new Scale("Continuous", [new continuous("CO", [0]), new continuous("CO", [patternInput[0]])]), new Scale("Continuous", [new continuous("CO", [0]), new continuous("CO", [1])]), ctx.Chart]), new Shape("OuterScale", [new Scale("Continuous", [new continuous("CO", [patternInput[0]]), new continuous("CO", [1])]), new Scale("Continuous", [new continuous("CO", [0]), new continuous("CO", [patternInput[1]])]), new Shape("Padding", [[ctx.Padding[0], 0, 0, 20], labs])])])]);
        return {
          v: new ChartContext(chart_1, ctx.XPoints, ctx.YPoints, ctx.XData, ctx.YData, ctx.Padding, ctx.ChartOptions)
        };
      }();

      if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
    } else {
      return ctx;
    }
  };

  var applyLabels = __exports.applyLabels = function (ctx) {
    var lblStyle = function lblStyle(font) {
      return function (chart) {
        return applyStyle(function (s$$1) {
          var StrokeWidth = new Width("Pixels", [0]);
          var Fill = new FillStyle("Solid", [[1, new Color("HTML", ["black"])]]);
          return new Style(s$$1.StrokeColor, StrokeWidth, s$$1.StrokeDashArray, Fill, s$$1.Animation, font, s$$1.Cursor, s$$1.FormatAxisXLabel, s$$1.FormatAxisYLabel);
        }, chart);
      };
    };

    var patternInput = void 0;
    var matchValue = ctx.ChartOptions.xAxis.label;

    if (matchValue != null) {
      var offs = defaultArg(ctx.ChartOptions.xAxis.labelOffset, 40);
      var lbl = new Shape("Offset", [[0, offs], new Shape("Text", [ctx.XPoints.Middle, ctx.YPoints.Minimum, new VerticalAlign("Middle", []), new HorizontalAlign("Center", []), 0, matchValue])]);
      patternInput = [new Shape("Layered", [ofArray$1([ctx.Chart, lblStyle("bold 9pt Roboto,sans-serif")(lbl)])]), offs + 10];
    } else {
      patternInput = [ctx.Chart, ctx.Padding[2]];
    }

    var patternInput_1 = void 0;
    var matchValue_1 = ctx.ChartOptions.yAxis.label;

    if (matchValue_1 != null) {
      var offs_1 = defaultArg(ctx.ChartOptions.yAxis.labelOffset, 60);
      var lbl_1 = new Shape("Offset", [[-offs_1, 0], new Shape("Text", [ctx.XPoints.Minimum, ctx.YPoints.Middle, new VerticalAlign("Middle", []), new HorizontalAlign("Center", []), -90, matchValue_1])]);
      patternInput_1 = [new Shape("Layered", [ofArray$1([patternInput[0], lblStyle("bold 9pt Roboto,sans-serif")(lbl_1)])]), offs_1 + 10];
    } else {
      patternInput_1 = [patternInput[0], ctx.Padding[3]];
    }

    var patternInput_2 = void 0;
    var matchValue_2 = ctx.ChartOptions.title;

    if (matchValue_2 != null) {
      var ttl = new Shape("Offset", [[0, -30], new Shape("Text", [ctx.XPoints.Middle, ctx.YPoints.Maximum, new VerticalAlign("Hanging", []), new HorizontalAlign("Center", []), 0, matchValue_2])]);
      patternInput_2 = [new Shape("Layered", [ofArray$1([patternInput_1[0], lblStyle("13pt Roboto,sans-serif")(ttl)])]), 40];
    } else {
      patternInput_2 = [patternInput_1[0], ctx.Padding[0]];
    }

    var Padding = [patternInput_2[1], ctx.Padding[1], patternInput[1], patternInput_1[1]];
    return new ChartContext(patternInput_2[0], ctx.XPoints, ctx.YPoints, ctx.XData, ctx.YData, Padding, ctx.ChartOptions);
  };

  var createChart = __exports.createChart = function (size_0, size_1, ctx) {
    var size = [size_0, size_1];
    return function (arg0) {
      return function (arg1) {
        return El.op_Dynamic(arg0, arg1);
      };
    }(h$$1)("div")(ofArray$1([op_EqualsGreater("style", "text-align:center;padding-top:20px")]))(ofArray$1([Compost.createSvg(size[0], size[1], ctx.Chart)]));
  };

  var inAxis = __exports.inAxis = function (axis, value) {
    if (function () {
      return axis.minValue != null;
    }(null) ? (value instanceof Date ? value.getTime() : value) < (axis.minValue instanceof Date ? axis.minValue.getTime() : axis.minValue) : false) {
      return false;
    } else if (function () {
      return axis.maxValue != null;
    }(null) ? (value instanceof Date ? value.getTime() : value) > (axis.maxValue instanceof Date ? axis.maxValue.getTime() : axis.maxValue) : false) {
      return false;
    } else {
      return true;
    }
  };

  return __exports;
}({});
var Charts = function (__exports) {
  var renderBubbles = __exports.renderBubbles = function (chartOptions, size_0, size_1, bc, data) {
    var size = [size_0, size_1];
    var patternInput = [data.map(function (tupledArg) {
      return tupledArg[0];
    }), data.map(function (tupledArg_1) {
      return tupledArg_1[1];
    })];
    return Internal.createChart(size[0], size[1], Internal.applyAxes(true, true, Internal.applyLabels(Internal.applyScales(function (chart) {
      return Internal.initChart(patternInput[0], patternInput[1], chartOptions, chart);
    }(new Shape("Layered", [toList(delay(function () {
      return collect(function (matchValue) {
        if (Internal.inAxis(chartOptions.xAxis, matchValue[0]) ? Internal.inAxis(chartOptions.yAxis, matchValue[1]) : false) {
          var size_2 = defaultArg(matchValue[2], 2);
          var b = new Shape("Bubble", [new Value("COV", [new continuous("CO", [matchValue[0] instanceof Date ? matchValue[0].getTime() : matchValue[0]])]), new Value("COV", [new continuous("CO", [matchValue[1] instanceof Date ? matchValue[1].getTime() : matchValue[1]])]), size_2, size_2]);
          return singleton(Internal.applyStyle(function (s$$1) {
            var StrokeWidth = new Width("Pixels", [0]);
            var Fill = new FillStyle("Solid", [[0.6, new Color("HTML", [bc])]]);
            return new Style(s$$1.StrokeColor, StrokeWidth, s$$1.StrokeDashArray, Fill, s$$1.Animation, s$$1.Font, s$$1.Cursor, s$$1.FormatAxisXLabel, s$$1.FormatAxisYLabel);
          }, b));
        } else {
          return empty();
        }
      }, data);
    }))]))))));
  };

  var renderLines = __exports.renderLines = function (isArea, chartOptions, size_0, size_1, lcs, labels, data) {
    var size = [size_0, size_1];
    var patternInput = [_Array$from(collect(function () {
      var mapping = function mapping(tuple) {
        return tuple[0];
      };

      return function (array) {
        return array.map(mapping);
      };
    }(), data)), _Array$from(collect(function () {
      var mapping_1 = function mapping_1(tuple_1) {
        return tuple_1[1];
      };

      return function (array_1) {
        return array_1.map(mapping_1);
      };
    }(), data))];
    return Internal.createChart(size[0], size[1], function () {
      var labels_1 = zip(CompostHelpers.infinitely(lcs), labels);
      return function (ctx) {
        return Internal.applyLegend(size[0], size[1], labels_1, ctx);
      };
    }()(Internal.applyAxes(true, true, Internal.applyLabels(Internal.applyScales(function (chart) {
      return Internal.initChart(patternInput[0], patternInput[1], chartOptions, chart);
    }(new Shape("Layered", [toList(delay(function () {
      return collect(function (matchValue) {
        var points = toList(delay(function () {
          return collect(function (matchValue_1) {
            return (Internal.inAxis(chartOptions.xAxis, matchValue_1[0]) ? Internal.inAxis(chartOptions.yAxis, matchValue_1[1]) : false) ? singleton([new Value("COV", [new continuous("CO", [matchValue_1[0] instanceof Date ? matchValue_1[0].getTime() : matchValue_1[0]])]), new Value("COV", [new continuous("CO", [matchValue_1[1] instanceof Date ? matchValue_1[1].getTime() : matchValue_1[1]])])]) : empty();
          }, matchValue[1]);
        }));

        if (!(points.tail == null)) {
          return append(isArea ? singleton(Internal.applyStyle(function (s$$1) {
            var Fill = new FillStyle("Solid", [[0.4, new Color("HTML", [matchValue[0]])]]);
            var StrokeWidth = new Width("Pixels", [0]);
            return new Style(s$$1.StrokeColor, StrokeWidth, s$$1.StrokeDashArray, Fill, s$$1.Animation, s$$1.Font, s$$1.Cursor, s$$1.FormatAxisXLabel, s$$1.FormatAxisYLabel);
          }, new Shape("Area", [points]))) : empty(), delay(function () {
            return singleton(Internal.applyStyle(function (s_1) {
              return new Style([1, new Color("HTML", [matchValue[0]])], new Width("Pixels", [2]), s_1.StrokeDashArray, s_1.Fill, s_1.Animation, s_1.Font, s_1.Cursor, s_1.FormatAxisXLabel, s_1.FormatAxisYLabel);
            }, new Shape("Line", [points])));
          }));
        } else {
          return empty();
        }
      }, zip(CompostHelpers.infinitely(lcs), data));
    }))])))))));
  };

  var renderColsBars = __exports.renderColsBars = function (isBar, inlineLabels, chartOptions, size_0, size_1, clrs, labels, data) {
    var size = [size_0, size_1];
    var patternInput = isBar ? [data.map(function ($var39) {
      return $var39[1];
    }), data.map(function ($var40) {
      return $var40[0];
    })] : [data.map(function ($var41) {
      return $var41[0];
    }), data.map(function ($var42) {
      return $var42[1];
    })];
    var patternInput_1 = Internal.applyScales(function (chart) {
      return Internal.initChart(patternInput[0], patternInput[1], chartOptions, chart);
    }(new Shape("Layered", [toList(delay(function () {
      return collect(function (matchValue) {
        return singleton(isBar ? new Shape("Bar", [new continuous("CO", [matchValue[1]]), new categorical("CA", [matchValue[0]])]) : new Shape("Column", [new categorical("CA", [matchValue[0]]), new continuous("CO", [matchValue[1]])]));
      }, data);
    }))])));
    var chartOptions_1 = void 0;

    if ((isBar ? inlineLabels : false) ? function () {
      return chartOptions.yAxis.labelOffset == null;
    }(null) : false) {
      var yAxis = void 0;
      var labelOffset = 10;
      yAxis = new AxisOptions(chartOptions.yAxis.minValue, chartOptions.yAxis.maxValue, chartOptions.yAxis.label, labelOffset);
      chartOptions_1 = new ChartOptions(chartOptions.size, chartOptions.xAxis, yAxis, chartOptions.title, chartOptions.legend);
    } else if ((!isBar ? inlineLabels : false) ? function () {
      return chartOptions.yAxis.labelOffset == null;
    }(null) : false) {
      var xAxis = void 0;
      var labelOffset_1 = 10;
      xAxis = new AxisOptions(chartOptions.xAxis.minValue, chartOptions.xAxis.maxValue, chartOptions.xAxis.label, labelOffset_1);
      chartOptions_1 = new ChartOptions(chartOptions.size, xAxis, chartOptions.yAxis, chartOptions.title, chartOptions.legend);
    } else {
      chartOptions_1 = chartOptions;
    }

    return Internal.createChart(size[0], size[1], function () {
      var labels_1 = zip(CompostHelpers.infinitely(clrs), labels);
      return function (ctx) {
        return Internal.applyLegend(size[0], size[1], labels_1, ctx);
      };
    }()(Internal.applyAxes(!(inlineLabels ? !isBar : false), !(inlineLabels ? isBar : false), Internal.applyLabels(Internal.applyScales(function (chart_1) {
      return Internal.initChart(patternInput[0], patternInput[1], chartOptions_1, chart_1);
    }(new Shape("Layered", [toList(delay(function () {
      return collect(function (matchValue_1) {
        var v = matchValue_1[1][1];
        var lbl = matchValue_1[1][0];
        var elem = isBar ? new Shape("Padding", [[6, 0, 6, 1], new Shape("Bar", [new continuous("CO", [v]), new categorical("CA", [lbl])])]) : new Shape("Padding", [[0, 6, 1, 6], new Shape("Column", [new categorical("CA", [lbl]), new continuous("CO", [v])])]);
        var label = !inlineLabels ? null : isBar ? new Shape("Offset", [[20, 0], new Shape("Text", [patternInput_1.XPoints.Minimum, new Value("CAR", [new categorical("CA", [lbl]), 0.5]), new VerticalAlign("Middle", []), new HorizontalAlign("Start", []), 0, lbl])]) : new Shape("Offset", [[0, -20], new Shape("Text", [new Value("CAR", [new categorical("CA", [lbl]), 0.5]), patternInput_1.YPoints.Minimum, new VerticalAlign("Middle", []), new HorizontalAlign("Start", []), -90, lbl])]);
        return append(singleton(Internal.applyStyle(function (s$$1) {
          var Fill = new FillStyle("Solid", [[0.6, new Color("HTML", [matchValue_1[0]])]]);
          return new Style(s$$1.StrokeColor, s$$1.StrokeWidth, s$$1.StrokeDashArray, Fill, s$$1.Animation, s$$1.Font, s$$1.Cursor, s$$1.FormatAxisXLabel, s$$1.FormatAxisYLabel);
        }, elem)), delay(function () {
          if (function () {
            return label != null;
          }(null)) {
            var _ret3 = function () {
              var clr = Internal.mapColor(function (tupledArg) {
                return [tupledArg[0] * 0.8, tupledArg[1] * 0.8, tupledArg[2] * 0.8];
              }, matchValue_1[0]);
              return {
                v: singleton(Internal.applyStyle(function (s_1) {
                  var Font = "11pt Roboto,sans-serif";
                  var Fill_1 = new FillStyle("Solid", [[1, new Color("HTML", [clr])]]);
                  var StrokeWidth = new Width("Pixels", [0]);
                  return new Style(s_1.StrokeColor, StrokeWidth, s_1.StrokeDashArray, Fill_1, s_1.Animation, Font, s_1.Cursor, s_1.FormatAxisXLabel, s_1.FormatAxisYLabel);
                }, label))
              };
            }();

            if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
          } else {
            return empty();
          }
        }));
      }, zip(CompostHelpers.infinitely(clrs), data));
    }))])))))));
  };

  return __exports;
}({});
var YouDrawHelpers = function (__exports) {
  var YouDrawEvent = __exports.YouDrawEvent = function () {
    function YouDrawEvent(caseName, fields) {
      _classCallCheck(this, YouDrawEvent);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(YouDrawEvent, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.YouDrawHelpers.YouDrawEvent",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            Draw: ["number", "number"],
            ShowResults: []
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return YouDrawEvent;
  }();

  setType("TheGamma.Interactive.YouDrawHelpers.YouDrawEvent", YouDrawEvent);

  var YouDrawState = __exports.YouDrawState = function () {
    function YouDrawState(completed, clip, data, xData, yData, guessed, isKeyDate) {
      _classCallCheck(this, YouDrawState);

      this.Completed = completed;
      this.Clip = clip;
      this.Data = data;
      this.XData = xData;
      this.YData = yData;
      this.Guessed = guessed;
      this.IsKeyDate = isKeyDate;
    }

    _createClass(YouDrawState, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.YouDrawHelpers.YouDrawState",
          interfaces: ["FSharpRecord", "System.IEquatable"],
          properties: {
            Completed: "boolean",
            Clip: "number",
            Data: FableArray(Tuple(["number", "number"])),
            XData: FableArray(Any),
            YData: FableArray(Any),
            Guessed: FableArray(Tuple(["number", Option("number")])),
            IsKeyDate: "boolean"
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }]);

    return YouDrawState;
  }();

  setType("TheGamma.Interactive.YouDrawHelpers.YouDrawState", YouDrawState);

  var initState = __exports.initState = function (data, clipx) {
    var isDate = exists(function ($var43) {
      return $var43[0] instanceof Date;
    }, data);
    var numData = data.map(function (tupledArg) {
      return [tupledArg[0] instanceof Date ? tupledArg[0].getTime() : tupledArg[0], tupledArg[1]];
    });
    var Completed = false;
    var XData = data.map(function ($var44) {
      return $var44[0];
    });
    var YData = data.map(function ($var45) {
      return $var45[1];
    });
    return new YouDrawState(Completed, clipx, numData, XData, YData, _Array$from(delay(function () {
      return collect(function (matchValue) {
        return matchValue[0] > clipx ? singleton([matchValue[0], null]) : empty();
      }, numData);
    })), isDate);
  };

  var handler = __exports.handler = function (log, state, evt) {
    var collectData = function collectData() {
      return state.Data.map(function (tupledArg) {
        return [tupledArg[0], tupledArg[1]];
      });
    };

    var collectGuesses = function collectGuesses() {
      return _Array$from(choose(function (tupledArg_1) {
        return function () {
          return tupledArg_1[1] != null;
        }(null) ? [tupledArg_1[0], tupledArg_1[1]] : null;
      }, state.Guessed));
    };

    if (evt.Case === "Draw") {
      var _ret4 = function () {
        var indexed = state.Guessed.map(function (x, y) {
          return [y, x];
        });
        var patternInput = reduce(function (f) {
          return function (x, y) {
            return f(x) < f(y) ? x : y;
          };
        }(function (tupledArg_2) {
          return Math.abs(evt.Fields[0] - tupledArg_2[1][0]);
        }), indexed);
        var Guessed = indexed.map(function (tupledArg_3) {
          return tupledArg_3[0] === patternInput[0] ? [tupledArg_3[1][0], evt.Fields[1]] : [tupledArg_3[1][0], tupledArg_3[1][1]];
        });
        return {
          v: new YouDrawState(state.Completed, state.Clip, state.Data, state.XData, state.YData, Guessed, state.IsKeyDate)
        };
      }();

      if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
    } else {
      log("completed")(ofArray$1([["guess", collectGuesses(null)], ["values", collectData(null)]]));
      return new YouDrawState(true, state.Clip, state.Data, state.XData, state.YData, state.Guessed, state.IsKeyDate);
    }
  };

  var render$$1 = __exports.render = function (chartOptions, width, height, markers, leftLbl, rightLbl, leftClr, rightClr, guessClr, markClr, trigger, state) {
    var all = _Array$from(delay(function () {
      return collect(function (matchValue) {
        return singleton([CompostHelpers.Cont(matchValue[0]), CompostHelpers.Cont(matchValue[1])]);
      }, state.Data);
    }));

    var known = _Array$from(delay(function () {
      return collect(function (matchValue_1) {
        return matchValue_1[0] <= state.Clip ? singleton([CompostHelpers.Cont(matchValue_1[0]), CompostHelpers.Cont(matchValue_1[1])]) : empty();
      }, state.Data);
    }));

    var right = _Array$from(delay(function () {
      return append(singleton(last(known)), delay(function () {
        return collect(function (matchValue_2) {
          return matchValue_2[0] > state.Clip ? singleton([CompostHelpers.Cont(matchValue_2[0]), CompostHelpers.Cont(matchValue_2[1])]) : empty();
        }, state.Data);
      }));
    }));

    var guessed = _Array$from(delay(function () {
      return append(singleton(last(known)), delay(function () {
        return collect(function (matchValue_3) {
          return function () {
            return matchValue_3[1] != null;
          }(null) ? singleton([CompostHelpers.Cont(matchValue_3[0]), CompostHelpers.Cont(matchValue_3[1])]) : empty();
        }, state.Guessed);
      }));
    }));

    var loy = void 0;
    var matchValue_4 = chartOptions.yAxis.minValue;

    if (matchValue_4 != null) {
      loy = matchValue_4;
    } else {
      loy = reduce(function (x, y) {
        return Math.min(x, y);
      }, map$3(function (tuple) {
        return tuple[1];
      }, state.Data));
    }

    var hiy = void 0;
    var matchValue_5 = chartOptions.yAxis.maxValue;

    if (matchValue_5 != null) {
      hiy = matchValue_5;
    } else {
      hiy = reduce(function (x, y) {
        return Math.max(x, y);
      }, map$3(function (tuple_1) {
        return tuple_1[1];
      }, state.Data));
    }

    var patternInput = [(head(state.Data)[0] + state.Clip) / 2, loy + (hiy - loy) / 10];
    var patternInput_1 = [(last(state.Data)[0] + state.Clip) / 2, loy + (hiy - loy) / 10];
    var patternInput_2 = [state.Clip, hiy - (hiy - loy) / 10];

    var setColor = function setColor(c) {
      return function (s$$1) {
        var Font = "12pt Roboto,sans-serif";
        var Fill = new FillStyle("Solid", [[1, new Color("HTML", [c])]]);
        return new Style([0, new Color("RGB", [0, 0, 0])], s$$1.StrokeWidth, s$$1.StrokeDashArray, Fill, s$$1.Animation, Font, s$$1.Cursor, s$$1.FormatAxisXLabel, s$$1.FormatAxisYLabel);
      };
    };

    var labels = new Shape("Layered", [ofArray$1([new Shape("Style", [setColor(leftClr), new Shape("Text", [new Value("COV", [new continuous("CO", [patternInput[0]])]), new Value("COV", [new continuous("CO", [patternInput[1]])]), new VerticalAlign("Baseline", []), new HorizontalAlign("Center", []), 0, leftLbl])]), new Shape("Style", [setColor(rightClr), new Shape("Text", [new Value("COV", [new continuous("CO", [patternInput_1[0]])]), new Value("COV", [new continuous("CO", [patternInput_1[1]])]), new VerticalAlign("Baseline", []), new HorizontalAlign("Center", []), 0, rightLbl])])])]);

    var LineStyle = function LineStyle(shape) {
      return new Shape("Style", [function (s_1) {
        var Fill_1 = new FillStyle("Solid", [[1, new Color("HTML", ["transparent"])]]);
        var StrokeWidth = new Width("Pixels", [2]);
        var StrokeDashArray = ofArray$1([new _Number("Integer", [5]), new _Number("Integer", [5])]);
        return new Style([0.6, new Color("HTML", [markClr])], StrokeWidth, StrokeDashArray, Fill_1, s_1.Animation, s_1.Font, s_1.Cursor, s_1.FormatAxisXLabel, s_1.FormatAxisYLabel);
      }, shape]);
    };

    var FontStyle = function FontStyle(shape_1) {
      return new Shape("Style", [function (s_2) {
        var Font_1 = "11pt Roboto,sans-serif";
        var Fill_2 = new FillStyle("Solid", [[1, new Color("HTML", [markClr])]]);
        return new Style([0, new Color("HTML", ["transparent"])], s_2.StrokeWidth, s_2.StrokeDashArray, Fill_2, s_2.Animation, Font_1, s_2.Cursor, s_2.FormatAxisXLabel, s_2.FormatAxisYLabel);
      }, shape_1]);
    };

    var patternInput_3 = Scales.adjustRange(loy, hiy);
    var markers_1 = toList(delay(function () {
      return collect(function (matchValue_6) {
        var x = matchValue_6[1][0];
        var lbl = matchValue_6[1][1];
        var patternInput_4 = matchValue_6[0] % 2 === 0 ? [0.9, 0.95] : [0.8, 0.85];
        var ytx = patternInput_3[0] + (patternInput_3[1] - patternInput_3[0]) * patternInput_4[1];
        var hiln = patternInput_3[0] + (patternInput_3[1] - patternInput_3[0]) * patternInput_4[0];
        return append(singleton(LineStyle(new Shape("Line", [ofArray$1([[new Value("COV", [new continuous("CO", [x])]), new Value("COV", [new continuous("CO", [patternInput_3[0]])])], [new Value("COV", [new continuous("CO", [x])]), new Value("COV", [new continuous("CO", [hiln])])]])]))), delay(function () {
          return singleton(FontStyle(new Shape("Text", [new Value("COV", [new continuous("CO", [x])]), new Value("COV", [new continuous("CO", [ytx])]), new VerticalAlign("Middle", []), new HorizontalAlign("Center", []), 0, toString$2(lbl)])));
        }));
      }, mapIndexed(function (i, v) {
        return [i, v];
      }, markers));
    }));
    var coreChart = new Shape("Layered", [toList(delay(function () {
      return append(singleton(labels), delay(function () {
        return append(markers_1, delay(function () {
          return append(singleton(new Shape("Style", [function ($var46) {
            return Drawing.hideStroke(Drawing.hideFill($var46));
          }, new Shape("Line", [all])])), delay(function () {
            return append(singleton(new Shape("Style", [function (s_3) {
              var StrokeColor = [1, new Color("HTML", [leftClr])];
              var Fill_3 = new FillStyle("Solid", [[0.2, new Color("HTML", [leftClr])]]);
              return new Style(StrokeColor, s_3.StrokeWidth, s_3.StrokeDashArray, Fill_3, s_3.Animation, s_3.Font, s_3.Cursor, s_3.FormatAxisXLabel, s_3.FormatAxisYLabel);
            }, new Shape("Layered", [ofArray$1([new Shape("Area", [known]), new Shape("Line", [known])])])])), delay(function () {
              return append(state.Completed ? singleton(new Shape("Style", [function (s_4) {
                var StrokeColor_1 = [1, new Color("HTML", [rightClr])];
                var StrokeDashArray_1 = ofArray$1([new _Number("Percentage", [0]), new _Number("Percentage", [100])]);
                var Fill_4 = new FillStyle("Solid", [[0, new Color("HTML", [rightClr])]]);
                var Animation = [1000, "ease", function (s_5) {
                  var StrokeDashArray_2 = ofArray$1([new _Number("Percentage", [100]), new _Number("Percentage", [0])]);
                  var Fill_5 = new FillStyle("Solid", [[0.2, new Color("HTML", [rightClr])]]);
                  return new Style(s_5.StrokeColor, s_5.StrokeWidth, StrokeDashArray_2, Fill_5, s_5.Animation, s_5.Font, s_5.Cursor, s_5.FormatAxisXLabel, s_5.FormatAxisYLabel);
                }];
                return new Style(StrokeColor_1, s_4.StrokeWidth, StrokeDashArray_1, Fill_4, Animation, s_4.Font, s_4.Cursor, s_4.FormatAxisXLabel, s_4.FormatAxisYLabel);
              }, new Shape("Layered", [ofArray$1([new Shape("Area", [right]), new Shape("Line", [right])])])])) : empty(), delay(function () {
                return guessed.length > 1 ? singleton(new Shape("Style", [function (s_6) {
                  var StrokeColor_2 = [1, new Color("HTML", [guessClr])];
                  var StrokeDashArray_3 = ofArray$1([new _Number("Integer", [5]), new _Number("Integer", [5])]);
                  return new Style(StrokeColor_2, s_6.StrokeWidth, StrokeDashArray_3, s_6.Fill, s_6.Animation, s_6.Font, s_6.Cursor, s_6.FormatAxisXLabel, s_6.FormatAxisYLabel);
                }, new Shape("Line", [guessed])])) : empty();
              }));
            }));
          }));
        }));
      }));
    }))]);
    var patternInput_5 = Internal.applyAxes(true, true, Internal.applyLabels(Internal.applyScales(function (chart) {
      return Internal.initChart(state.XData, state.YData, chartOptions, chart);
    }(coreChart))));
    var chart_1 = Internal.applyInteractive(state.Completed ? new List$1() : ofArray$1([new EventHandler("MouseMove", [function (evt) {
      return function (tupledArg) {
        var activePatternResult3651 = CompostHelpers["|Cont|"](tupledArg[0]);
        var activePatternResult3650 = CompostHelpers["|Cont|"](tupledArg[1]);

        if ((~~evt.buttons & 1) === 1) {
          trigger(new YouDrawEvent("Draw", [activePatternResult3651, activePatternResult3650]));
        }
      };
    }]), new EventHandler("TouchMove", [function (evt_1) {
      return function (tupledArg_1) {
        var activePatternResult3655 = CompostHelpers["|Cont|"](tupledArg_1[0]);
        var activePatternResult3654 = CompostHelpers["|Cont|"](tupledArg_1[1]);
        trigger(new YouDrawEvent("Draw", [activePatternResult3655, activePatternResult3654]));
      };
    }]), new EventHandler("MouseDown", [function (evt_2) {
      return function (tupledArg_2) {
        var activePatternResult3659 = CompostHelpers["|Cont|"](tupledArg_2[0]);
        var activePatternResult3658 = CompostHelpers["|Cont|"](tupledArg_2[1]);
        trigger(new YouDrawEvent("Draw", [activePatternResult3659, activePatternResult3658]));
      };
    }]), new EventHandler("TouchStart", [function (evt_3) {
      return function (tupledArg_3) {
        var activePatternResult3663 = CompostHelpers["|Cont|"](tupledArg_3[0]);
        var activePatternResult3662 = CompostHelpers["|Cont|"](tupledArg_3[1]);
        trigger(new YouDrawEvent("Draw", [activePatternResult3663, activePatternResult3662]));
      };
    }])]), patternInput_5.Chart);
    return function (arg0) {
      return function (arg1) {
        return El.op_Dynamic(arg0, arg1);
      };
    }(h$$1)("div")(ofArray$1([op_EqualsGreater("style", "text-align:center;padding-top:20px")]))(ofArray$1([Compost.createSvg(width, height, chart_1), function (arg0_1) {
      return function (arg1_1) {
        return El.op_Dynamic(arg0_1, arg1_1);
      };
    }(h$$1)("div")(ofArray$1([op_EqualsGreater("style", "padding-bottom:20px")]))(ofArray$1([function (arg0_2) {
      return function (arg1_2) {
        return El.op_Dynamic(arg0_2, arg1_2);
      };
    }(h$$1)("button")(toList(delay(function () {
      return append(singleton(op_EqualsGreater("type", "button")), delay(function () {
        return append(singleton(op_EqualsBangGreater("click", function (_arg10) {
          return function (_arg9) {
            trigger(new YouDrawEvent("ShowResults", []));
          };
        })), delay(function () {
          return equals(last(state.Guessed)[1], null) ? singleton(op_EqualsGreater("disabled", "disabled")) : empty();
        }));
      }));
    })))(ofArray$1([text("Show me how I did")]))]))]));
  };

  return __exports;
}({});
var YouGuessColsHelpers = function (__exports) {
  var YouGuessState = __exports.YouGuessState = function () {
    function YouGuessState(completed, completionStep, _default, maximum, xData, yData, data, guesses) {
      _classCallCheck(this, YouGuessState);

      this.Completed = completed;
      this.CompletionStep = completionStep;
      this.Default = _default;
      this.Maximum = maximum;
      this.XData = xData;
      this.YData = yData;
      this.Data = data;
      this.Guesses = guesses;
    }

    _createClass(YouGuessState, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.YouGuessColsHelpers.YouGuessState",
          interfaces: ["FSharpRecord", "System.IEquatable"],
          properties: {
            Completed: "boolean",
            CompletionStep: "number",
            Default: "number",
            Maximum: "number",
            XData: FableArray(Any),
            YData: FableArray(Any),
            Data: FableArray(Tuple(["string", "number"])),
            Guesses: makeGeneric(FableMap, {
              Key: "string",
              Value: "number"
            })
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }]);

    return YouGuessState;
  }();

  setType("TheGamma.Interactive.YouGuessColsHelpers.YouGuessState", YouGuessState);

  var YouGuessEvent = __exports.YouGuessEvent = function () {
    function YouGuessEvent(caseName, fields) {
      _classCallCheck(this, YouGuessEvent);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(YouGuessEvent, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.YouGuessColsHelpers.YouGuessEvent",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            Animate: [],
            ShowResults: [],
            Update: ["string", "number"]
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return YouGuessEvent;
  }();

  setType("TheGamma.Interactive.YouGuessColsHelpers.YouGuessEvent", YouGuessEvent);

  var initState = __exports.initState = function (isBar, data, maxValue$$1) {
    var Completed = false;
    var CompletionStep = 0;
    var XData = isBar ? Internal.arrayMap(function ($var47) {
      return $var47[1];
    }, data) : Internal.arrayMap(function ($var48) {
      return $var48[0];
    }, data);
    var YData = isBar ? Internal.arrayMap(function ($var49) {
      return $var49[0];
    }, data) : Internal.arrayMap(function ($var50) {
      return $var50[1];
    }, data);
    return new YouGuessState(Completed, CompletionStep, averageBy(function (tuple) {
      return tuple[1];
    }, data), InteractiveHelpers.calclateMax(maxValue$$1, data), XData, YData, data, create$6(null, new GenericComparer(compare)));
  };

  var update = __exports.update = function (log, state, evt) {
    var collectData = function collectData() {
      return state.Data.map(function (tupledArg) {
        return [tupledArg[0], tupledArg[1]];
      });
    };

    var collectGuesses = function collectGuesses() {
      return _Array$from(map$3(function (_arg1) {
        var activePatternResult3715 = _arg1;
        return [activePatternResult3715[0], activePatternResult3715[1]];
      }, state.Guesses));
    };

    if (evt.Case === "Animate") {
      var CompletionStep = 1 < state.CompletionStep + 0.05 ? 1 : state.CompletionStep + 0.05;
      return new YouGuessState(state.Completed, CompletionStep, state.Default, state.Maximum, state.XData, state.YData, state.Data, state.Guesses);
    } else if (evt.Case === "Update") {
      var Guesses = add$3(evt.Fields[0], evt.Fields[1], state.Guesses);
      return new YouGuessState(state.Completed, state.CompletionStep, state.Default, state.Maximum, state.XData, state.YData, state.Data, Guesses);
    } else {
      log("completed")(ofArray$1([["guess", collectGuesses(null)], ["values", collectData(null)]]));
      return new YouGuessState(true, state.CompletionStep, state.Default, state.Maximum, state.XData, state.YData, state.Data, state.Guesses);
    }
  };

  var renderCols = __exports.renderCols = function (width, height, topLabel, trigger, state) {
    if (state.Completed ? state.CompletionStep < 1 : false) {
      window.setTimeout(function () {
        trigger(new YouGuessEvent("Animate", []));
      }, 50);
    }

    var chart = new Shape("Axes", [true, true, new Shape("AutoScale", [false, true, new Shape("Interactive", [state.Completed ? new List$1() : ofArray$1([new EventHandler("MouseMove", [function (evt) {
      return function (tupledArg) {
        var activePatternResult3723 = CompostHelpers["|Cat|"](tupledArg[0]);
        var activePatternResult3722 = CompostHelpers["|Cont|"](tupledArg[1]);

        if ((~~evt.buttons & 1) === 1) {
          trigger(new YouGuessEvent("Update", [activePatternResult3723[0], activePatternResult3722]));
        }
      };
    }]), new EventHandler("MouseDown", [function (evt_1) {
      return function (tupledArg_1) {
        var activePatternResult3727 = CompostHelpers["|Cat|"](tupledArg_1[0]);
        var activePatternResult3726 = CompostHelpers["|Cont|"](tupledArg_1[1]);
        trigger(new YouGuessEvent("Update", [activePatternResult3727[0], activePatternResult3726]));
      };
    }]), new EventHandler("TouchStart", [function (evt_2) {
      return function (tupledArg_2) {
        var activePatternResult3731 = CompostHelpers["|Cat|"](tupledArg_2[0]);
        var activePatternResult3730 = CompostHelpers["|Cont|"](tupledArg_2[1]);
        trigger(new YouGuessEvent("Update", [activePatternResult3731[0], activePatternResult3730]));
      };
    }]), new EventHandler("TouchMove", [function (evt_3) {
      return function (tupledArg_3) {
        var activePatternResult3735 = CompostHelpers["|Cat|"](tupledArg_3[0]);
        var activePatternResult3734 = CompostHelpers["|Cont|"](tupledArg_3[1]);
        trigger(new YouGuessEvent("Update", [activePatternResult3735[0], activePatternResult3734]));
      };
    }])]), new Shape("Style", [function (s$$1) {
      if (state.Completed) {
        return s$$1;
      } else {
        var Cursor = "row-resize";
        return new Style(s$$1.StrokeColor, s$$1.StrokeWidth, s$$1.StrokeDashArray, s$$1.Fill, s$$1.Animation, s$$1.Font, Cursor, s$$1.FormatAxisXLabel, s$$1.FormatAxisYLabel);
      }
    }, new Shape("Layered", [toList(delay(function () {
      return append(singleton(new Shape("Stack", [new Orientation("Horizontal", []), toList(delay(function () {
        return collect(function (matchValue) {
          var value = matchValue[1][1];
          var lbl = matchValue[1][0];
          return singleton(function () {
            var sh = new Shape("Style", [function (s_1) {
              var Fill = new FillStyle("Solid", [[0.2, new Color("HTML", ["#a0a0a0"])]]);
              return new Style(s_1.StrokeColor, s_1.StrokeWidth, s_1.StrokeDashArray, Fill, s_1.Animation, s_1.Font, s_1.Cursor, s_1.FormatAxisXLabel, s_1.FormatAxisYLabel);
            }, new Shape("Column", [new categorical("CA", [lbl]), new continuous("CO", [state.Maximum])])]);
            return new Shape("Padding", [[0, 10, 0, 10], sh]);
          }());
        }, zip(CompostHelpers.infinitely(CompostHelpers.vega10), state.Data));
      }))])), delay(function () {
        return append(singleton(new Shape("Stack", [new Orientation("Horizontal", []), toList(delay(function () {
          return collect(function (matchValue_1) {
            var value_1 = matchValue_1[1][1];
            var lbl_1 = matchValue_1[1][0];
            return singleton(function () {
              var patternInput = void 0;
              var matchValue_2 = [state.Completed, tryFind$1(lbl_1, state.Guesses)];
              var $var51 = matchValue_2[0] ? matchValue_2[1] == null ? [2] : [0] : matchValue_2[1] == null ? [2] : [1];

              switch ($var51[0]) {
                case 0:
                  var guess = matchValue_2[1];
                  patternInput = [0.6, state.CompletionStep * value_1 + (1 - state.CompletionStep) * guess];
                  break;

                case 1:
                  var v = matchValue_2[1];
                  patternInput = [0.6, v];
                  break;

                case 2:
                  patternInput = [0.2, state.Default];
                  break;
              }

              var sh_1 = new Shape("Style", [function (s_2) {
                var Fill_1 = new FillStyle("Solid", [[patternInput[0], new Color("HTML", [matchValue_1[0]])]]);
                return new Style(s_2.StrokeColor, s_2.StrokeWidth, s_2.StrokeDashArray, Fill_1, s_2.Animation, s_2.Font, s_2.Cursor, s_2.FormatAxisXLabel, s_2.FormatAxisYLabel);
              }, new Shape("Column", [new categorical("CA", [lbl_1]), new continuous("CO", [patternInput[1]])])]);
              return new Shape("Padding", [[0, 10, 0, 10], sh_1]);
            }());
          }, zip(CompostHelpers.infinitely(CompostHelpers.vega10), state.Data));
        }))])), delay(function () {
          return append(collect(function (matchValue_3) {
            var value_2 = matchValue_3[1][1];
            var lbl_2 = matchValue_3[1][0];
            var matchValue_4 = tryFind$1(lbl_2, state.Guesses);

            if (matchValue_4 != null) {
              var line = new Shape("Line", [ofArray$1([[new Value("CAR", [new categorical("CA", [lbl_2]), 0]), new Value("COV", [new continuous("CO", [matchValue_4])])], [new Value("CAR", [new categorical("CA", [lbl_2]), 1]), new Value("COV", [new continuous("CO", [matchValue_4])])]])]);
              return singleton(new Shape("Style", [function (s_3) {
                return new Style([1, new Color("HTML", [matchValue_3[0]])], new Width("Pixels", [4]), ofArray$1([new _Number("Integer", [5]), new _Number("Integer", [5])]), s_3.Fill, s_3.Animation, s_3.Font, s_3.Cursor, s_3.FormatAxisXLabel, s_3.FormatAxisYLabel);
              }, new Shape("Padding", [[0, 10, 0, 10], line])]));
            } else {
              return empty();
            }
          }, zip(CompostHelpers.infinitely(CompostHelpers.vega10), state.Data)), delay(function () {
            if (topLabel != null) {
              var x = new Value("CAR", [new categorical("CA", [state.Data[~~(state.Data.length / 2)][0]]), state.Data.length % 2 === 0 ? 0 : 0.5]);
              var y = new Value("COV", [new continuous("CO", [state.Maximum * 0.9])]);
              return singleton(new Shape("Style", [function (s_4) {
                var Font = "13pt Roboto,sans-serif";
                var Fill_2 = new FillStyle("Solid", [[1, new Color("HTML", ["#808080"])]]);
                return new Style([0, new Color("RGB", [0, 0, 0])], s_4.StrokeWidth, s_4.StrokeDashArray, Fill_2, s_4.Animation, Font, s_4.Cursor, s_4.FormatAxisXLabel, s_4.FormatAxisYLabel);
              }, new Shape("Text", [x, y, new VerticalAlign("Baseline", []), new HorizontalAlign("Center", []), 0, topLabel])]));
            } else {
              return empty();
            }
          }));
        }));
      }));
    }))])])])])]);
    return function (arg0) {
      return function (arg1) {
        return El.op_Dynamic(arg0, arg1);
      };
    }(h$$1)("div")(ofArray$1([op_EqualsGreater("style", "text-align:center;padding-top:20px")]))(ofArray$1([Compost.createSvg(width, height, chart), function (arg0_1) {
      return function (arg1_1) {
        return El.op_Dynamic(arg0_1, arg1_1);
      };
    }(h$$1)("div")(ofArray$1([op_EqualsGreater("style", "padding-bottom:20px")]))(ofArray$1([function (arg0_2) {
      return function (arg1_2) {
        return El.op_Dynamic(arg0_2, arg1_2);
      };
    }(h$$1)("button")(toList(delay(function () {
      return append(singleton(op_EqualsGreater("type", "button")), delay(function () {
        return append(singleton(op_EqualsBangGreater("click", function (_arg10) {
          return function (_arg9) {
            trigger(new YouGuessEvent("ShowResults", []));
          };
        })), delay(function () {
          return state.Guesses.size !== state.Data.length ? singleton(op_EqualsGreater("disabled", "disabled")) : empty();
        }));
      }));
    })))(ofArray$1([text("Show me how I did")]))]))]));
  };

  var renderBars = __exports.renderBars = function (inlineLabels, size_0, size_1, chartOptions, trigger, state) {
    var size = [size_0, size_1];

    if (state.Completed ? state.CompletionStep < 1 : false) {
      window.setTimeout(function () {
        trigger(new YouGuessEvent("Animate", []));
      }, 50);
    }

    var chartOptions_1 = void 0;

    if (inlineLabels ? function () {
      return chartOptions.yAxis.labelOffset == null;
    }(null) : false) {
      var yAxis = void 0;
      var labelOffset = 10;
      yAxis = new AxisOptions(chartOptions.yAxis.minValue, chartOptions.yAxis.maxValue, chartOptions.yAxis.label, labelOffset);
      chartOptions_1 = new ChartOptions(chartOptions.size, chartOptions.xAxis, yAxis, chartOptions.title, chartOptions.legend);
    } else {
      chartOptions_1 = chartOptions;
    }

    var chart = Internal.applyStyle(function (s$$1) {
      if (state.Completed) {
        return s$$1;
      } else {
        var Cursor = "col-resize";
        return new Style(s$$1.StrokeColor, s$$1.StrokeWidth, s$$1.StrokeDashArray, s$$1.Fill, s$$1.Animation, s$$1.Font, Cursor, s$$1.FormatAxisXLabel, s$$1.FormatAxisYLabel);
      }
    }, Internal.applyInteractive(state.Completed ? new List$1() : ofArray$1([new EventHandler("MouseMove", [function (evt) {
      return function (tupledArg) {
        var activePatternResult3786 = CompostHelpers["|Cont|"](tupledArg[0]);
        var activePatternResult3785 = CompostHelpers["|Cat|"](tupledArg[1]);

        if ((~~evt.buttons & 1) === 1) {
          trigger(new YouGuessEvent("Update", [activePatternResult3785[0], activePatternResult3786]));
        }
      };
    }]), new EventHandler("MouseDown", [function (evt_1) {
      return function (tupledArg_1) {
        var activePatternResult3790 = CompostHelpers["|Cont|"](tupledArg_1[0]);
        var activePatternResult3789 = CompostHelpers["|Cat|"](tupledArg_1[1]);
        trigger(new YouGuessEvent("Update", [activePatternResult3789[0], activePatternResult3790]));
      };
    }]), new EventHandler("TouchStart", [function (evt_2) {
      return function (tupledArg_2) {
        var activePatternResult3794 = CompostHelpers["|Cont|"](tupledArg_2[0]);
        var activePatternResult3793 = CompostHelpers["|Cat|"](tupledArg_2[1]);
        trigger(new YouGuessEvent("Update", [activePatternResult3793[0], activePatternResult3794]));
      };
    }]), new EventHandler("TouchMove", [function (evt_3) {
      return function (tupledArg_3) {
        var activePatternResult3798 = CompostHelpers["|Cont|"](tupledArg_3[0]);
        var activePatternResult3797 = CompostHelpers["|Cat|"](tupledArg_3[1]);
        trigger(new YouGuessEvent("Update", [activePatternResult3797[0], activePatternResult3798]));
      };
    }])]), new Shape("Layered", [toList(delay(function () {
      return append(singleton(new Shape("Stack", [new Orientation("Vertical", []), toList(delay(function () {
        return collect(function (matchValue) {
          var value = matchValue[1][1];
          var lbl = matchValue[1][0];
          return singleton(function () {
            var sh = new Shape("Style", [function (s_1) {
              var Fill = new FillStyle("Solid", [[0.2, new Color("HTML", ["#a0a0a0"])]]);
              return new Style(s_1.StrokeColor, s_1.StrokeWidth, s_1.StrokeDashArray, Fill, s_1.Animation, s_1.Font, s_1.Cursor, s_1.FormatAxisXLabel, s_1.FormatAxisYLabel);
            }, new Shape("Bar", [new continuous("CO", [state.Maximum]), new categorical("CA", [lbl])])]);
            return new Shape("Padding", [[10, 0, 10, 0], sh]);
          }());
        }, zip(CompostHelpers.infinitely(CompostHelpers.vega10), state.Data));
      }))])), delay(function () {
        return append(singleton(new Shape("Stack", [new Orientation("Vertical", []), toList(delay(function () {
          return collect(function (matchValue_1) {
            var value_1 = matchValue_1[1][1];
            var lbl_1 = matchValue_1[1][0];
            return singleton(function () {
              var patternInput = void 0;
              var matchValue_2 = [state.Completed, tryFind$1(lbl_1, state.Guesses)];
              var $var52 = matchValue_2[0] ? matchValue_2[1] == null ? [2] : [0] : matchValue_2[1] == null ? [2] : [1];

              switch ($var52[0]) {
                case 0:
                  var guess = matchValue_2[1];
                  patternInput = [0.6, state.CompletionStep * value_1 + (1 - state.CompletionStep) * guess];
                  break;

                case 1:
                  var v = matchValue_2[1];
                  patternInput = [0.6, v];
                  break;

                case 2:
                  patternInput = [0.2, state.Default];
                  break;
              }

              var sh_1 = new Shape("Style", [function (s_2) {
                var Fill_1 = new FillStyle("Solid", [[patternInput[0], new Color("HTML", [matchValue_1[0]])]]);
                return new Style(s_2.StrokeColor, s_2.StrokeWidth, s_2.StrokeDashArray, Fill_1, s_2.Animation, s_2.Font, s_2.Cursor, s_2.FormatAxisXLabel, s_2.FormatAxisYLabel);
              }, new Shape("Bar", [new continuous("CO", [patternInput[1]]), new categorical("CA", [lbl_1])])]);
              return new Shape("Padding", [[10, 0, 10, 0], sh_1]);
            }());
          }, zip(CompostHelpers.infinitely(CompostHelpers.vega10), state.Data));
        }))])), delay(function () {
          return append(inlineLabels ? collect(function (matchValue_3) {
            var lbl_2 = matchValue_3[1][0];
            var x = new Value("COV", [new continuous("CO", [state.Maximum * 0.95])]);
            var y = new Value("CAR", [new categorical("CA", [lbl_2]), 0.5]);
            return singleton(new Shape("Style", [function (s_3) {
              var Font = "13pt Roboto,sans-serif";
              var Fill_2 = new FillStyle("Solid", [[1, new Color("HTML", [matchValue_3[0]])]]);
              return new Style([0, new Color("RGB", [0, 0, 0])], s_3.StrokeWidth, s_3.StrokeDashArray, Fill_2, s_3.Animation, Font, s_3.Cursor, s_3.FormatAxisXLabel, s_3.FormatAxisYLabel);
            }, new Shape("Text", [x, y, new VerticalAlign("Middle", []), new HorizontalAlign("End", []), 0, lbl_2])]));
          }, zip(CompostHelpers.infinitely(CompostHelpers.vega10), state.Data)) : empty(), delay(function () {
            return collect(function (matchValue_4) {
              var value_2 = matchValue_4[1][1];
              var lbl_3 = matchValue_4[1][0];
              var matchValue_5 = tryFind$1(lbl_3, state.Guesses);

              if (matchValue_5 != null) {
                var line = new Shape("Line", [ofArray$1([[new Value("COV", [new continuous("CO", [matchValue_5])]), new Value("CAR", [new categorical("CA", [lbl_3]), 0])], [new Value("COV", [new continuous("CO", [matchValue_5])]), new Value("CAR", [new categorical("CA", [lbl_3]), 1])]])]);
                return singleton(new Shape("Style", [function (s_4) {
                  return new Style([1, new Color("HTML", [matchValue_4[0]])], new Width("Pixels", [4]), ofArray$1([new _Number("Integer", [5]), new _Number("Integer", [5])]), s_4.Fill, s_4.Animation, s_4.Font, s_4.Cursor, s_4.FormatAxisXLabel, s_4.FormatAxisYLabel);
                }, new Shape("Padding", [[10, 0, 10, 0], line])]));
              } else {
                return empty();
              }
            }, zip(CompostHelpers.infinitely(CompostHelpers.vega10), state.Data));
          }));
        }));
      }));
    }))])));

    var ctx_1 = function () {
      var labels = zip(CompostHelpers.infinitely(CompostHelpers.vega10), map$3(function (tuple) {
        return tuple[0];
      }, state.Data));
      return function (ctx) {
        return Internal.applyLegend(size[0], size[1], labels, ctx);
      };
    }()(Internal.applyAxes(true, !inlineLabels, Internal.applyLabels(Internal.applyScales(function (chart_1) {
      return Internal.initChart(state.XData, state.YData, chartOptions_1, chart_1);
    }(chart)))));

    return function (arg0) {
      return function (arg1) {
        return El.op_Dynamic(arg0, arg1);
      };
    }(h$$1)("div")(ofArray$1([op_EqualsGreater("style", "text-align:center;padding-top:20px")]))(ofArray$1([Compost.createSvg(size[0], size[1], ctx_1.Chart), function (arg0_1) {
      return function (arg1_1) {
        return El.op_Dynamic(arg0_1, arg1_1);
      };
    }(h$$1)("div")(ofArray$1([op_EqualsGreater("style", "padding-bottom:20px")]))(ofArray$1([function (arg0_2) {
      return function (arg1_2) {
        return El.op_Dynamic(arg0_2, arg1_2);
      };
    }(h$$1)("button")(toList(delay(function () {
      return append(singleton(op_EqualsGreater("type", "button")), delay(function () {
        return append(singleton(op_EqualsBangGreater("click", function (_arg10) {
          return function (_arg9) {
            trigger(new YouGuessEvent("ShowResults", []));
          };
        })), delay(function () {
          return state.Guesses.size !== state.Data.length ? singleton(op_EqualsGreater("disabled", "disabled")) : empty();
        }));
      }));
    })))(ofArray$1([text("Show me how I did")]))]))]));
  };

  return __exports;
}({});
var YouGuessSortHelpers = function (__exports) {
  var YouGuessState = __exports.YouGuessState = function () {
    function YouGuessState(data, colors, assignments, selected, maximum, completionStep, completed) {
      _classCallCheck(this, YouGuessState);

      this.Data = data;
      this.Colors = colors;
      this.Assignments = assignments;
      this.Selected = selected;
      this.Maximum = maximum;
      this.CompletionStep = completionStep;
      this.Completed = completed;
    }

    _createClass(YouGuessState, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.YouGuessSortHelpers.YouGuessState",
          interfaces: ["FSharpRecord", "System.IEquatable"],
          properties: {
            Data: FableArray(Tuple(["string", "number"])),
            Colors: Interface("System.Collections.Generic.IDictionary"),
            Assignments: makeGeneric(FableMap, {
              Key: "string",
              Value: "string"
            }),
            Selected: "string",
            Maximum: "number",
            CompletionStep: "number",
            Completed: "boolean"
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsRecords(this, other);
      }
    }]);

    return YouGuessState;
  }();

  setType("TheGamma.Interactive.YouGuessSortHelpers.YouGuessState", YouGuessState);

  var YouGuessEvent = __exports.YouGuessEvent = function () {
    function YouGuessEvent(caseName, fields) {
      _classCallCheck(this, YouGuessEvent);

      this.Case = caseName;
      this.Fields = fields;
    }

    _createClass(YouGuessEvent, [{
      key: _Symbol.reflection,
      value: function () {
        return {
          type: "TheGamma.Interactive.YouGuessSortHelpers.YouGuessEvent",
          interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
          cases: {
            Animate: [],
            AssignCurrent: ["string"],
            SelectItem: ["string"],
            ShowResults: []
          }
        };
      }
    }, {
      key: "Equals",
      value: function (other) {
        return equalsUnions(this, other);
      }
    }, {
      key: "CompareTo",
      value: function (other) {
        return compareUnions(this, other);
      }
    }]);

    return YouGuessEvent;
  }();

  setType("TheGamma.Interactive.YouGuessSortHelpers.YouGuessEvent", YouGuessEvent);

  var initState = __exports.initState = function (maxValue$$1, data) {
    var CompletionStep = 0;
    var Completed = false;
    return new YouGuessState(data, new _Map(map2(function (tupledArg, clr) {
      return [tupledArg[0], clr];
    }, data, CompostHelpers.vega10)), create$6(null, new GenericComparer(compare)), head(data)[0], InteractiveHelpers.calclateMax(maxValue$$1, data), CompletionStep, Completed);
  };

  var update = __exports.update = function (log, state, evt) {
    var collectData = function collectData() {
      return state.Data.map(function (tupledArg) {
        return [tupledArg[0], tupledArg[1]];
      });
    };

    var collectGuesses = function collectGuesses() {
      return _Array$from(map$3(function (_arg2) {
        var activePatternResult3851 = _arg2;
        var i = findIndex(function (tupledArg_1) {
          return tupledArg_1[0] === activePatternResult3851[0];
        }, state.Data);
        return [activePatternResult3851[1], i];
      }, state.Assignments));
    };

    if (evt.Case === "ShowResults") {
      log("completed")(ofArray$1([["values", collectData(null)], ["guess", collectGuesses(null)]]));
      var Completed = true;
      return new YouGuessState(state.Data, state.Colors, state.Assignments, state.Selected, state.Maximum, state.CompletionStep, Completed);
    } else if (evt.Case === "SelectItem") {
      log("select")(ofArray$1([["selection", evt.Fields[0]]]));
      return new YouGuessState(state.Data, state.Colors, state.Assignments, evt.Fields[0], state.Maximum, state.CompletionStep, state.Completed);
    } else if (evt.Case === "AssignCurrent") {
      var newAssigns = function (table) {
        return add$3(evt.Fields[0], state.Selected, table);
      }(filter$3(function (_arg3, v) {
        return v !== state.Selected;
      }, state.Assignments));

      var assigned = create$5(map$3(function (kvp) {
        return kvp[1];
      }, newAssigns), new GenericComparer(compare));
      var newSelected = tryHead(filter(function ($var53) {
        return function (value) {
          return !value;
        }(function (arg00) {
          return assigned.has(arg00);
        }($var53));
      }, map$3(function (tuple) {
        return tuple[0];
      }, state.Data)));
      var Selected = newSelected != null ? newSelected : state.Selected;
      return new YouGuessState(state.Data, state.Colors, newAssigns, Selected, state.Maximum, state.CompletionStep, state.Completed);
    } else {
      var CompletionStep = 1 < state.CompletionStep + 0.05 ? 1 : state.CompletionStep + 0.05;
      return new YouGuessState(state.Data, state.Colors, state.Assignments, state.Selected, state.Maximum, CompletionStep, state.Completed);
    }
  };

  var renderBars = __exports.renderBars = function (width, height, trigger, state) {
    if (state.Completed ? state.CompletionStep < 1 : false) {
      window.setTimeout(function () {
        trigger(new YouGuessEvent("Animate", []));
      }, 50);
    }

    var chart = new Shape("Axes", [true, false, new Shape("AutoScale", [true, false, new Shape("Interactive", [state.Completed ? new List$1() : ofArray$1([new EventHandler("MouseDown", [function (evt) {
      return function (tupledArg) {
        var activePatternResult3862 = CompostHelpers["|Cat|"](tupledArg[1]);
        trigger(new YouGuessEvent("AssignCurrent", [activePatternResult3862[0]]));
      };
    }]), new EventHandler("TouchStart", [function (evt_1) {
      return function (tupledArg_1) {
        var activePatternResult3865 = CompostHelpers["|Cat|"](tupledArg_1[1]);
        trigger(new YouGuessEvent("AssignCurrent", [activePatternResult3865[0]]));
      };
    }]), new EventHandler("TouchMove", [function (evt_2) {
      return function (tupledArg_2) {
        var activePatternResult3868 = CompostHelpers["|Cat|"](tupledArg_2[1]);
        trigger(new YouGuessEvent("AssignCurrent", [activePatternResult3868[0]]));
      };
    }])]), new Shape("Style", [function (s$$1) {
      if (state.Completed) {
        return s$$1;
      } else {
        var Cursor = "pointer";
        return new Style(s$$1.StrokeColor, s$$1.StrokeWidth, s$$1.StrokeDashArray, s$$1.Fill, s$$1.Animation, s$$1.Font, Cursor, s$$1.FormatAxisXLabel, s$$1.FormatAxisYLabel);
      }
    }, new Shape("Layered", [toList(delay(function () {
      return singleton(new Shape("Stack", [new Orientation("Vertical", []), toList(delay(function () {
        return collect(function (matchValue) {
          var original = matchValue[1][1];
          var lbl = matchValue[1][0];
          var patternInput_1 = void 0;
          var matchValue_1 = [state.Completed, tryFind$1(lbl, state.Assignments)];
          var $var54 = matchValue_1[0] ? matchValue_1[1] == null ? [2] : [0] : matchValue_1[1] == null ? [2] : [1];

          (function () {
            switch ($var54[0]) {
              case 0:
                var assigned = matchValue_1[1];
                var patternInput = find(function (tupledArg_3) {
                  return tupledArg_3[0] === assigned;
                }, state.Data);
                patternInput_1 = [0.6, state.CompletionStep * patternInput[1] + (1 - state.CompletionStep) * original, state.Colors.get(assigned)];
                break;

              case 1:
                var assigned_1 = matchValue_1[1];
                patternInput_1 = [0.6, original, state.Colors.get(assigned_1)];
                break;

              case 2:
                patternInput_1 = [0.3, original, "#a0a0a0"];
                break;
            }
          })();

          return append((matchValue[0] === state.Data.length - 1 ? state.Assignments.size === 0 : false) ? function () {
            var txt = new Shape("Text", [new Value("COV", [new continuous("CO", [state.Maximum * 0.05])]), new Value("CAR", [new categorical("CA", [lbl]), 0.5]), new VerticalAlign("Middle", []), new HorizontalAlign("Start", []), 0, "Assign highlighted value to one of the bars by clicking on it!"]);
            return singleton(new Shape("Style", [function (s_1) {
              var Font = "13pt Roboto,sans-serif";
              var Fill = new FillStyle("Solid", [[1, new Color("HTML", ["#606060"])]]);
              return new Style([0, new Color("HTML", ["white"])], s_1.StrokeWidth, s_1.StrokeDashArray, Fill, s_1.Animation, Font, s_1.Cursor, s_1.FormatAxisXLabel, s_1.FormatAxisYLabel);
            }, txt]));
          }() : empty(), delay(function () {
            var sh = new Shape("Style", [function (s_2) {
              var Fill_1 = new FillStyle("Solid", [[patternInput_1[0], new Color("HTML", [patternInput_1[2]])]]);
              return new Style(s_2.StrokeColor, s_2.StrokeWidth, s_2.StrokeDashArray, Fill_1, s_2.Animation, s_2.Font, s_2.Cursor, s_2.FormatAxisXLabel, s_2.FormatAxisYLabel);
            }, new Shape("Bar", [new continuous("CO", [patternInput_1[1]]), new categorical("CA", [lbl])])]);
            return append(patternInput_1[2] !== "#a0a0a0" ? function () {
              var line = new Shape("Line", [ofArray$1([[new Value("COV", [new continuous("CO", [original])]), new Value("CAR", [new categorical("CA", [lbl]), 0])], [new Value("COV", [new continuous("CO", [original])]), new Value("CAR", [new categorical("CA", [lbl]), 1])]])]);
              return singleton(new Shape("Style", [function (s_3) {
                return new Style([1, new Color("HTML", [patternInput_1[2]])], new Width("Pixels", [4]), ofArray$1([new _Number("Integer", [5]), new _Number("Integer", [5])]), s_3.Fill, s_3.Animation, s_3.Font, s_3.Cursor, s_3.FormatAxisXLabel, s_3.FormatAxisYLabel);
              }, new Shape("Padding", [[5, 0, 5, 0], line])]));
            }() : empty(), delay(function () {
              return singleton(new Shape("Padding", [[5, 0, 5, 0], sh]));
            }));
          }));
        }, mapIndexed(function (i, v) {
          return [i, v];
        }, sortWith(function (x, y) {
          return compare(function (tuple) {
            return tuple[1];
          }(x), function (tuple) {
            return tuple[1];
          }(y));
        }, state.Data)));
      }))]));
    }))])])])])]);
    var labs = new Shape("Padding", [[0, 20, 20, 25], new Shape("InnerScale", [[new continuous("CO", [0]), new continuous("CO", [100])], null, new Shape("Interactive", [state.Completed ? new List$1() : ofArray$1([new EventHandler("MouseDown", [function (evt_3) {
      return function (tupledArg_4) {
        var activePatternResult3884 = CompostHelpers["|Cat|"](tupledArg_4[1]);
        trigger(new YouGuessEvent("SelectItem", [activePatternResult3884[0]]));
      };
    }]), new EventHandler("TouchStart", [function (evt_4) {
      return function (tupledArg_5) {
        var activePatternResult3887 = CompostHelpers["|Cat|"](tupledArg_5[1]);
        trigger(new YouGuessEvent("SelectItem", [activePatternResult3887[0]]));
      };
    }]), new EventHandler("TouchMove", [function (evt_5) {
      return function (tupledArg_6) {
        var activePatternResult3890 = CompostHelpers["|Cat|"](tupledArg_6[1]);
        trigger(new YouGuessEvent("SelectItem", [activePatternResult3890[0]]));
      };
    }])]), new Shape("Layered", [toList(delay(function () {
      return collect(function (matchValue_2) {
        var clr = state.Colors.get(matchValue_2[0]);
        var x = new Value("COV", [new continuous("CO", [5])]);
        var y = new Value("CAR", [new categorical("CA", [matchValue_2[0]]), 0.5]);
        var patternInput_2 = (state.Completed ? true : matchValue_2[0] === state.Selected) ? [0.9, 1] : [0.2, 0.6];
        return append(singleton(new Shape("Style", [function (s_4) {
          var Fill_2 = new FillStyle("Solid", [[patternInput_2[0], new Color("HTML", [clr])]]);
          return new Style(s_4.StrokeColor, s_4.StrokeWidth, s_4.StrokeDashArray, Fill_2, s_4.Animation, s_4.Font, s_4.Cursor, s_4.FormatAxisXLabel, s_4.FormatAxisYLabel);
        }, new Shape("Padding", [[2, 0, 2, 0], new Shape("Bar", [new continuous("CO", [4]), new categorical("CA", [matchValue_2[0]])])])])), delay(function () {
          return append(singleton(new Shape("Style", [function (s_5) {
            var Font_1 = "11pt Roboto,sans-serif";
            var Fill_3 = new FillStyle("Solid", [[patternInput_2[1], new Color("HTML", [clr])]]);
            return new Style([0, new Color("RGB", [0, 0, 0])], s_5.StrokeWidth, s_5.StrokeDashArray, Fill_3, s_5.Animation, Font_1, s_5.Cursor, s_5.FormatAxisXLabel, s_5.FormatAxisYLabel);
          }, new Shape("Text", [x, y, new VerticalAlign("Middle", []), new HorizontalAlign("Start", []), 0, matchValue_2[0]])])), delay(function () {
            return !state.Completed ? singleton(new Shape("Style", [function (s_6) {
              var Cursor_1 = "pointer";
              var Fill_4 = new FillStyle("Solid", [[0, new Color("HTML", ["white"])]]);
              return new Style(s_6.StrokeColor, s_6.StrokeWidth, s_6.StrokeDashArray, Fill_4, s_6.Animation, s_6.Font, Cursor_1, s_6.FormatAxisXLabel, s_6.FormatAxisYLabel);
            }, new Shape("Bar", [new continuous("CO", [100]), new categorical("CA", [matchValue_2[0]])])])) : empty();
          }));
        }));
      }, reverse(state.Data));
    }))])])])]);
    var all = new Shape("Layered", [ofArray$1([new Shape("OuterScale", [null, new Scale("Continuous", [new continuous("CO", [0]), new continuous("CO", [3])]), labs]), new Shape("OuterScale", [null, new Scale("Continuous", [new continuous("CO", [3]), new continuous("CO", [10])]), new Shape("Padding", [[0, 20, 0, 20], chart])])])]);
    return function (arg0) {
      return function (arg1) {
        return El.op_Dynamic(arg0, arg1);
      };
    }(h$$1)("div")(ofArray$1([op_EqualsGreater("style", "text-align:center;padding-top:20px")]))(ofArray$1([Compost.createSvg(width, height, all), function (arg0_1) {
      return function (arg1_1) {
        return El.op_Dynamic(arg0_1, arg1_1);
      };
    }(h$$1)("div")(ofArray$1([op_EqualsGreater("style", "padding-bottom:20px")]))(ofArray$1([function (arg0_2) {
      return function (arg1_2) {
        return El.op_Dynamic(arg0_2, arg1_2);
      };
    }(h$$1)("button")(toList(delay(function () {
      return append(singleton(op_EqualsGreater("type", "button")), delay(function () {
        return append(singleton(op_EqualsBangGreater("click", function (_arg15) {
          return function (_arg14) {
            trigger(new YouGuessEvent("ShowResults", []));
          };
        })), delay(function () {
          return state.Assignments.size !== state.Data.length ? singleton(op_EqualsGreater("disabled", "disabled")) : empty();
        }));
      }));
    })))(ofArray$1([text("Show me how I did")]))]))]));
  };

  return __exports;
}({});
var YouGuessColsBarsKind = function () {
  function YouGuessColsBarsKind(caseName, fields) {
    _classCallCheck(this, YouGuessColsBarsKind);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(YouGuessColsBarsKind, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.YouGuessColsBarsKind",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Bars: [],
          Cols: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return YouGuessColsBarsKind;
}();
setType("TheGamma.Interactive.YouGuessColsBarsKind", YouGuessColsBarsKind);
var YouGuessColsBars = function () {
  function YouGuessColsBars(kind$$1, data, logger, options) {
    _classCallCheck(this, YouGuessColsBars);

    this.kind = kind$$1;
    this.data = data;
    this.logger = logger;
    this.options = options;
  }

  _createClass(YouGuessColsBars, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.YouGuessColsBars",
        interfaces: ["FSharpRecord"],
        properties: {
          kind: YouGuessColsBarsKind,
          data: makeGeneric(series, {
            k: "string",
            v: "number"
          }),
          logger: Option("function"),
          options: ChartOptions
        }
      };
    }
  }, {
    key: "setTitle",
    value: function (title) {
      var options = new ChartOptions(this.options.size, this.options.xAxis, this.options.yAxis, title, this.options.legend);
      return new YouGuessColsBars(this.kind, this.data, this.logger, options);
    }
  }, {
    key: "setLegend",
    value: function (position) {
      var options = void 0;
      var legend = new LegendOptions(position);
      options = new ChartOptions(this.options.size, this.options.xAxis, this.options.yAxis, this.options.title, legend);
      return new YouGuessColsBars(this.kind, this.data, this.logger, options);
    }
  }, {
    key: "setSize",
    value: function (width, height) {
      var options = new ChartOptions([CompostHelpers.orElse(width, this.options.size[0]), CompostHelpers.orElse(height, this.options.size[1])], this.options.xAxis, this.options.yAxis, this.options.title, this.options.legend);
      return new YouGuessColsBars(this.kind, this.data, this.logger, options);
    }
  }, {
    key: "setAxisX",
    value: function (minValue$$1, maxValue$$1, label, labelOffset) {
      var ax = void 0;
      var inputRecord = this.options.xAxis;
      ax = new AxisOptions(CompostHelpers.orElse(minValue$$1, this.options.xAxis.minValue), CompostHelpers.orElse(maxValue$$1, this.options.xAxis.maxValue), CompostHelpers.orElse(label, this.options.xAxis.label), CompostHelpers.orElse(labelOffset, this.options.xAxis.labelOffset));
      var options = new ChartOptions(this.options.size, ax, this.options.yAxis, this.options.title, this.options.legend);
      return new YouGuessColsBars(this.kind, this.data, this.logger, options);
    }
  }, {
    key: "setAxisY",
    value: function (minValue$$1, maxValue$$1, label, labelOffset) {
      var ax = void 0;
      var inputRecord = this.options.yAxis;
      ax = new AxisOptions(CompostHelpers.orElse(minValue$$1, this.options.yAxis.minValue), CompostHelpers.orElse(maxValue$$1, this.options.yAxis.maxValue), CompostHelpers.orElse(label, this.options.yAxis.label), CompostHelpers.orElse(labelOffset, this.options.yAxis.labelOffset));
      var options = new ChartOptions(this.options.size, this.options.xAxis, ax, this.options.title, this.options.legend);
      return new YouGuessColsBars(this.kind, this.data, this.logger, options);
    }
  }, {
    key: "setLogger",
    value: function (logger) {
      var logger_1 = logger;
      return new YouGuessColsBars(this.kind, this.data, logger_1, this.options);
    }
  }, {
    key: "setLabel",
    value: function (top) {
      return this.setTitle(top);
    }
  }, {
    key: "setMaximum",
    value: function (max$$1) {
      if (this.kind.Equals(new YouGuessColsBarsKind("Bars", []))) {
        return this.setAxisX(null, max$$1);
      } else {
        return this.setAxisY(null, max$$1);
      }
    }
  }, {
    key: "show",
    value: function (outputId) {
      var _this = this;

      var tupledArg = this.options.size;

      var initial = function initial(data) {
        return YouGuessColsHelpers.initState(_this.kind.Equals(new YouGuessColsBarsKind("Bars", [])), data, _this.kind.Equals(new YouGuessColsBarsKind("Bars", [])) ? _this.options.xAxis.maxValue : _this.options.yAxis.maxValue);
      };

      var render$$1 = function render$$1(_arg1) {
        return function (size) {
          if (_this.kind.Case === "Cols") {
            var _ret6 = function () {
              var topLabel = _this.options.title;
              return {
                v: function v(trigger) {
                  return function (state) {
                    return YouGuessColsHelpers.renderCols(size[0], size[1], topLabel, trigger, state);
                  };
                }
              };
            }();

            if ((typeof _ret6 === "undefined" ? "undefined" : _typeof(_ret6)) === "object") return _ret6.v;
          } else {
            var _ret7 = function () {
              var inlineLabels = true;
              return {
                v: function v(trigger_1) {
                  return function (state_1) {
                    return YouGuessColsHelpers.renderBars(inlineLabels, size[0], size[1], _this.options, trigger_1, state_1);
                  };
                }
              };
            }();

            if ((typeof _ret7 === "undefined" ? "undefined" : _typeof(_ret7)) === "object") return _ret7.v;
          }
        };
      };

      var update = function update(_arg2) {
        var log = void 0;
        var clo2 = InteractiveHelpers.createLogger(outputId, _this.logger);

        log = function log(arg20) {
          var clo3 = clo2(arg20);
          return function (arg30) {
            clo3(arg30);
          };
        };

        return function (state_2) {
          return function (evt) {
            return YouGuessColsHelpers.update(log, state_2, evt);
          };
        };
      };

      InteractiveHelpers.showApp(outputId, tupledArg[0], tupledArg[1], this.data, initial, render$$1, update);
    }
  }]);

  return YouGuessColsBars;
}();
setType("TheGamma.Interactive.YouGuessColsBars", YouGuessColsBars);
var YouGuessLine = function () {
  function YouGuessLine(data, markers, clip, markerColor, knownColor, unknownColor, drawColor, knownLabel, guessLabel, logger, options) {
    _classCallCheck(this, YouGuessLine);

    this.data = data;
    this.markers = markers;
    this.clip = clip;
    this.markerColor = markerColor;
    this.knownColor = knownColor;
    this.unknownColor = unknownColor;
    this.drawColor = drawColor;
    this.knownLabel = knownLabel;
    this.guessLabel = guessLabel;
    this.logger = logger;
    this.options = options;
  }

  _createClass(YouGuessLine, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.YouGuessLine",
        interfaces: ["FSharpRecord"],
        properties: {
          data: makeGeneric(series, {
            k: Any,
            v: "number"
          }),
          markers: Option(makeGeneric(series, {
            k: "number",
            v: Any
          })),
          clip: Option("number"),
          markerColor: Option("string"),
          knownColor: Option("string"),
          unknownColor: Option("string"),
          drawColor: Option("string"),
          knownLabel: Option("string"),
          guessLabel: Option("string"),
          logger: Option("function"),
          options: ChartOptions
        }
      };
    }
  }, {
    key: "setTitle",
    value: function (title) {
      var options = new ChartOptions(this.options.size, this.options.xAxis, this.options.yAxis, title, this.options.legend);
      return new YouGuessLine(this.data, this.markers, this.clip, this.markerColor, this.knownColor, this.unknownColor, this.drawColor, this.knownLabel, this.guessLabel, this.logger, options);
    }
  }, {
    key: "setLegend",
    value: function (position) {
      var options = void 0;
      var legend = new LegendOptions(position);
      options = new ChartOptions(this.options.size, this.options.xAxis, this.options.yAxis, this.options.title, legend);
      return new YouGuessLine(this.data, this.markers, this.clip, this.markerColor, this.knownColor, this.unknownColor, this.drawColor, this.knownLabel, this.guessLabel, this.logger, options);
    }
  }, {
    key: "setSize",
    value: function (width, height) {
      var options = new ChartOptions([CompostHelpers.orElse(width, this.options.size[0]), CompostHelpers.orElse(height, this.options.size[1])], this.options.xAxis, this.options.yAxis, this.options.title, this.options.legend);
      return new YouGuessLine(this.data, this.markers, this.clip, this.markerColor, this.knownColor, this.unknownColor, this.drawColor, this.knownLabel, this.guessLabel, this.logger, options);
    }
  }, {
    key: "setAxisX",
    value: function (minValue$$1, maxValue$$1, label, labelOffset) {
      var ax = void 0;
      var inputRecord = this.options.xAxis;
      ax = new AxisOptions(CompostHelpers.orElse(minValue$$1, this.options.xAxis.minValue), CompostHelpers.orElse(maxValue$$1, this.options.xAxis.maxValue), CompostHelpers.orElse(label, this.options.xAxis.label), CompostHelpers.orElse(labelOffset, this.options.xAxis.labelOffset));
      var options = new ChartOptions(this.options.size, ax, this.options.yAxis, this.options.title, this.options.legend);
      return new YouGuessLine(this.data, this.markers, this.clip, this.markerColor, this.knownColor, this.unknownColor, this.drawColor, this.knownLabel, this.guessLabel, this.logger, options);
    }
  }, {
    key: "setAxisY",
    value: function (minValue$$1, maxValue$$1, label, labelOffset) {
      var ax = void 0;
      var inputRecord = this.options.yAxis;
      ax = new AxisOptions(CompostHelpers.orElse(minValue$$1, this.options.yAxis.minValue), CompostHelpers.orElse(maxValue$$1, this.options.yAxis.maxValue), CompostHelpers.orElse(label, this.options.yAxis.label), CompostHelpers.orElse(labelOffset, this.options.yAxis.labelOffset));
      var options = new ChartOptions(this.options.size, this.options.xAxis, ax, this.options.title, this.options.legend);
      return new YouGuessLine(this.data, this.markers, this.clip, this.markerColor, this.knownColor, this.unknownColor, this.drawColor, this.knownLabel, this.guessLabel, this.logger, options);
    }
  }, {
    key: "setLogger",
    value: function (logger) {
      var logger_1 = logger;
      return new YouGuessLine(this.data, this.markers, this.clip, this.markerColor, this.knownColor, this.unknownColor, this.drawColor, this.knownLabel, this.guessLabel, logger_1, this.options);
    }
  }, {
    key: "setRange",
    value: function (min$$1, max$$1) {
      return this.setAxisY(min$$1, max$$1);
    }
  }, {
    key: "setClip",
    value: function (clip) {
      var clip_1 = clip instanceof Date ? clip.getTime() : clip;
      return new YouGuessLine(this.data, this.markers, clip_1, this.markerColor, this.knownColor, this.unknownColor, this.drawColor, this.knownLabel, this.guessLabel, this.logger, this.options);
    }
  }, {
    key: "setColors",
    value: function (known, unknown) {
      var knownColor = known;
      var unknownColor = unknown;
      return new YouGuessLine(this.data, this.markers, this.clip, this.markerColor, knownColor, unknownColor, this.drawColor, this.knownLabel, this.guessLabel, this.logger, this.options);
    }
  }, {
    key: "setDrawColor",
    value: function (draw) {
      var drawColor = draw;
      return new YouGuessLine(this.data, this.markers, this.clip, this.markerColor, this.knownColor, this.unknownColor, drawColor, this.knownLabel, this.guessLabel, this.logger, this.options);
    }
  }, {
    key: "setMarkerColor",
    value: function (marker) {
      var markerColor = marker;
      return new YouGuessLine(this.data, this.markers, this.clip, markerColor, this.knownColor, this.unknownColor, this.drawColor, this.knownLabel, this.guessLabel, this.logger, this.options);
    }
  }, {
    key: "setLabels",
    value: function (top, known, guess) {
      var knownLabel = CompostHelpers.orElse(known, this.knownLabel);
      var guessLabel = CompostHelpers.orElse(guess, this.guessLabel);
      var options = void 0;
      var title = CompostHelpers.orElse(top, this.options.title);
      options = new ChartOptions(this.options.size, this.options.xAxis, this.options.yAxis, title, this.options.legend);
      return new YouGuessLine(this.data, this.markers, this.clip, this.markerColor, this.knownColor, this.unknownColor, this.drawColor, knownLabel, guessLabel, this.logger, options);
    }
  }, {
    key: "setMarkers",
    value: function (markers) {
      var markers_1 = markers;
      return new YouGuessLine(this.data, markers_1, this.clip, this.markerColor, this.knownColor, this.unknownColor, this.drawColor, this.knownLabel, this.guessLabel, this.logger, this.options);
    }
  }, {
    key: "show",
    value: function (outputId) {
      var _this2 = this;

      (function (arg00) {
        startImmediate(arg00);
      })(function (builder_) {
        return builder_.Delay(function () {
          var markers = defaultArg(_this2.markers, series.create(singleton$2.Return([]), "", "", ""));
          return builder_.Bind(Async_AwaitFuture_Static(markers.data), function (_arg1) {
            var markers_1 = _Array$from(sortWith(function (x, y) {
              return compare(function (tuple) {
                return tuple[0];
              }(x), function (tuple) {
                return tuple[0];
              }(y));
            }, _arg1));

            return builder_.ReturnFrom(function () {
              var tupledArg = _this2.options.size;

              var initial = function initial(data) {
                var clipx = _this2.clip != null ? _this2.clip : data[~~(data.length / 2)][0] instanceof Date ? data[~~(data.length / 2)][0].getTime() : data[~~(data.length / 2)][0];
                return YouDrawHelpers.initState(_Array$from(sortWith(function (x, y) {
                  return compare(function ($var55) {
                    return $var55[0] instanceof Date ? $var55[0].getTime() : $var55[0];
                  }(x), function ($var55) {
                    return $var55[0] instanceof Date ? $var55[0].getTime() : $var55[0];
                  }(y));
                }, data)), clipx);
              };

              var render$$1 = function render$$1(data_1) {
                return function (size) {
                  var patternInput = [defaultArg(_this2.knownColor, "#606060"), defaultArg(_this2.unknownColor, "#FFC700"), defaultArg(_this2.drawColor, "#808080"), defaultArg(_this2.markerColor, "#C65E31")];

                  var data_2 = _Array$from(sortWith(function (x, y) {
                    return compare(function ($var56) {
                      return $var56[0] instanceof Date ? $var56[0].getTime() : $var56[0];
                    }(x), function ($var56) {
                      return $var56[0] instanceof Date ? $var56[0].getTime() : $var56[0];
                    }(y));
                  }, data_1));

                  var co = void 0;
                  var xAxis = void 0;
                  var inputRecord = _this2.options.xAxis;
                  xAxis = new AxisOptions(data_2[0][0] instanceof Date ? data_2[0][0].getTime() : data_2[0][0], data_2[data_2.length - 1][0] instanceof Date ? data_2[data_2.length - 1][0].getTime() : data_2[data_2.length - 1][0], inputRecord.label, inputRecord.labelOffset);
                  co = new ChartOptions(_this2.options.size, xAxis, _this2.options.yAxis, _this2.options.title, _this2.options.legend);
                  var tupledArg_1 = [defaultArg(_this2.knownLabel, ""), defaultArg(_this2.guessLabel, "")];
                  var tupledArg_2 = [patternInput[0], patternInput[1], patternInput[2], patternInput[3]];
                  return function (trigger) {
                    return function (state) {
                      return YouDrawHelpers.render(co, size[0], size[1], markers_1, tupledArg_1[0], tupledArg_1[1], tupledArg_2[0], tupledArg_2[1], tupledArg_2[2], tupledArg_2[3], trigger, state);
                    };
                  };
                };
              };

              var update = function update(_arg3) {
                var log = void 0;
                var clo2 = InteractiveHelpers.createLogger(outputId, _this2.logger);

                log = function log(arg20) {
                  var clo3 = clo2(arg20);
                  return function (arg30) {
                    clo3(arg30);
                  };
                };

                return function (state_1) {
                  return function (evt) {
                    return YouDrawHelpers.handler(log, state_1, evt);
                  };
                };
              };

              return InteractiveHelpers.showAppAsync(outputId, tupledArg[0], tupledArg[1], _this2.data, initial, render$$1, update);
            }());
          });
        });
      }(singleton$2));
    }
  }]);

  return YouGuessLine;
}();
setType("TheGamma.Interactive.YouGuessLine", YouGuessLine);
var YouGuessSortBars = function () {
  function YouGuessSortBars(data, maxValue$$1, size, logger) {
    _classCallCheck(this, YouGuessSortBars);

    this.data = data;
    this.maxValue = maxValue$$1;
    this.size = size;
    this.logger = logger;
  }

  _createClass(YouGuessSortBars, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.YouGuessSortBars",
        interfaces: ["FSharpRecord"],
        properties: {
          data: makeGeneric(series, {
            k: "string",
            v: "number"
          }),
          maxValue: Option("number"),
          size: Tuple([Option("number"), Option("number")]),
          logger: Option("function")
        }
      };
    }
  }, {
    key: "setLogger",
    value: function (logger) {
      var logger_1 = logger;
      return new YouGuessSortBars(this.data, this.maxValue, this.size, logger_1);
    }
  }, {
    key: "setMaximum",
    value: function (max$$1) {
      var maxValue$$1 = max$$1;
      return new YouGuessSortBars(this.data, maxValue$$1, this.size, this.logger);
    }
  }, {
    key: "setSize",
    value: function (width, height) {
      var size = [CompostHelpers.orElse(width, this.size[0]), CompostHelpers.orElse(height, this.size[1])];
      return new YouGuessSortBars(this.data, this.maxValue, size, this.logger);
    }
  }, {
    key: "show",
    value: function (outputId) {
      var _this3 = this;

      var initial = function initial(data) {
        return YouGuessSortHelpers.initState(_this3.maxValue, data);
      };

      var render$$1 = function render$$1(_arg4) {
        return function (size) {
          return function (trigger) {
            return function (state) {
              return YouGuessSortHelpers.renderBars(size[0], size[1], trigger, state);
            };
          };
        };
      };

      var update = function update(_arg5) {
        var log = void 0;
        var clo2 = InteractiveHelpers.createLogger(outputId, _this3.logger);

        log = function log(arg20) {
          var clo3 = clo2(arg20);
          return function (arg30) {
            clo3(arg30);
          };
        };

        return function (state_1) {
          return function (evt) {
            return YouGuessSortHelpers.update(log, state_1, evt);
          };
        };
      };

      InteractiveHelpers.showApp(outputId, this.size[0], this.size[1], this.data, initial, render$$1, update);
    }
  }]);

  return YouGuessSortBars;
}();
setType("TheGamma.Interactive.YouGuessSortBars", YouGuessSortBars);
var youguess = function () {
  function youguess() {
    _classCallCheck(this, youguess);
  }

  _createClass(youguess, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.youguess",
        properties: {}
      };
    }
  }], [{
    key: "columns",
    value: function (data) {
      var kind$$1 = new YouGuessColsBarsKind("Cols", []);
      var options = ChartOptions.Default;
      return new YouGuessColsBars(kind$$1, data, null, options);
    }
  }, {
    key: "bars",
    value: function (data) {
      var kind$$1 = new YouGuessColsBarsKind("Bars", []);
      var options = ChartOptions.Default;
      return new YouGuessColsBars(kind$$1, data, null, options);
    }
  }, {
    key: "sortBars",
    value: function (data) {
      return new YouGuessSortBars(data, null, [null, null], null);
    }
  }, {
    key: "line",
    value: function (data) {
      var clip = null;
      var markerColor = null;
      var guessLabel = null;
      var knownLabel = null;
      var markers = null;
      var knownColor = null;
      var unknownColor = null;
      var drawColor = null;
      var options = ChartOptions.Default;
      return new YouGuessLine(data, markers, clip, markerColor, knownColor, unknownColor, drawColor, knownLabel, guessLabel, null, options);
    }
  }]);

  return youguess;
}();
setType("TheGamma.Interactive.youguess", youguess);
var CompostBubblesChartSet = function () {
  function CompostBubblesChartSet(data, selectY, selectX, selectSize, bubbleColor, options) {
    _classCallCheck(this, CompostBubblesChartSet);

    this.data = data;
    this.selectY = selectY;
    this.selectX = selectX;
    this.selectSize = selectSize;
    this.bubbleColor = bubbleColor;
    this.options = options;
  }

  _createClass(CompostBubblesChartSet, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.CompostBubblesChartSet",
        interfaces: ["FSharpRecord"],
        properties: {
          data: makeGeneric(series, {
            k: Any,
            v: Any
          }),
          selectY: "function",
          selectX: "function",
          selectSize: Option("function"),
          bubbleColor: Option("string"),
          options: ChartOptions
        }
      };
    }
  }, {
    key: "setTitle",
    value: function (title) {
      var options = new ChartOptions(this.options.size, this.options.xAxis, this.options.yAxis, title, this.options.legend);
      return new CompostBubblesChartSet(this.data, this.selectY, this.selectX, this.selectSize, this.bubbleColor, options);
    }
  }, {
    key: "setLegend",
    value: function (position) {
      var options = void 0;
      var legend = new LegendOptions(position);
      options = new ChartOptions(this.options.size, this.options.xAxis, this.options.yAxis, this.options.title, legend);
      return new CompostBubblesChartSet(this.data, this.selectY, this.selectX, this.selectSize, this.bubbleColor, options);
    }
  }, {
    key: "setSize",
    value: function (width, height) {
      var options = new ChartOptions([CompostHelpers.orElse(width, this.options.size[0]), CompostHelpers.orElse(height, this.options.size[1])], this.options.xAxis, this.options.yAxis, this.options.title, this.options.legend);
      return new CompostBubblesChartSet(this.data, this.selectY, this.selectX, this.selectSize, this.bubbleColor, options);
    }
  }, {
    key: "setAxisX",
    value: function (minValue$$1, maxValue$$1, label, labelOffset) {
      var ax = void 0;
      var inputRecord = this.options.xAxis;
      ax = new AxisOptions(CompostHelpers.orElse(minValue$$1, this.options.xAxis.minValue), CompostHelpers.orElse(maxValue$$1, this.options.xAxis.maxValue), CompostHelpers.orElse(label, this.options.xAxis.label), CompostHelpers.orElse(labelOffset, this.options.xAxis.labelOffset));
      var options = new ChartOptions(this.options.size, ax, this.options.yAxis, this.options.title, this.options.legend);
      return new CompostBubblesChartSet(this.data, this.selectY, this.selectX, this.selectSize, this.bubbleColor, options);
    }
  }, {
    key: "setAxisY",
    value: function (minValue$$1, maxValue$$1, label, labelOffset) {
      var ax = void 0;
      var inputRecord = this.options.yAxis;
      ax = new AxisOptions(CompostHelpers.orElse(minValue$$1, this.options.yAxis.minValue), CompostHelpers.orElse(maxValue$$1, this.options.yAxis.maxValue), CompostHelpers.orElse(label, this.options.yAxis.label), CompostHelpers.orElse(labelOffset, this.options.yAxis.labelOffset));
      var options = new ChartOptions(this.options.size, this.options.xAxis, ax, this.options.title, this.options.legend);
      return new CompostBubblesChartSet(this.data, this.selectY, this.selectX, this.selectSize, this.bubbleColor, options);
    }
  }, {
    key: "setColors",
    value: function (bubbleColor) {
      var bubbleColor_1 = bubbleColor != null ? bubbleColor : this.bubbleColor;
      return new CompostBubblesChartSet(this.data, this.selectY, this.selectX, this.selectSize, bubbleColor_1, this.options);
    }
  }, {
    key: "show",
    value: function (outputId) {
      var _this4 = this;

      var tupledArg = this.options.size;

      var render$$1 = function render$$1(data) {
        return function (size) {
          var ss = _this4.selectSize != null ? function (x) {
            return _this4.selectSize(x);
          } : function (_arg6) {
            return null;
          };
          var data_1 = data.map(function (tupledArg_1) {
            return [_this4.selectX(tupledArg_1[1]), _this4.selectY(tupledArg_1[1]), ss(tupledArg_1[1])];
          });
          var bc = defaultArg(_this4.bubbleColor, "#20a030");
          return Charts.renderBubbles(_this4.options, size[0], size[1], bc, data_1);
        };
      };

      InteractiveHelpers.showStaticApp(outputId, tupledArg[0], tupledArg[1], this.data, render$$1);
    }
  }]);

  return CompostBubblesChartSet;
}();
setType("TheGamma.Interactive.CompostBubblesChartSet", CompostBubblesChartSet);
var CompostBubblesChart = function () {
  _createClass(CompostBubblesChart, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.CompostBubblesChart",
        properties: {}
      };
    }
  }]);

  function CompostBubblesChart(data) {
    _classCallCheck(this, CompostBubblesChart);

    this.data = data;
  }

  _createClass(CompostBubblesChart, [{
    key: "set",
    value: function (x, y, size) {
      var data = this.data;
      var selectX = void 0;
      var clo1 = x;

      selectX = function selectX(arg10) {
        return clo1(arg10);
      };

      return new CompostBubblesChartSet(data, function () {
        var clo1_1 = y;
        return function (arg10_1) {
          return clo1_1(arg10_1);
        };
      }(), selectX, size, null, ChartOptions.Default);
    }
  }]);

  return CompostBubblesChart;
}();
setType("TheGamma.Interactive.CompostBubblesChart", CompostBubblesChart);
var CompostColBarChart = function () {
  function CompostColBarChart(isBar, data, colors, inlineLabels, options) {
    _classCallCheck(this, CompostColBarChart);

    this.isBar = isBar;
    this.data = data;
    this.colors = colors;
    this.inlineLabels = inlineLabels;
    this.options = options;
  }

  _createClass(CompostColBarChart, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.CompostColBarChart",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          isBar: "boolean",
          data: makeGeneric(series, {
            k: "string",
            v: "number"
          }),
          colors: Option(FableArray("string")),
          inlineLabels: "boolean",
          options: ChartOptions
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "setTitle",
    value: function (title) {
      var options = new ChartOptions(this.options.size, this.options.xAxis, this.options.yAxis, title, this.options.legend);
      return new CompostColBarChart(this.isBar, this.data, this.colors, this.inlineLabels, options);
    }
  }, {
    key: "setLegend",
    value: function (position) {
      var options = void 0;
      var legend = new LegendOptions(position);
      options = new ChartOptions(this.options.size, this.options.xAxis, this.options.yAxis, this.options.title, legend);
      return new CompostColBarChart(this.isBar, this.data, this.colors, this.inlineLabels, options);
    }
  }, {
    key: "setSize",
    value: function (width, height) {
      var options = new ChartOptions([CompostHelpers.orElse(width, this.options.size[0]), CompostHelpers.orElse(height, this.options.size[1])], this.options.xAxis, this.options.yAxis, this.options.title, this.options.legend);
      return new CompostColBarChart(this.isBar, this.data, this.colors, this.inlineLabels, options);
    }
  }, {
    key: "setAxisX",
    value: function (minValue$$1, maxValue$$1, label, labelOffset) {
      var ax = void 0;
      var inputRecord = this.options.xAxis;
      ax = new AxisOptions(CompostHelpers.orElse(minValue$$1, this.options.xAxis.minValue), CompostHelpers.orElse(maxValue$$1, this.options.xAxis.maxValue), CompostHelpers.orElse(label, this.options.xAxis.label), CompostHelpers.orElse(labelOffset, this.options.xAxis.labelOffset));
      var options = new ChartOptions(this.options.size, ax, this.options.yAxis, this.options.title, this.options.legend);
      return new CompostColBarChart(this.isBar, this.data, this.colors, this.inlineLabels, options);
    }
  }, {
    key: "setAxisY",
    value: function (minValue$$1, maxValue$$1, label, labelOffset) {
      var ax = void 0;
      var inputRecord = this.options.yAxis;
      ax = new AxisOptions(CompostHelpers.orElse(minValue$$1, this.options.yAxis.minValue), CompostHelpers.orElse(maxValue$$1, this.options.yAxis.maxValue), CompostHelpers.orElse(label, this.options.yAxis.label), CompostHelpers.orElse(labelOffset, this.options.yAxis.labelOffset));
      var options = new ChartOptions(this.options.size, this.options.xAxis, ax, this.options.title, this.options.legend);
      return new CompostColBarChart(this.isBar, this.data, this.colors, this.inlineLabels, options);
    }
  }, {
    key: "setStyle",
    value: function (inlineLabels) {
      var inlineLabels_1 = inlineLabels != null ? inlineLabels : this.inlineLabels;
      return new CompostColBarChart(this.isBar, this.data, this.colors, inlineLabels_1, this.options);
    }
  }, {
    key: "setColors",
    value: function (colors) {
      var colors_1 = colors != null ? colors : this.colors;
      return new CompostColBarChart(this.isBar, this.data, colors_1, this.inlineLabels, this.options);
    }
  }, {
    key: "show",
    value: function (outputId) {
      var _this5 = this;

      var tupledArg = this.options.size;

      var render$$1 = function render$$1(data) {
        return function (size) {
          var cc = defaultArg(_this5.colors, CompostHelpers.vega10);
          var clrs = cc;
          var labels = map$3(function (tuple) {
            return tuple[0];
          }, data);
          return Charts.renderColsBars(_this5.isBar, _this5.inlineLabels, _this5.options, size[0], size[1], clrs, labels, data);
        };
      };

      InteractiveHelpers.showStaticApp(outputId, tupledArg[0], tupledArg[1], this.data, render$$1);
    }
  }]);

  return CompostColBarChart;
}();
setType("TheGamma.Interactive.CompostColBarChart", CompostColBarChart);
var CompostLineAreaChart = function () {
  function CompostLineAreaChart(isArea, data, lineColor, options) {
    _classCallCheck(this, CompostLineAreaChart);

    this.isArea = isArea;
    this.data = data;
    this.lineColor = lineColor;
    this.options = options;
  }

  _createClass(CompostLineAreaChart, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.CompostLineAreaChart",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          isArea: "boolean",
          data: makeGeneric(series, {
            k: Any,
            v: Any
          }),
          lineColor: Option("string"),
          options: ChartOptions
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "setTitle",
    value: function (title) {
      var options = new ChartOptions(this.options.size, this.options.xAxis, this.options.yAxis, title, this.options.legend);
      return new CompostLineAreaChart(this.isArea, this.data, this.lineColor, options);
    }
  }, {
    key: "setLegend",
    value: function (position) {
      var options = void 0;
      var legend = new LegendOptions(position);
      options = new ChartOptions(this.options.size, this.options.xAxis, this.options.yAxis, this.options.title, legend);
      return new CompostLineAreaChart(this.isArea, this.data, this.lineColor, options);
    }
  }, {
    key: "setSize",
    value: function (width, height) {
      var options = new ChartOptions([CompostHelpers.orElse(width, this.options.size[0]), CompostHelpers.orElse(height, this.options.size[1])], this.options.xAxis, this.options.yAxis, this.options.title, this.options.legend);
      return new CompostLineAreaChart(this.isArea, this.data, this.lineColor, options);
    }
  }, {
    key: "setAxisX",
    value: function (minValue$$1, maxValue$$1, label, labelOffset) {
      var ax = void 0;
      var inputRecord = this.options.xAxis;
      ax = new AxisOptions(CompostHelpers.orElse(minValue$$1, this.options.xAxis.minValue), CompostHelpers.orElse(maxValue$$1, this.options.xAxis.maxValue), CompostHelpers.orElse(label, this.options.xAxis.label), CompostHelpers.orElse(labelOffset, this.options.xAxis.labelOffset));
      var options = new ChartOptions(this.options.size, ax, this.options.yAxis, this.options.title, this.options.legend);
      return new CompostLineAreaChart(this.isArea, this.data, this.lineColor, options);
    }
  }, {
    key: "setAxisY",
    value: function (minValue$$1, maxValue$$1, label, labelOffset) {
      var ax = void 0;
      var inputRecord = this.options.yAxis;
      ax = new AxisOptions(CompostHelpers.orElse(minValue$$1, this.options.yAxis.minValue), CompostHelpers.orElse(maxValue$$1, this.options.yAxis.maxValue), CompostHelpers.orElse(label, this.options.yAxis.label), CompostHelpers.orElse(labelOffset, this.options.yAxis.labelOffset));
      var options = new ChartOptions(this.options.size, this.options.xAxis, ax, this.options.title, this.options.legend);
      return new CompostLineAreaChart(this.isArea, this.data, this.lineColor, options);
    }
  }, {
    key: "setColors",
    value: function (lineColor) {
      var lineColor_1 = lineColor != null ? lineColor : this.lineColor;
      return new CompostLineAreaChart(this.isArea, this.data, lineColor_1, this.options);
    }
  }, {
    key: "show",
    value: function (outputId) {
      var _this6 = this;

      var tupledArg = this.options.size;

      var render$$1 = function render$$1(data) {
        return function (size) {
          var lc = defaultArg(_this6.lineColor, "#1f77b4");
          var lcs = [lc];
          var labels = ofArray$1(["Data"]);
          var data_1 = [data];
          return Charts.renderLines(_this6.isArea, _this6.options, size[0], size[1], lcs, labels, data_1);
        };
      };

      InteractiveHelpers.showStaticApp(outputId, tupledArg[0], tupledArg[1], this.data, render$$1);
    }
  }]);

  return CompostLineAreaChart;
}();
setType("TheGamma.Interactive.CompostLineAreaChart", CompostLineAreaChart);
var CompostLinesAreasChart = function () {
  function CompostLinesAreasChart(isArea, data, lineColors, options) {
    _classCallCheck(this, CompostLinesAreasChart);

    this.isArea = isArea;
    this.data = data;
    this.lineColors = lineColors;
    this.options = options;
  }

  _createClass(CompostLinesAreasChart, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.CompostLinesAreasChart",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          isArea: "boolean",
          data: FableArray(makeGeneric(series, {
            k: Any,
            v: Any
          })),
          lineColors: Option(FableArray("string")),
          options: ChartOptions
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "setTitle",
    value: function (title) {
      var options = new ChartOptions(this.options.size, this.options.xAxis, this.options.yAxis, title, this.options.legend);
      return new CompostLinesAreasChart(this.isArea, this.data, this.lineColors, options);
    }
  }, {
    key: "setLegend",
    value: function (position) {
      var options = void 0;
      var legend = new LegendOptions(position);
      options = new ChartOptions(this.options.size, this.options.xAxis, this.options.yAxis, this.options.title, legend);
      return new CompostLinesAreasChart(this.isArea, this.data, this.lineColors, options);
    }
  }, {
    key: "setSize",
    value: function (width, height) {
      var options = new ChartOptions([CompostHelpers.orElse(width, this.options.size[0]), CompostHelpers.orElse(height, this.options.size[1])], this.options.xAxis, this.options.yAxis, this.options.title, this.options.legend);
      return new CompostLinesAreasChart(this.isArea, this.data, this.lineColors, options);
    }
  }, {
    key: "setAxisX",
    value: function (minValue$$1, maxValue$$1, label, labelOffset) {
      var ax = void 0;
      var inputRecord = this.options.xAxis;
      ax = new AxisOptions(CompostHelpers.orElse(minValue$$1, this.options.xAxis.minValue), CompostHelpers.orElse(maxValue$$1, this.options.xAxis.maxValue), CompostHelpers.orElse(label, this.options.xAxis.label), CompostHelpers.orElse(labelOffset, this.options.xAxis.labelOffset));
      var options = new ChartOptions(this.options.size, ax, this.options.yAxis, this.options.title, this.options.legend);
      return new CompostLinesAreasChart(this.isArea, this.data, this.lineColors, options);
    }
  }, {
    key: "setAxisY",
    value: function (minValue$$1, maxValue$$1, label, labelOffset) {
      var ax = void 0;
      var inputRecord = this.options.yAxis;
      ax = new AxisOptions(CompostHelpers.orElse(minValue$$1, this.options.yAxis.minValue), CompostHelpers.orElse(maxValue$$1, this.options.yAxis.maxValue), CompostHelpers.orElse(label, this.options.yAxis.label), CompostHelpers.orElse(labelOffset, this.options.yAxis.labelOffset));
      var options = new ChartOptions(this.options.size, this.options.xAxis, ax, this.options.title, this.options.legend);
      return new CompostLinesAreasChart(this.isArea, this.data, this.lineColors, options);
    }
  }, {
    key: "setColors",
    value: function (lineColors) {
      var lineColors_1 = lineColors != null ? lineColors : this.lineColors;
      return new CompostLinesAreasChart(this.isArea, this.data, lineColors_1, this.options);
    }
  }, {
    key: "show",
    value: function (outputId) {
      var _this7 = this;

      (function (arg00) {
        startImmediate(arg00);
      })(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(parallel(toList(delay(function () {
            return map$3(function (d) {
              return Async_AwaitFuture_Static(d.data);
            }, _this7.data);
          }))), function (_arg1) {
            return builder_.ReturnFrom(function () {
              var tupledArg = _this7.options.size;

              var render$$1 = function render$$1(size) {
                var lcs = defaultArg(_this7.lineColors, CompostHelpers.vega10);
                var lcs_1 = lcs;
                var labels = map$3(function (s$$1) {
                  return s$$1.seriesName;
                }, _this7.data);
                return Charts.renderLines(_this7.isArea, _this7.options, size[0], size[1], lcs_1, labels, _arg1);
              };

              return InteractiveHelpers.showStaticAppAsync(outputId, tupledArg[0], tupledArg[1], render$$1);
            }());
          });
        });
      }(singleton$2));
    }
  }]);

  return CompostLinesAreasChart;
}();
setType("TheGamma.Interactive.CompostLinesAreasChart", CompostLinesAreasChart);
var CompostCharts = function () {
  _createClass(CompostCharts, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.CompostCharts",
        properties: {}
      };
    }
  }]);

  function CompostCharts() {
    _classCallCheck(this, CompostCharts);
  }

  _createClass(CompostCharts, [{
    key: "bubbles",
    value: function (data) {
      return new CompostBubblesChart(data);
    }
  }, {
    key: "line",
    value: function (data) {
      var data_1 = data;
      var lineColor = null;
      var options = ChartOptions.Default;
      return new CompostLineAreaChart(false, data_1, lineColor, options);
    }
  }, {
    key: "area",
    value: function (data) {
      var data_1 = data;
      var lineColor = null;
      var options = ChartOptions.Default;
      return new CompostLineAreaChart(true, data_1, lineColor, options);
    }
  }, {
    key: "lines",
    value: function (data) {
      var data_1 = data;
      var lineColors = null;
      var options = ChartOptions.Default;
      return new CompostLinesAreasChart(false, data_1, lineColors, options);
    }
  }, {
    key: "areas",
    value: function (data) {
      var data_1 = data;
      var lineColors = null;
      var options = ChartOptions.Default;
      return new CompostLinesAreasChart(true, data_1, lineColors, options);
    }
  }, {
    key: "bar",
    value: function (data) {
      var colors = null;
      var options = ChartOptions.Default;
      return new CompostColBarChart(true, data, colors, false, options);
    }
  }, {
    key: "column",
    value: function (data) {
      var colors = null;
      var options = ChartOptions.Default;
      return new CompostColBarChart(false, data, colors, false, options);
    }
  }]);

  return CompostCharts;
}();
setType("TheGamma.Interactive.CompostCharts", CompostCharts);
var compost = function () {
  function compost() {
    _classCallCheck(this, compost);
  }

  _createClass(compost, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Interactive.compost",
        properties: {
          charts: CompostCharts
        }
      };
    }
  }], [{
    key: "charts",
    get: function () {
      return new CompostCharts();
    }
  }]);

  return compost;
}();
setType("TheGamma.Interactive.compost", compost);

function node(rng, node_1) {
  var Entity$$1 = null;
  var WhiteBefore = new List$1();
  var WhiteAfter = new List$1();
  return new _Node(WhiteBefore, WhiteAfter, rng, node_1, Entity$$1);
}
function needsEscaping(s) {
  if (s[0] >= "0" ? s[0] <= "9" : false) {
    return true;
  } else {
    return s.split("").some(function (c) {
      return !(((c >= "a" ? c <= "z" : false) ? true : c >= "A" ? c <= "Z" : false) ? true : c >= "0" ? c <= "9" : false);
    });
  }
}
function escapeIdent(s) {
  if (s === "") {
    return "";
  } else if (needsEscaping(s)) {
    return "'" + s + "'";
  } else {
    return s;
  }
}
function unionRanges(r1, r2) {
  return new _Range(r1.Start < r2.Start ? r1.Start : r2.Start, r1.End > r2.End ? r1.End : r2.End);
}

function formatToken(_arg1) {
  if (_arg1.Case === "RParen") {
    return ")";
  } else if (_arg1.Case === "Equals") {
    return "=";
  } else if (_arg1.Case === "Dot") {
    return ".";
  } else if (_arg1.Case === "Comma") {
    return ",";
  } else if (_arg1.Case === "Colon") {
    return ":";
  } else if (_arg1.Case === "Let") {
    return "let";
  } else if (_arg1.Case === "LSquare") {
    return "[";
  } else if (_arg1.Case === "RSquare") {
    return "]";
  } else if (_arg1.Case === "Fun") {
    return "fun";
  } else if (_arg1.Case === "Arrow") {
    return "->";
  } else if (_arg1.Case === "Operator") {
    if (_arg1.Fields[0].Case === "Divide") {
      return "/";
    } else if (_arg1.Fields[0].Case === "GreaterThan") {
      return ">";
    } else if (_arg1.Fields[0].Case === "GreaterThanOrEqual") {
      return ">=";
    } else if (_arg1.Fields[0].Case === "LessThan") {
      return "<";
    } else if (_arg1.Fields[0].Case === "LessThanOrEqual") {
      return "<=";
    } else if (_arg1.Fields[0].Case === "Minus") {
      return "-";
    } else if (_arg1.Fields[0].Case === "Multiply") {
      return "*";
    } else if (_arg1.Fields[0].Case === "Plus") {
      return "+";
    } else if (_arg1.Fields[0].Case === "Power") {
      return "^";
    } else if (_arg1.Fields[0].Case === "Equals") {
      return "=";
    } else {
      return "%";
    }
  } else if (_arg1.Case === "Boolean") {
    if (_arg1.Fields[0]) {
      return "true";
    } else {
      return "false";
    }
  } else if (_arg1.Case === "Number") {
    return _arg1.Fields[0];
  } else if (_arg1.Case === "String") {
    return "\"" + replace$$1(replace$$1(replace$$1(_arg1.Fields[0], "\\", "\\\\"), "\n", "\\n"), "\"", "\\\"") + "\"";
  } else if (_arg1.Case === "Ident") {
    return _arg1.Fields[0];
  } else if (_arg1.Case === "QIdent") {
    return "'" + _arg1.Fields[0] + "'";
  } else if (_arg1.Case === "White") {
    return _arg1.Fields[0];
  } else if (_arg1.Case === "Newline") {
    return "\n";
  } else if (_arg1.Case === "Error") {
    return _arg1.Fields[0];
  } else if (_arg1.Case === "EndOfFile") {
    return "";
  } else {
    return "(";
  }
}
function formatTokenInfo(_arg1) {
  if (_arg1.Case === "RParen") {
    return "right parenthesis `)`";
  } else if (_arg1.Case === "Equals") {
    return "equals sign `=`";
  } else if (_arg1.Case === "Dot") {
    return "dot character `.`";
  } else if (_arg1.Case === "Comma") {
    return "comma character `,`";
  } else if (_arg1.Case === "Colon") {
    return "colon character `:`";
  } else if (_arg1.Case === "Let") {
    return "`let` keyword";
  } else if (_arg1.Case === "LSquare") {
    return "left square bracket `[`";
  } else if (_arg1.Case === "RSquare") {
    return "right square bracket `]`";
  } else if (_arg1.Case === "Fun") {
    return "`fun` keyword";
  } else if (_arg1.Case === "Arrow") {
    return "arrow sign `->`";
  } else if (_arg1.Case === "Operator") {
    if (_arg1.Fields[0].Case === "Divide") {
      return "division sign `/`";
    } else if (_arg1.Fields[0].Case === "Modulo") {
      return "modulo operator `%`";
    } else if (_arg1.Fields[0].Case === "GreaterThan") {
      return "greater than sign `>`";
    } else if (_arg1.Fields[0].Case === "GreaterThanOrEqual") {
      return "greater than or equals sign `>=`";
    } else if (_arg1.Fields[0].Case === "LessThan") {
      return "less than sign `<`";
    } else if (_arg1.Fields[0].Case === "LessThanOrEqual") {
      return "less than or equals sign `<=`";
    } else if (_arg1.Fields[0].Case === "Minus") {
      return "minus sign `-`";
    } else if (_arg1.Fields[0].Case === "Multiply") {
      return "multiplication sign `*`";
    } else if (_arg1.Fields[0].Case === "Plus") {
      return "plus sign `+`";
    } else if (_arg1.Fields[0].Case === "Power") {
      return "exponentiation sign `^`";
    } else {
      return "equals operator `=`";
    }
  } else if (_arg1.Case === "Boolean") {
    if (_arg1.Fields[0]) {
      return "logical `true` value";
    } else {
      return "logical `false` value";
    }
  } else if (_arg1.Case === "Number") {
    return fsFormat("numerical value `%s`")(function (x) {
      return x;
    })(_arg1.Fields[0]);
  } else if (_arg1.Case === "String") {
    return fsFormat("string value `%s`")(function (x) {
      return x;
    })(replace$$1(_arg1.Fields[0], "`", "'"));
  } else if (_arg1.Case === "Ident") {
    return fsFormat("identifer `%s`")(function (x) {
      return x;
    })(_arg1.Fields[0]);
  } else if (_arg1.Case === "QIdent") {
    return fsFormat("quoted identifer `'%s'`")(function (x) {
      return x;
    })(_arg1.Fields[0]);
  } else if (_arg1.Case === "White") {
    return "whitespace";
  } else if (_arg1.Case === "Newline") {
    return "end of line";
  } else if (_arg1.Case === "Error") {
    if (_arg1.Fields[0] === "`") {
      return "back-tick character";
    } else {
      return fsFormat("other character `%s`")(function (x) {
        return x;
      })(_arg1.Fields[0]);
    }
  } else if (_arg1.Case === "EndOfFile") {
    return "end of file";
  } else {
    return "left parenthesis `(`";
  }
}

var FormattingContext = function () {
  function FormattingContext(strings) {
    _classCallCheck(this, FormattingContext);

    this.Strings = strings;
  }

  _createClass(FormattingContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Ast.FormattingContext",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Strings: FableArray("string")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "Add",
    value: function (tok) {
      this.Strings.push(formatToken(tok));
    }
  }]);

  return FormattingContext;
}();
setType("TheGamma.Ast.FormattingContext", FormattingContext);
function formatNode(ctx, f, node_1) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(node_1.WhiteBefore), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var t = _step.value;
      ctx.Add(t.Token);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  f(ctx)(node_1.Node);
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = _getIterator(node_1.WhiteAfter), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var t_1 = _step2.value;
      ctx.Add(t_1.Token);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}
function formatName(ctx, name) {
  if (name.Name === "") {} else if (needsEscaping(name.Name)) {
    ctx.Add(new TokenKind("QIdent", [name.Name]));
  } else {
    ctx.Add(new TokenKind("Ident", [name.Name]));
  }
}
function formatArgument(ctx, arg) {
  if (arg.Name != null) {
    formatNode(ctx, function (ctx_1) {
      return function (name) {
        formatName(ctx_1, name);
      };
    }, arg.Name);
    ctx.Add(new TokenKind("Equals", []));
  }

  formatNode(ctx, function (ctx_2) {
    return function (expr) {
      formatExpression(ctx_2, expr);
    };
  }, arg.Value);
}
function formatExpression(ctx, expr) {
  if (expr.Case === "Member") {
    formatNode(ctx, function (ctx_1) {
      return function (expr_1) {
        formatExpression(ctx_1, expr_1);
      };
    }, expr.Fields[0]);
    ctx.Add(new TokenKind("Dot", []));
    formatNode(ctx, function (ctx_2) {
      return function (expr_2) {
        formatExpression(ctx_2, expr_2);
      };
    }, expr.Fields[1]);
  } else if (expr.Case === "Call") {
    formatNode(ctx, function (ctx_3) {
      return function (expr_3) {
        formatExpression(ctx_3, expr_3);
      };
    }, expr.Fields[0]);
    ctx.Add(new TokenKind("LParen", []));
    (function () {
      var f = function f(ctx_4) {
        return function (args) {
          iterateIndexed(function (i, arg) {
            if (i !== 0) {
              ctx_4.Add(new TokenKind("Comma", []));
            }

            formatArgument(ctx_4, arg);
          }, args);
        };
      };

      return function (node_1) {
        formatNode(ctx, f, node_1);
      };
    })()(expr.Fields[1]);
    ctx.Add(new TokenKind("RParen", []));
  } else if (expr.Case === "String") {
    ctx.Add(new TokenKind("String", [expr.Fields[0]]));
  } else if (expr.Case === "Number") {
    ctx.Add(new TokenKind("Number", [String(expr.Fields[0]), expr.Fields[0]]));
  } else if (expr.Case === "Boolean") {
    ctx.Add(new TokenKind("Boolean", [expr.Fields[0]]));
  } else if (expr.Case === "Binary") {
    formatNode(ctx, function (ctx_5) {
      return function (expr_4) {
        formatExpression(ctx_5, expr_4);
      };
    }, expr.Fields[0]);
    (function () {
      var f_1 = function f_1(ctx_6) {
        return function (op) {
          ctx_6.Add(new TokenKind("Operator", [op]));
        };
      };

      return function (node_2) {
        formatNode(ctx, f_1, node_2);
      };
    })()(expr.Fields[1]);
    formatNode(ctx, function (ctx_7) {
      return function (expr_5) {
        formatExpression(ctx_7, expr_5);
      };
    }, expr.Fields[2]);
  } else if (expr.Case === "Function") {
    ctx.Add(new TokenKind("Fun", []));
    formatNode(ctx, function (ctx_8) {
      return function (name) {
        formatName(ctx_8, name);
      };
    }, expr.Fields[0]);
    ctx.Add(new TokenKind("Arrow", []));
    formatNode(ctx, function (ctx_9) {
      return function (expr_6) {
        formatExpression(ctx_9, expr_6);
      };
    }, expr.Fields[1]);
  } else if (expr.Case === "Placeholder") {
    ctx.Add(new TokenKind("LSquare", []));
    formatNode(ctx, function (ctx_10) {
      return function (name_1) {
        formatName(ctx_10, name_1);
      };
    }, expr.Fields[0]);
    ctx.Add(new TokenKind("Colon", []));
    formatNode(ctx, function (ctx_11) {
      return function (expr_7) {
        formatExpression(ctx_11, expr_7);
      };
    }, expr.Fields[1]);
    ctx.Add(new TokenKind("RSquare", []));
  } else if (expr.Case === "List") {
    ctx.Add(new TokenKind("LSquare", []));
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = _getIterator(expr.Fields[0]), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var e = _step3.value;
        formatNode(ctx, function (ctx_12) {
          return function (expr_8) {
            formatExpression(ctx_12, expr_8);
          };
        }, e);
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    ctx.Add(new TokenKind("RSquare", []));
  } else if (expr.Case === "Empty") {} else {
    formatNode(ctx, function (ctx_13) {
      return function (name_2) {
        formatName(ctx_13, name_2);
      };
    }, expr.Fields[0]);
  }
}

function formatSingleExpression(expr) {
  var ctx = new FormattingContext([]);
  formatNode(ctx, function (ctx_1) {
    return function (expr_1) {
      formatExpression(ctx_1, expr_1);
    };
  }, expr);
  return join("", ctx.Strings);
}

function formatWhiteAfterExpr(nd) {
  var wa = nd.Node.Case === "Variable" ? append$1(nd.Node.Fields[0].WhiteAfter, nd.WhiteAfter) : nd.WhiteAfter;
  return join("", toList(delay(function () {
    return map$3(function (t) {
      return formatToken(t.Token);
    }, wa);
  })));
}
function formatWhiteBeforeExpr(nd) {
  var wa = void 0;
  var $var81 = nd.Node.Case === "Variable" ? [0, nd.Node.Fields[0]] : nd.Node.Case === "Member" ? nd.Node.Fields[1].Node.Case === "Variable" ? [1, nd.Node.Fields[1], nd.Node.Fields[1].Node.Fields[0]] : [2] : [2];

  switch ($var81[0]) {
    case 0:
      wa = append$1(nd.WhiteBefore, $var81[1].WhiteBefore);
      break;

    case 1:
      wa = append$1(nd.WhiteBefore, append$1($var81[1].WhiteBefore, $var81[2].WhiteBefore));
      break;

    case 2:
      wa = nd.WhiteBefore;
      break;
  }

  return join("", toList(delay(function () {
    return map$3(function (t) {
      return formatToken(t.Token);
    }, wa);
  })));
}
function formatEntityKind(_arg1) {
  if (_arg1.Case === "Variable") {
    return "variable";
  } else if (_arg1.Case === "Binding") {
    return "binding";
  } else if (_arg1.Case === "Operator") {
    return formatToken(new TokenKind("Operator", [_arg1.Fields[1]])) + " operator";
  } else if (_arg1.Case === "List") {
    return "list";
  } else if (_arg1.Case === "Constant") {
    if (_arg1.Fields[0].Case === "Number") {
      return fsFormat("number `%f`")(function (x) {
        return x;
      })(_arg1.Fields[0].Fields[0]);
    } else if (_arg1.Fields[0].Case === "String") {
      return fsFormat("string `%s`")(function (x) {
        return x;
      })(_arg1.Fields[0].Fields[0]);
    } else if (_arg1.Fields[0].Case === "Boolean") {
      if (_arg1.Fields[0].Fields[0]) {
        return "`true` value";
      } else {
        return "`false` value";
      }
    } else {
      return "empty value";
    }
  } else if (_arg1.Case === "Function") {
    return "function";
  } else if (_arg1.Case === "LetCommand") {
    return "let command";
  } else if (_arg1.Case === "RunCommand") {
    return "run command";
  } else if (_arg1.Case === "Program") {
    return "program";
  } else if (_arg1.Case === "Root") {
    return "root";
  } else if (_arg1.Case === "CallSite") {
    return "call site";
  } else if (_arg1.Case === "NamedParam") {
    return "named param";
  } else if (_arg1.Case === "Call") {
    return "call";
  } else if (_arg1.Case === "ArgumentList") {
    return "argument list";
  } else if (_arg1.Case === "Member") {
    return "member access";
  } else if (_arg1.Case === "MemberName") {
    return "member name";
  } else if (_arg1.Case === "Placeholder") {
    return "placeholder";
  } else {
    return "global value";
  }
}
function entityCodeNameAndAntecedents(_arg1) {
  if (_arg1.Case === "Program") {
    return [1, _arg1.Fields[0], "<program>"];
  } else if (_arg1.Case === "RunCommand") {
    return [2, ofArray$1([_arg1.Fields[0]]), "<do>"];
  } else if (_arg1.Case === "LetCommand") {
    return [3, ofArray$1([_arg1.Fields[0], _arg1.Fields[1]]), "<let>"];
  } else if (_arg1.Case === "Operator") {
    return [4, ofArray$1([_arg1.Fields[0], _arg1.Fields[2]]), formatToken(new TokenKind("Operator", [_arg1.Fields[1]]))];
  } else if (_arg1.Case === "List") {
    return [5, _arg1.Fields[0], "<list>"];
  } else if (_arg1.Case === "Constant") {
    if (_arg1.Fields[0].Case === "Number") {
      return [7, new List$1(), String(_arg1.Fields[0].Fields[0])];
    } else if (_arg1.Fields[0].Case === "Boolean") {
      return [8, new List$1(), String(_arg1.Fields[0].Fields[0])];
    } else if (_arg1.Fields[0].Case === "Empty") {
      return [9, new List$1(), "<empty>"];
    } else {
      return [6, new List$1(), _arg1.Fields[0].Fields[0]];
    }
  } else if (_arg1.Case === "Function") {
    return [10, ofArray$1([_arg1.Fields[0], _arg1.Fields[1]]), "<function>"];
  } else if (_arg1.Case === "GlobalValue") {
    return [11, new List$1(), _arg1.Fields[0].Name];
  } else if (_arg1.Case === "Variable") {
    return [12, ofArray$1([_arg1.Fields[1]]), _arg1.Fields[0].Name];
  } else if (_arg1.Case === "Binding") {
    return [13, ofArray$1([_arg1.Fields[1]]), _arg1.Fields[0].Name];
  } else if (_arg1.Case === "ArgumentList") {
    return [14, _arg1.Fields[0], "<args>"];
  } else if (_arg1.Case === "Call") {
    return [15, ofArray$1([_arg1.Fields[0], _arg1.Fields[1]]), "<call>"];
  } else if (_arg1.Case === "Member") {
    return [16, ofArray$1([_arg1.Fields[0], _arg1.Fields[1]]), "<member>"];
  } else if (_arg1.Case === "NamedParam") {
    return [17, ofArray$1([_arg1.Fields[1]]), _arg1.Fields[0].Name];
  } else if (_arg1.Case === "Placeholder") {
    return [18, ofArray$1([_arg1.Fields[1]]), _arg1.Fields[0].Name];
  } else if (_arg1.Case === "CallSite") {
    if (_arg1.Fields[1].Case === "Choice2Of2") {
      return [20, ofArray$1([_arg1.Fields[0]]), String(_arg1.Fields[1].Fields[0])];
    } else {
      return [19, ofArray$1([_arg1.Fields[0]]), _arg1.Fields[1].Fields[0]];
    }
  } else if (_arg1.Case === "MemberName") {
    return [21, new List$1(), _arg1.Fields[0].Name];
  } else {
    return [0, new List$1(), "<root>"];
  }
}
function lastChainElement(ent) {
  if (ent.Kind.Case === "Variable") {
    return ent;
  } else if (ent.Kind.Case === "Member") {
    return ent.Kind.Fields[1];
  } else {
    return ent;
  }
}

function Entity_get_Antecedents() {
  var patternInput = entityCodeNameAndAntecedents(this.Kind);
  return patternInput[1];
}

function Entity_get_Name() {
  var patternInput = entityCodeNameAndAntecedents(this.Kind);
  return patternInput[2];
}

function formatType(_arg1) {
  if (_arg1.Case === "Primitive") {
    if (_arg1.Fields[0].Case === "Date") {
      return "date";
    } else if (_arg1.Fields[0].Case === "Number") {
      return "number";
    } else if (_arg1.Fields[0].Case === "String") {
      return "string";
    } else if (_arg1.Fields[0].Case === "Unit") {
      return "unit";
    } else {
      return "bool";
    }
  } else if (_arg1.Case === "Object") {
    try {
      var mem = _arg1.Fields[0].Members;
      var mems = join(", ", map$3(function (m) {
        return m.Name;
      }, truncate(5, mem)));
      return "{ " + (mem.length > 5 ? mems + ", ..." : mems + " }");
    } catch (matchValue) {
      return "{ members }";
    }
  } else if (_arg1.Case === "Method") {
    var tout = void 0;

    var matchValue_2 = _arg1.Fields[1](toList(delay(function () {
      return collect(function (matchValue_1) {
        return singleton(matchValue_1[2]);
      }, _arg1.Fields[0]);
    })));

    if (matchValue_2 != null) {
      tout = formatType(matchValue_2);
    } else {
      tout = "?";
    }

    var tin = join(", ", toList(delay(function () {
      return collect(function (matchValue_3) {
        return singleton(fsFormat("%s%s:%s")(function (x) {
          return x;
        })(matchValue_3[1] ? "?" : "")(matchValue_3[0])(formatType(matchValue_3[2])));
      }, _arg1.Fields[0]);
    })));
    return "(" + tin + ") -> " + tout;
  } else if (_arg1.Case === "List") {
    return "list<" + formatType(_arg1.Fields[0]) + ">";
  } else if (_arg1.Case === "Any") {
    return "any";
  } else {
    return "delayed type";
  }
}
function formatTypeInfo(_arg1) {
  if (_arg1.Case === "Primitive") {
    if (_arg1.Fields[0].Case === "Date") {
      return "date";
    } else if (_arg1.Fields[0].Case === "Number") {
      return "number";
    } else if (_arg1.Fields[0].Case === "String") {
      return "string";
    } else if (_arg1.Fields[0].Case === "Unit") {
      return "unit";
    } else {
      return "bool";
    }
  } else if (_arg1.Case === "Object") {
    return "object type";
  } else if (_arg1.Case === "Method") {
    return "method type";
  } else if (_arg1.Case === "List") {
    return "list type";
  } else if (_arg1.Case === "Any") {
    return "unknown";
  } else {
    return "delayed type";
  }
}


function _ExprLeaf_ExprNode_(e) {
  var $var84 = e.Case === "Member" ? [1] : e.Case === "Call" ? [2] : e.Case === "Variable" ? [3] : e.Case === "List" ? [4] : e.Case === "Function" ? [5] : e.Case === "Binary" ? [6] : e.Case === "Number" ? [7] : e.Case === "Boolean" ? [7] : e.Case === "String" ? [7] : e.Case === "Empty" ? [7] : [0];

  switch ($var84[0]) {
    case 0:
      return new Choice("Choice2Of2", [[ofArray$1([e.Fields[1]]), ofArray$1([e.Fields[0]])]]);

    case 1:
      return new Choice("Choice2Of2", [[ofArray$1([e.Fields[0], e.Fields[1]]), new List$1()]]);

    case 2:
      return new Choice("Choice2Of2", [[new List$1(e.Fields[0], toList(delay(function () {
        return map$3(function (a) {
          return a.Value;
        }, e.Fields[1].Node);
      }))), choose$1(function (a_1) {
        return a_1.Name;
      }, e.Fields[1].Node)]]);

    case 3:
      return new Choice("Choice2Of2", [[new List$1(), ofArray$1([e.Fields[0]])]]);

    case 4:
      return new Choice("Choice2Of2", [[e.Fields[0], new List$1()]]);

    case 5:
      return new Choice("Choice2Of2", [[ofArray$1([e.Fields[1]]), ofArray$1([e.Fields[0]])]]);

    case 6:
      return new Choice("Choice2Of2", [[ofArray$1([e.Fields[0], e.Fields[2]]), new List$1()]]);

    case 7:
      return new Choice("Choice1Of2", [null]);
  }
}

function _FindMember___(name, obj) {
  return tryPick(function (m) {
    return m.Name === name.Name ? m : null;
  }, obj.Members);
}

var Lazy = (function () {
    function Lazy(factory) {
        this.factory = factory;
        this.isValueCreated = false;
    }
    Object.defineProperty(Lazy.prototype, "value", {
        get: function () {
            if (!this.isValueCreated) {
                this.createdValue = this.factory();
                this.isValueCreated = true;
            }
            return this.createdValue;
        },
        enumerable: true,
        configurable: true
    });
    return Lazy;
}());

function storeArguments(values) {
  return [_Array$from(values), mapIndexed$1(function (i, _arg1) {
    return new Expression("MemberExpression", [new Expression("IdentifierExpression", ["_stored", null]), new Expression("NumericLiteral", [i, null]), true, null]);
  }, values)];
}
function evaluateExpression(_stored, expr) {
  var prog = new Program$1(null, ofArray$1([new Statement("ExpressionStatement", [expr, null])]));
  var code = Babel.transformFromAst(Serializer.serializeProgram(prog), "", new BabelOptions(["es2015"]));
  Log.trace("interpreter", "Interpreter evaluating: %O using values %O", code.code, _stored);

  try {
    var s = series.create(function (builder_) {
      return builder_.Delay(function () {
        return builder_.Return([]);
      });
    }(singleton$2), "", "", "");
    new RuntimeContext("lol", "", "troll");

    (function (c) {
      return function (s_1) {
        return trimLeft(c, s_1);
      };
    });

    (function (f) {
      return function (g) {
        return function (data) {
          return convertTupleSequence(f, g, data);
        };
      };
    });

    (function (arg00) {
      return chart.bar(arg00);
    });

    table.create(s);
    date$1.now();
    series.values(new Int32Array([1]));
    placeholder.create("");

    (function (arg00_1) {
      return youguess.line(arg00_1);
    });

    _stored.length;
    return eval(code.code);
  } catch (e) {
    Log.exn("interpreter", "Evaluation failed: %O", e);
    throw new Error();
  }
}
function evaluateExpr(args, exprBuilder) {
  var patternInput = storeArguments(args);
  return evaluateExpression(patternInput[0], exprBuilder(patternInput[1]));
}
function evaluatePreview(ent, value) {
  var previewName = new Name("preview");
  Log.trace("interpreter", "Evaluating preview on: %O (%s)", ent, formatType(ent.Type));
  var matchValue = ent.Type;
  var $var127 = void 0;

  if (matchValue != null) {
    if (matchValue.Case === "Object") {
      var activePatternResult6460 = function (obj) {
        return _FindMember___(previewName, obj);
      }(matchValue.Fields[0]);

      if (activePatternResult6460 != null) {
        $var127 = [0, activePatternResult6460];
      } else {
        $var127 = [1];
      }
    } else {
      $var127 = [1];
    }
  } else {
    $var127 = [1];
  }

  switch ($var127[0]) {
    case 0:
      if ($var127[1].Type.Case === "Method") {
        return evaluateExpr(ofArray$1([value]), function (inst) {
          return BabelOperators.op_DivideAtDivide($var127[1].Emitter.Emit(inst.head), new List$1());
        });
      } else {
        return evaluateExpr(ofArray$1([value]), function (inst_1) {
          return $var127[1].Emitter.Emit(inst_1.head);
        });
      }

    case 1:
      return null;
  }
}
function evaluateEntity(e) {
  var $var128 = e.Kind.Case === "Variable" ? [4, e.Kind.Fields[1]] : e.Kind.Case === "GlobalValue" ? [5, e.Kind.Fields[1], e.Kind.Fields[0]] : e.Kind.Case === "Member" ? e.Kind.Fields[1].Kind.Case === "MemberName" ? [6, e.Kind.Fields[0], e.Kind.Fields[1].Kind.Fields[0]] : [8, e.Kind.Fields[0]] : e.Kind.Case === "Call" ? e.Kind.Fields[1].Kind.Case === "ArgumentList" ? [7, e.Kind.Fields[1].Kind.Fields[0], e.Kind.Fields[0]] : [9, e.Kind.Fields[0]] : e.Kind.Case === "Operator" ? e.Kind.Fields[1].Case === "Power" ? [10, e.Kind.Fields[0], e.Kind.Fields[2]] : [11, e.Kind.Fields[0], e.Kind.Fields[1], e.Kind.Fields[2]] : e.Kind.Case === "List" ? [12, e.Kind.Fields[0]] : e.Kind.Case === "Placeholder" ? [13, e.Kind.Fields[1]] : e.Kind.Case === "ArgumentList" ? [14] : e.Kind.Case === "NamedParam" ? [14] : e.Kind.Case === "MemberName" ? [14] : e.Kind.Case === "Binding" ? [14] : e.Kind.Case === "Root" ? [14] : e.Kind.Case === "CallSite" ? [14] : e.Kind.Case === "Function" ? [15] : e.Kind.Case === "Program" ? [15] : e.Kind.Case === "LetCommand" ? [15] : e.Kind.Case === "RunCommand" ? [15] : e.Kind.Fields[0].Case === "Number" ? [1, e.Kind.Fields[0].Fields[0]] : e.Kind.Fields[0].Case === "String" ? [2, e.Kind.Fields[0].Fields[0]] : e.Kind.Fields[0].Case === "Empty" ? [3] : [0, e.Kind.Fields[0].Fields[0]];

  var _ret = function () {
    switch ($var128[0]) {
      case 0:
        return {
          v: $var128[1]
        };

      case 1:
        return {
          v: $var128[1]
        };

      case 2:
        return {
          v: $var128[1]
        };

      case 3:
        return {
          v: null
        };

      case 4:
        return {
          v: defaultArg($var128[1].Value, null, function (v) {
            return v.Value;
          })
        };

      case 5:
        if ($var128[1] != null) {
          return {
            v: evaluateExpression([], $var128[1])
          };
        } else {
          return {
            v: null
          };
        }

      case 6:
        var matchValue = $var128[1].Type;
        var $var129 = void 0;

        if (matchValue.Case === "Object") {
          var activePatternResult6467 = function (obj) {
            return _FindMember___($var128[2], obj);
          }(matchValue.Fields[0]);

          if (activePatternResult6467 != null) {
            $var129 = [0, activePatternResult6467];
          } else {
            $var129 = [1];
          }
        } else {
          $var129 = [1];
        }

        switch ($var129[0]) {
          case 0:
            return {
              v: evaluateExpr(ofArray$1([getValue($var128[1])]), function (inst) {
                return $var129[1].Emitter.Emit(inst.head);
              })
            };

          case 1:
            return {
              v: null
            };
        }

      case 7:
        var pb = toList(takeWhile(function (_arg1) {
          return _arg1.Kind.Case === "NamedParam" ? false : true;
        }, $var128[1]));
        var nb = toList(skipWhile(function (_arg2) {
          return _arg2.Kind.Case === "NamedParam" ? false : true;
        }, $var128[1]));

        var positionBased = _Array$from(map$5(function (e_1) {
          return getValue(e_1);
        }, pb));

        var nameBased = new _Map(choose$1(function (_arg3) {
          if (_arg3.Kind.Case === "NamedParam") {
            var value = _arg3.Kind.Fields[1];
            var name = _arg3.Kind.Fields[0];
            return [name.Name, getValue(value)];
          } else {
            return null;
          }
        }, nb));
        var expectedArgs = void 0;
        var matchValue_1 = $var128[2].Type;

        if (matchValue_1.Case === "Method") {
          expectedArgs = matchValue_1.Fields[0];
        } else {
          expectedArgs = new List$1();
        }

        var pars = mapIndexed$1(function (i, tupledArg) {
          return i < positionBased.length ? positionBased[i] : nameBased.has(tupledArg[0]) ? nameBased.get(tupledArg[0]) : null;
        }, expectedArgs);
        var $var130 = $var128[2].Kind.Case === "Member" ? $var128[2].Kind.Fields[1].Kind.Case === "MemberName" ? [0, $var128[2].Kind.Fields[0], $var128[2].Kind.Fields[1].Kind.Fields[0]] : [1] : [1];

        var _ret2 = function () {
          switch ($var130[0]) {
            case 0:
              var instValue = getValue($var130[1]);
              var matchValue_2 = $var130[1].Type;
              var $var131 = void 0;

              if (matchValue_2 != null) {
                if (matchValue_2.Case === "Object") {
                  var activePatternResult6476 = function (obj_1) {
                    return _FindMember___($var130[2], obj_1);
                  }(matchValue_2.Fields[0]);

                  if (activePatternResult6476 != null) {
                    $var131 = [0, activePatternResult6476];
                  } else {
                    $var131 = [1];
                  }
                } else {
                  $var131 = [1];
                }
              } else {
                $var131 = [1];
              }

              switch ($var131[0]) {
                case 0:
                  return {
                    v: {
                      v: evaluateExpr(new List$1(instValue, pars), function (stored) {
                        return BabelOperators.op_DivideAtDivide($var131[1].Emitter.Emit(stored.head), stored.tail);
                      })
                    }
                  };

                case 1:
                  return {
                    v: {
                      v: evaluateExpr(new List$1(instValue, pars), function (stored_1) {
                        return BabelOperators.op_DivideAtDivide(BabelOperators.op_DivideQmarkDivide(stored_1.head, BabelOperators.str($var130[2].Name)), stored_1.tail);
                      })
                    }
                  };
              }

            case 1:
              var instValue_1 = getValue($var128[2]);
              return {
                v: {
                  v: evaluateExpr(new List$1(instValue_1, pars), function (stored_2) {
                    return BabelOperators.op_DivideAtDivide(stored_2.head, stored_2.tail);
                  })
                }
              };
          }
        }();

        if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;

      case 8:
        Log.error("interpreter", "typeCheckEntity: Member access is missing member name!");
        return {
          v: null
        };

      case 9:
        Log.error("interpreter", "typeCheckEntity: Call to %s is missing argument list!", Entity_get_Name.bind(lastChainElement($var128[1]))());
        return {
          v: null
        };

      case 10:
        return {
          v: evaluateExpr(ofArray$1([getValue($var128[1]), getValue($var128[2])]), function (_arg4) {
            var $var132 = _arg4.tail != null ? _arg4.tail.tail != null ? _arg4.tail.tail.tail == null ? [0, _arg4.head, _arg4.tail.head] : [1] : [1] : [1];

            switch ($var132[0]) {
              case 0:
                return BabelOperators.op_DivideAtDivide(BabelOperators.op_Dynamic(BabelOperators.ident("Math"), "pow"), ofArray$1([$var132[1], $var132[2]]));

              case 1:
                throw new Error("evaluateEntity: Expected two arguments");
            }
          })
        };

      case 11:
        return {
          v: evaluateExpr(ofArray$1([getValue($var128[1]), getValue($var128[3])]), function (_arg5) {
            var $var133 = _arg5.tail != null ? _arg5.tail.tail != null ? _arg5.tail.tail.tail == null ? [0, _arg5.head, _arg5.tail.head] : [1] : [1] : [1];

            switch ($var133[0]) {
              case 0:
                var op = void 0;

                if ($var128[2].Case === "Equals") {
                  op = new BinaryOperator("BinaryEqualStrict", []);
                } else if ($var128[2].Case === "Plus") {
                  op = new BinaryOperator("BinaryPlus", []);
                } else if ($var128[2].Case === "Minus") {
                  op = new BinaryOperator("BinaryMinus", []);
                } else if ($var128[2].Case === "Multiply") {
                  op = new BinaryOperator("BinaryMultiply", []);
                } else if ($var128[2].Case === "Divide") {
                  op = new BinaryOperator("BinaryDivide", []);
                } else if ($var128[2].Case === "GreaterThan") {
                  op = new BinaryOperator("BinaryGreater", []);
                } else if ($var128[2].Case === "LessThan") {
                  op = new BinaryOperator("BinaryLess", []);
                } else if ($var128[2].Case === "GreaterThanOrEqual") {
                  op = new BinaryOperator("BinaryGreaterOrEqual", []);
                } else if ($var128[2].Case === "LessThanOrEqual") {
                  op = new BinaryOperator("BinaryLessOrEqual", []);
                } else if ($var128[2].Case === "Power") {
                  throw new Error("evaluateEntity: Power is not a binary operation");
                } else {
                  op = new BinaryOperator("BinaryModulus", []);
                }

                return new Expression("BinaryExpression", [op, $var133[1], $var133[2], null]);

              case 1:
                throw new Error("evaluateEntity: Expected two arguments");
            }
          })
        };

      case 12:
        return {
          v: evaluateExpr(map$5(function (e_2) {
            return getValue(e_2);
          }, $var128[1]), function (elements) {
            return new Expression("ArrayExpression", [elements, null]);
          })
        };

      case 13:
        return {
          v: getValue($var128[1])
        };

      case 14:
        return {
          v: null
        };

      case 15:
        Log.error("interpreter", "Cannot evaluate entity (probably not supported yet): %O", e);
        return {
          v: null
        };
    }
  }();

  if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
}
function ensureValue(e) {
  if (function () {
    return e.Value == null;
  }(null)) {
    (function () {
      var matchValue = evaluateEntity(e);

      if (matchValue != null) {
        e.Value = new EntityValue(matchValue, new Lazy(function () {
          return evaluatePreview(e, matchValue);
        }));
      }
    })();
  }
}
function getValue(e) {
  if (function () {
    return e.Value == null;
  }(null)) {
    Log.error("interpreter", "getValue: Value of entity %O has not been evaluated.", e);
  }

  return e.Value.Value;
}
function evaluateEntityTree(e) {
  var visited = new _Map();

  var loop = function loop(e_1) {
    if (!visited.has(e_1.Symbol) ? function () {
      return e_1.Value == null;
    }(null) : false) {
      visited.set(e_1.Symbol, true);
      var inputSequence = Entity_get_Antecedents.bind(e_1)();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _getIterator(inputSequence), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var e_2 = _step.value;
          loop(e_2);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      ensureValue(e_1);
    }
  };

  loop(e);
  return e.Value;
}
function globalEntity(name, meta, typ, expr) {
  var Kind = new EntityKind("GlobalValue", [new Name(name), expr]);

  var _Symbol = _Symbol2();

  var Type$$1 = typ;
  return new Entity(Kind, _Symbol, null, meta, Type$$1, new List$1());
}
function evaluate(globals, e) {
  var res = evaluateEntityTree(e);
  return res;
}

function listsEqual(l1, l2, f) {
  var matchValue = [l1, l2];
  var $var85 = matchValue[0].tail != null ? matchValue[1].tail != null ? function () {
    var ys = matchValue[1].tail;
    var y = matchValue[1].head;
    var xs = matchValue[0].tail;
    var x = matchValue[0].head;
    return f(x)(y);
  }() ? [1, matchValue[0].head, matchValue[0].tail, matchValue[1].head, matchValue[1].tail] : [2] : [2] : matchValue[1].tail == null ? [0] : [2];

  switch ($var85[0]) {
    case 0:
      return true;

    case 1:
      return listsEqual($var85[2], $var85[4], f);

    case 2:
      return false;
  }
}
function optionsEqual(o1, o2, f) {
  var matchValue = [o1, o2];
  var $var86 = matchValue[0] != null ? matchValue[1] != null ? [1, matchValue[0], matchValue[1]] : [2] : matchValue[1] == null ? [0] : [2];

  switch ($var86[0]) {
    case 0:
      return true;

    case 1:
      return f($var86[1])($var86[2]);

    case 2:
      return false;
  }
}
function typesEqual(t1, t2) {
  var _loop = function _loop() {
    var matchValue = [t1, t2];
    var $var87 = matchValue[0].Case === "Any" ? [0] : matchValue[0].Case === "List" ? matchValue[1].Case === "Any" ? [0] : matchValue[1].Case === "List" ? [1, matchValue[0].Fields[0], matchValue[1].Fields[0]] : [5] : matchValue[0].Case === "Method" ? matchValue[1].Case === "Any" ? [0] : matchValue[1].Case === "Method" ? [2, matchValue[0].Fields[0], matchValue[1].Fields[0], matchValue[0].Fields[1], matchValue[1].Fields[1]] : [5] : matchValue[0].Case === "Object" ? matchValue[1].Case === "Any" ? [0] : matchValue[1].Case === "Object" ? [3, matchValue[0].Fields[0], matchValue[1].Fields[0]] : [5] : matchValue[0].Case === "Primitive" ? matchValue[1].Case === "Any" ? [0] : matchValue[1].Case === "Primitive" ? [4, matchValue[0].Fields[0], matchValue[1].Fields[0]] : [5] : matchValue[1].Case === "Any" ? [0] : [5];

    switch ($var87[0]) {
      case 0:
        return {
          v: true
        };

      case 1:
        t1 = $var87[1];
        t2 = $var87[2];
        return "continue|typesEqual";

      case 2:
        if (optionsEqual($var87[3](toList(delay(function () {
          return collect(function (matchValue_1) {
            return singleton(matchValue_1[2]);
          }, $var87[1]);
        }))), $var87[4](toList(delay(function () {
          return collect(function (matchValue_2) {
            return singleton(matchValue_2[2]);
          }, $var87[2]);
        }))), function (t1_1) {
          return function (t2_1) {
            return typesEqual(t1_1, t2_1);
          };
        })) {
          return {
            v: listsEqual($var87[1], $var87[2], function (tupledArg) {
              return function (tupledArg_1) {
                return (tupledArg[0] === tupledArg_1[0] ? tupledArg[1] === tupledArg_1[1] : false) ? typesEqual(tupledArg[2], tupledArg_1[2]) : false;
              };
            })
          };
        } else {
          return {
            v: false
          };
        }

      case 3:
        return {
          v: $var87[1].TypeEquals($var87[2])
        };

      case 4:
        return {
          v: $var87[1].Equals($var87[2])
        };

      case 5:
        return {
          v: false
        };
    }
  };

  typesEqual: while (true) {
    var _ret = _loop();

    switch (_ret) {
      case "continue|typesEqual":
        continue typesEqual;

      default:
        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
    }
  }
}

var GenericParameterType = function () {
  function GenericParameterType(kind, name) {
    _classCallCheck(this, GenericParameterType);

    this.kind = kind;
    this.name = name;
  }

  _createClass(GenericParameterType, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.FSharpProvider.GenericParameterType",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          kind: "string",
          name: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return GenericParameterType;
}();
setType("TheGamma.TypeProviders.FSharpProvider.GenericParameterType", GenericParameterType);
var ArrayType = function () {
  function ArrayType(kind, element) {
    _classCallCheck(this, ArrayType);

    this.kind = kind;
    this.element = element;
  }

  _createClass(ArrayType, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.FSharpProvider.ArrayType",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          kind: "string",
          element: Any
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return ArrayType;
}();
setType("TheGamma.TypeProviders.FSharpProvider.ArrayType", ArrayType);
var PrimitiveType$1 = function () {
  function PrimitiveType$$1(kind, name) {
    _classCallCheck(this, PrimitiveType$$1);

    this.kind = kind;
    this.name = name;
  }

  _createClass(PrimitiveType$$1, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.FSharpProvider.PrimitiveType",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          kind: "string",
          name: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return PrimitiveType$$1;
}();
setType("TheGamma.TypeProviders.FSharpProvider.PrimitiveType", PrimitiveType$1);
var FunctionType = function () {
  function FunctionType(kind, _arguments, returns) {
    _classCallCheck(this, FunctionType);

    this.kind = kind;
    this.arguments = _arguments;
    this.returns = returns;
  }

  _createClass(FunctionType, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.FSharpProvider.FunctionType",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          kind: "string",
          arguments: FableArray(Any),
          returns: Any
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return FunctionType;
}();
setType("TheGamma.TypeProviders.FSharpProvider.FunctionType", FunctionType);
var NamedType = function () {
  function NamedType(kind, name, typargs) {
    _classCallCheck(this, NamedType);

    this.kind = kind;
    this.name = name;
    this.typargs = typargs;
  }

  _createClass(NamedType, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.FSharpProvider.NamedType",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          kind: "string",
          name: "string",
          typargs: FableArray(Any)
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return NamedType;
}();
setType("TheGamma.TypeProviders.FSharpProvider.NamedType", NamedType);
var Argument$1 = function () {
  function Argument$$1(name, optional, type) {
    _classCallCheck(this, Argument$$1);

    this.name = name;
    this.optional = optional;
    this.type = type;
  }

  _createClass(Argument$$1, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.FSharpProvider.Argument",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          name: "string",
          optional: "boolean",
          type: Any
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return Argument$$1;
}();
setType("TheGamma.TypeProviders.FSharpProvider.Argument", Argument$1);
var MethodMember = function () {
  function MethodMember(kind, name, typepars, _arguments, returns) {
    _classCallCheck(this, MethodMember);

    this.kind = kind;
    this.name = name;
    this.typepars = typepars;
    this.arguments = _arguments;
    this.returns = returns;
  }

  _createClass(MethodMember, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.FSharpProvider.MethodMember",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          kind: "string",
          name: "string",
          typepars: FableArray(Any),
          arguments: FableArray(Argument$1),
          returns: Any
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return MethodMember;
}();
setType("TheGamma.TypeProviders.FSharpProvider.MethodMember", MethodMember);
var PropertyMember = function () {
  function PropertyMember(kind, name, returns) {
    _classCallCheck(this, PropertyMember);

    this.kind = kind;
    this.name = name;
    this.returns = returns;
  }

  _createClass(PropertyMember, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.FSharpProvider.PropertyMember",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          kind: "string",
          name: "string",
          returns: Any
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return PropertyMember;
}();
setType("TheGamma.TypeProviders.FSharpProvider.PropertyMember", PropertyMember);
var ExportedType = function () {
  function ExportedType(name, typepars, _static, instance, members) {
    _classCallCheck(this, ExportedType);

    this.name = name;
    this.typepars = typepars;
    this.static = _static;
    this.instance = instance;
    this.members = members;
  }

  _createClass(ExportedType, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.FSharpProvider.ExportedType",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          name: "string",
          typepars: FableArray(Any),
          static: "boolean",
          instance: FableArray("string"),
          members: FableArray(Any)
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return ExportedType;
}();
setType("TheGamma.TypeProviders.FSharpProvider.ExportedType", ExportedType);
var TypeSchema = function () {
  function TypeSchema(caseName, fields) {
    _classCallCheck(this, TypeSchema);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(TypeSchema, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.FSharpProvider.TypeSchema",
        interfaces: ["FSharpUnion"],
        cases: {
          Function: [makeGeneric(List$1, {
            T: TypeSchema
          }), TypeSchema],
          GenericType: [Interface("TheGamma.TypeProviders.FSharpProvider.GenericTypeSchema")],
          List: [TypeSchema],
          Parameter: ["string"],
          Primitive: [Type]
        }
      };
    }
  }]);

  return TypeSchema;
}();
setType("TheGamma.TypeProviders.FSharpProvider.TypeSchema", TypeSchema);
function mapGenericType(typ, g) {
  var $var134 = typ.Case === "Delayed" ? [0, typ.Fields[0]] : typ.Case === "Object" ? hasInterface(typ.Fields[0], "TheGamma.TypeProviders.FSharpProvider.GenericTypeDefinition") ? [1, typ.Fields[0]] : [2, typ] : [2, typ];

  switch ($var134[0]) {
    case 0:
      return new Type("Delayed", [function (arg00) {
        return function (arg10) {
          return Async_CreateNamedFuture_Static(arg00, arg10);
        };
      }("applyTypes")(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(Async_AwaitFuture_Static($var134[1]), function (_arg1) {
            return builder_.Return(mapGenericType(_arg1, g));
          });
        });
      }(singleton$2))]);

    case 1:
      return new Type("Object", [$var134[1].Apply(toList(delay(function () {
        return map$3(function (t) {
          return new TypeSchema("Primitive", [t]);
        }, g($var134[1]));
      }))).Substitute(function (_arg1_1) {
        return null;
      })]);

    case 2:
      return $var134[1];
  }
}
function applyTypes(typ, tyargs) {
  var $var135 = typ.Case === "Delayed" ? [0, typ.Fields[0]] : typ.Case === "Object" ? hasInterface(typ.Fields[0], "TheGamma.TypeProviders.FSharpProvider.GenericTypeDefinition") ? [1, typ.Fields[0]] : [2] : [2];

  switch ($var135[0]) {
    case 0:
      return new Type("Delayed", [function (arg00) {
        return function (arg10) {
          return Async_CreateNamedFuture_Static(arg00, arg10);
        };
      }("applyTypes")(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(Async_AwaitFuture_Static($var135[1]), function (_arg1) {
            return builder_.Return(applyTypes(_arg1, tyargs));
          });
        });
      }(singleton$2))]);

    case 1:
      return new Type("Object", [$var135[1].Apply(toList(delay(function () {
        return map$3(function (t) {
          return new TypeSchema("Primitive", [t]);
        }, tyargs);
      }))).Substitute(function (_arg1_1) {
        return null;
      })]);

    case 2:
      throw new Error("applyTypes: Expected generic type definition");
  }
}
function unifyTypes(ctx, schemas, tys) {
  var _loop = function _loop() {
    var matchValue = [schemas, tys];
    var $var136 = matchValue[0].tail != null ? matchValue[0].head.Case === "GenericType" ? matchValue[1].tail != null ? matchValue[1].head.Case === "Object" ? hasInterface(matchValue[1].head.Fields[0], "TheGamma.TypeProviders.FSharpProvider.GenericType") ? function () {
      var ts_2 = matchValue[1].tail;
      var ss_2 = matchValue[0].tail;
      var gt = matchValue[1].head.Fields[0];
      var gs = matchValue[0].head.Fields[0];

      if (gt.TypeDefinition.FullName === gs.TypeDefinition.FullName) {
        return gs.TypeArguments.length === gt.TypeArguments.length;
      } else {
        return false;
      }
    }() ? [1, matchValue[0].head.Fields[0], matchValue[1].head.Fields[0], matchValue[0].tail, matchValue[1].tail] : [2] : [2] : [2] : [2] : [2] : matchValue[1].tail == null ? [0] : [2];

    switch ($var136[0]) {
      case 0:
        return {
          v: ctx
        };

      case 1:
        ctx = ctx;
        schemas = append$1($var136[1].TypeArguments, $var136[3]);
        tys = append$1($var136[2].TypeArguments, $var136[4]);
        return "continue|unifyTypes";

      case 2:
        var $var137 = matchValue[0].tail != null ? matchValue[0].head.Case === "Primitive" ? matchValue[1].tail != null ? function () {
          var ts_1 = matchValue[1].tail;
          var t2 = matchValue[1].head;
          var t1 = matchValue[0].head.Fields[0];
          var ss_1 = matchValue[0].tail;
          return typesEqual(t1, t2);
        }() ? [0, matchValue[0].tail, matchValue[0].head.Fields[0], matchValue[1].head, matchValue[1].tail] : [1] : [1] : [1] : [1];

        var _ret2 = function () {
          switch ($var137[0]) {
            case 0:
              ctx = ctx;
              schemas = $var137[1];
              tys = $var137[4];
              return {
                v: "continue|unifyTypes"
              };

            case 1:
              var $var138 = matchValue[0].tail != null ? matchValue[0].head.Case === "Parameter" ? matchValue[1].tail != null ? [0, matchValue[0].head.Fields[0], matchValue[0].tail, matchValue[1].head, matchValue[1].tail] : [3] : matchValue[0].head.Case === "List" ? matchValue[1].tail != null ? matchValue[1].head.Case === "List" ? [1, matchValue[0].head.Fields[0], matchValue[0].tail, matchValue[1].head.Fields[0], matchValue[1].tail] : [3] : [3] : matchValue[0].head.Case === "Function" ? matchValue[1].tail != null ? matchValue[1].head.Case === "Method" ? function () {
                var ts = matchValue[1].tail;
                var tr_1 = matchValue[1].head.Fields[1];
                var ta_1 = matchValue[1].head.Fields[0];
                var ss = matchValue[0].tail;
                var sr = matchValue[0].head.Fields[1];
                var sa = matchValue[0].head.Fields[0];
                return sa.length === ta_1.length;
              }() ? [2, matchValue[0].head.Fields[0], matchValue[0].head.Fields[1], matchValue[0].tail, matchValue[1].head.Fields[0], matchValue[1].head.Fields[1], matchValue[1].tail] : [3] : [3] : [3] : [3] : [3];

              switch ($var138[0]) {
                case 0:
                  ctx = new List$1([$var138[1], $var138[3]], ctx);
                  schemas = $var138[2];
                  tys = $var138[4];
                  return {
                    v: "continue|unifyTypes"
                  };

                case 1:
                  ctx = ctx;
                  schemas = new List$1($var138[1], $var138[2]);
                  tys = new List$1($var138[3], $var138[4]);
                  return {
                    v: "continue|unifyTypes"
                  };

                case 2:
                  var ta = toList(delay(function () {
                    return collect(function (matchValue_1) {
                      return singleton(matchValue_1[2]);
                    }, $var138[4]);
                  }));
                  var tr = defaultArg($var138[5](ta), new Type("Any", []));
                  ctx = ctx;
                  schemas = new List$1($var138[2], append$1($var138[1], $var138[3]));
                  tys = new List$1(tr, append$1(ta, $var138[6]));
                  return {
                    v: "continue|unifyTypes"
                  };

                case 3:
                  var $var139 = matchValue[0].tail == null ? [0] : matchValue[0].head.Case === "GenericType" ? [0] : matchValue[0].head.Case === "Primitive" ? [0] : matchValue[0].head.Case === "List" ? [0] : matchValue[0].head.Case === "Function" ? [0] : matchValue[1].tail == null ? [0] : [1];

                  switch ($var139[0]) {
                    case 0:
                      var matchValue_2 = [schemas, tys];
                      var $var140 = matchValue_2[0].tail != null ? matchValue_2[1].tail != null ? [0, matchValue_2[0].head, matchValue_2[1].head] : [1] : [1];

                      switch ($var140[0]) {
                        case 0:
                          Log.trace("providers", "Failed to unify types %O and %O", $var140[1], $var140[2]);
                          break;

                        case 1:
                          Log.trace("providers", "Failed to unify types %O and %O", schemas, tys);
                          break;
                      }

                      return {
                        v: {
                          v: null
                        }
                      };

                    case 1:
                      throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\thegamma\\providers/fsharp.fs", 126, 8);
                  }

              }

          }
        }();

        if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
    }
  };

  unifyTypes: while (true) {
    var _ret = _loop();

    switch (_ret) {
      case "continue|unifyTypes":
        continue unifyTypes;

      default:
        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
    }
  }
}
function substituteTypeParams(assigns, schema) {
  if (schema.Case === "Primitive") {
    return schema.Fields[0];
  } else if (schema.Case === "List") {
    return new Type("List", [substituteTypeParams(assigns, schema.Fields[0])]);
  } else if (schema.Case === "Parameter") {
    var _matchValue = assigns(schema.Fields[0]);

    if (_matchValue != null) {
      return _matchValue;
    } else {
      throw new Error("substituteTypeParams: unresolved type parameter");
    }
  } else if (schema.Case === "Function") {
    var args = map$5(function (it) {
      return ["", false, substituteTypeParams(assigns, it)];
    }, schema.Fields[0]);
    return new Type("Method", [args, function (_arg1) {
      return substituteTypeParams(assigns, schema.Fields[1]);
    }]);
  } else {
    return new Type("Object", [schema.Fields[0].Substitute(assigns)]);
  }
}
function partiallySubstituteTypeParams(assigns, schema) {
  var $var141 = schema.Case === "Primitive" ? [0, schema.Fields[0]] : schema.Case === "List" ? [1, schema.Fields[0]] : schema.Case === "Parameter" ? function () {
    return assigns(schema.Fields[0]) != null;
  }(null) ? [2, schema.Fields[0]] : [3] : [3];

  switch ($var141[0]) {
    case 0:
      return new TypeSchema("Primitive", [$var141[1]]);

    case 1:
      return new TypeSchema("List", [partiallySubstituteTypeParams(assigns, $var141[1])]);

    case 2:
      return new TypeSchema("Primitive", [assigns($var141[1])]);

    case 3:
      if (schema.Case === "Parameter") {
        return new TypeSchema("Parameter", [schema.Fields[0]]);
      } else if (schema.Case === "Function") {
        return new TypeSchema("Function", [map$5(function (schema_1) {
          return partiallySubstituteTypeParams(assigns, schema_1);
        }, schema.Fields[0]), partiallySubstituteTypeParams(assigns, schema.Fields[1])]);
      } else if (schema.Case === "GenericType") {
        return new TypeSchema("GenericType", [_defineProperty({
          get Members() {
            throw new Error("Uninstantiated generic type schema");
          },

          TypeEquals: function (_arg1) {
            throw new Error("Uninstantiated generic type schema");
          },

          get TypeArguments() {
            return map$5(function (schema_1) {
              return partiallySubstituteTypeParams(assigns, schema_1);
            }, schema.Fields[0].TypeArguments);
          },

          get TypeDefinition() {
            return schema.Fields[0].TypeDefinition;
          },

          Substitute: function (assigns2) {
            return schema.Fields[0].Substitute(function (n) {
              var matchValue = [assigns2(n), assigns(n)];
              var $var142 = matchValue[0] != null ? [0, matchValue[0]] : matchValue[1] != null ? [0, matchValue[1]] : [1];

              switch ($var142[0]) {
                case 0:
                  return $var142[1];

                case 1:
                  return null;
              }
            });
          }
        }, _Symbol.reflection, function () {
          return {
            interfaces: ["TheGamma.TypeProviders.FSharpProvider.GenericTypeSchema"]
          };
        })]);
      } else {
        throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\thegamma\\providers/fsharp.fs", 161, 8);
      }

  }
}
function importProvidedType(url, lookupNamed, exp) {
  var mapType = function mapType(t) {
    var matchValue = t.kind;

    switch (matchValue) {
      case "primitive":
        return new TypeSchema("Primitive", [function () {
          var matchValue_1 = t.name;

          switch (matchValue_1) {
            case "object":
              return new Type("Any", []);

            case "int":
            case "float":
              return new Type("Primitive", [new PrimitiveType("Number", [])]);

            case "string":
              return new Type("Primitive", [new PrimitiveType("String", [])]);

            case "bool":
              return new Type("Primitive", [new PrimitiveType("Bool", [])]);

            case "unit":
              return new Type("Primitive", [new PrimitiveType("Unit", [])]);

            case "date":
              return new Type("Primitive", [new PrimitiveType("Date", [])]);

            default:
              throw new Error("provideFSharpType: Unsupported type: " + matchValue_1);
          }
        }()]);

      case "function":
        var t_1 = t;
        return new TypeSchema("Function", [toList(_Array$from(map$3(mapType, t_1.arguments))), mapType(t_1.returns)]);

      case "named":
        var t_2 = t;
        var tyargs = ofArray$1(_Array$from(map$3(mapType, t_2.typargs)));
        var matchValue_2 = lookupNamed(t_2.name);
        var $var143 = matchValue_2.Case === "Object" ? hasInterface(matchValue_2.Fields[0], "TheGamma.TypeProviders.FSharpProvider.GenericTypeDefinition") ? [0, matchValue_2.Fields[0]] : [1, matchValue_2] : [1, matchValue_2];

        switch ($var143[0]) {
          case 0:
            if ($var143[1].TypeParameterCount !== tyargs.length) {
              throw new Error("provideFSharpType: Named type has mismatching nuumber of arguments");
            }

            return new TypeSchema("GenericType", [$var143[1].Apply(tyargs)]);

          case 1:
            return new TypeSchema("Primitive", [$var143[1]]);
        }

      case "parameter":
        return new TypeSchema("Parameter", [t.name]);

      case "array":
        return new TypeSchema("List", [mapType(t.element)]);

      default:
        throw new Error("provideFSharpType: Unexpected type");
    }
  };

  var getTypeParameters = function getTypeParameters(typars) {
    return ofArray$1(_Array$from(map$3(function (t_3) {
      var matchValue_3 = function (arg00) {
        return mapType(arg00);
      }(t_3);

      if (matchValue_3.Case === "Parameter") {
        return matchValue_3.Fields[0];
      } else {
        throw new Error("importProvidedType: expected type parameter");
      }
    }, typars)));
  };

  var generateMembers = function generateMembers(assigns) {
    return _Array$from(choose(function (m) {
      if (m.kind === "property") {
        var _ret3 = function () {
          var m_1 = m;
          var retTyp = substituteTypeParams(assigns, mapType(m_1.returns));
          var emitter = new Emitter(function (inst) {
            return new Expression("MemberExpression", [inst, new Expression("IdentifierExpression", [m_1.name, null]), false, null]);
          });
          return {
            v: new Member(m_1.name, retTyp, new List$1(), emitter)
          };
        }();

        if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
      } else if (m.kind === "method") {
        var _ret4 = function () {
          var m_2 = m;
          var typars_1 = getTypeParameters(m_2.typepars);

          var assigns_1 = function assigns_1(n) {
            if (exists(function (y) {
              return n === y;
            }, typars_1)) {
              return null;
            } else {
              return assigns(n);
            }
          };

          var args = toList(delay(function () {
            return map$3(function (a) {
              return [a.name, a.optional, partiallySubstituteTypeParams(assigns_1, mapType(a.type))];
            }, m_2.arguments);
          }));
          var emitter_1 = new Emitter(function (inst_1) {
            return new Expression("MemberExpression", [inst_1, new Expression("IdentifierExpression", [m_2.name, null]), false, null]);
          });
          var retTyp_1 = partiallySubstituteTypeParams(assigns_1, mapType(m_2.returns));

          var retFunc = function retFunc(tys) {
            Log.trace("providers", "F# provider unifying: %O, %O", _Array$from(delay(function () {
              return collect(function (matchValue_4) {
                return singleton(matchValue_4[2]);
              }, args);
            })), _Array$from(tys));
            var matchValue_6 = unifyTypes(new List$1(), toList(delay(function () {
              return collect(function (matchValue_5) {
                return singleton(matchValue_5[2]);
              }, args);
            })), tys);

            if (matchValue_6 != null) {
              var assigns_3 = fold(function (assigns_2, assign) {
                var matchValue_7 = [assigns_2, assign];
                var $var144 = matchValue_7[0] != null ? matchValue_7[1][1] != null ? [0, matchValue_7[1][1], matchValue_7[0], matchValue_7[1][0]] : [1] : [1];

                switch ($var144[0]) {
                  case 0:
                    return new List$1([$var144[3], $var144[1]], $var144[2]);

                  case 1:
                    return null;
                }
              }, new List$1(), map$3(function (tupledArg) {
                return [tupledArg[0], fold(function (st, tupledArg_1) {
                  return st == null ? null : typesEqual(st, tupledArg_1[1]) ? tupledArg_1[1] : null;
                }, new Type("Any", []), tupledArg[1])];
              }, groupBy$1(function (tuple) {
                return tuple[0];
              }, matchValue_6)));
              var $var145 = assigns_3 != null ? assigns_3.length === typars_1.length ? [0, assigns_3] : [1] : [1];

              var _ret5 = function () {
                switch ($var145[0]) {
                  case 0:
                    var assigns_4 = new _Map($var145[1]);

                    var subst = function subst(n_1) {
                      if (assigns_4.has(n_1)) {
                        return assigns_4.get(n_1);
                      } else {
                        return null;
                      }
                    };

                    return {
                      v: substituteTypeParams(subst, retTyp_1)
                    };

                  case 1:
                    return {
                      v: null
                    };
                }
              }();

              if ((typeof _ret5 === "undefined" ? "undefined" : _typeof(_ret5)) === "object") return _ret5.v;
            } else {
              return null;
            }
          };

          var args_1 = toList(delay(function () {
            return collect(function (matchValue_8) {
              return singleton([matchValue_8[0], matchValue_8[1], substituteTypeParams(function (_arg2) {
                return new Type("Any", []);
              }, matchValue_8[2])]);
            }, args);
          }));
          return {
            v: new Member(m_2.name, new Type("Method", [args_1, retFunc]), new List$1(), emitter_1)
          };
        }();

        if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
      } else {
        return null;
      }
    }, exp.members));
  };

  var objectType = void 0;
  var matchValue_9 = getTypeParameters(exp.typepars);

  if (matchValue_9.tail == null) {
    objectType = _defineProperty({
      get Members() {
        return generateMembers(function (_arg3) {
          return null;
        });
      },

      TypeEquals: function (_arg1) {
        return false;
      }
    }, _Symbol.reflection, function () {
      return {
        interfaces: ["TheGamma.ObjectType"]
      };
    });
  } else {
    objectType = _defineProperty({
      get TypeParameterCount() {
        return matchValue_9.length;
      },

      get FullName() {
        return concatUrl(url, exp.name);
      },

      get Members() {
        return fsFormat("Uninstantiated generic type definition (%s)")(function (x) {
          throw new Error(x);
        })(this.FullName);
      },

      TypeEquals: function (_arg2) {
        return fsFormat("Uninstantiated generic type definition (%s)")(function (x) {
          throw new Error(x);
        })(this.FullName);
      },
      Apply: function (tyargs) {
        var $var146 = this;
        return _defineProperty({
          get Members() {
            throw new Error("Uninstantiated generic type schema");
          },

          get TypeDefinition() {
            return $var146;
          },

          TypeEquals: function (_arg3) {
            throw new Error("Uninstantiated generic type schema");
          },
          Substitute: function (assigns) {
            var tyArgLookup = new _Map(toList(zip(matchValue_9, tyargs)));
            var members = new Lazy(function () {
              return generateMembers(function (n) {
                var matchValue = tryGetValue(tyArgLookup, n, null);

                if (matchValue[0]) {
                  return substituteTypeParams(assigns, matchValue[1]);
                } else {
                  return null;
                }
              });
            });
            var $var147 = this;
            return _defineProperty({
              get TypeArguments() {
                return map$5(function (schema) {
                  return substituteTypeParams(assigns, schema);
                }, tyargs);
              },

              get TypeDefinition() {
                return $var146;
              },

              get Members() {
                return members.value;
              },

              TypeEquals: function (t2) {
                if (hasInterface(t2, "TheGamma.TypeProviders.FSharpProvider.GenericType")) {
                  if (t2.TypeDefinition.FullName === this.TypeDefinition.FullName) {
                    return listsEqual(this.TypeArguments, t2.TypeArguments, function (t1) {
                      return function (t2_1) {
                        return typesEqual(t1, t2_1);
                      };
                    });
                  } else {
                    return false;
                  }
                } else {
                  return false;
                }
              }
            }, _Symbol.reflection, function () {
              return {
                interfaces: ["TheGamma.TypeProviders.FSharpProvider.GenericType"]
              };
            });
          },

          get TypeArguments() {
            return tyargs;
          }

        }, _Symbol.reflection, function () {
          return {
            interfaces: ["TheGamma.TypeProviders.FSharpProvider.GenericTypeSchema"]
          };
        });
      }
    }, _Symbol.reflection, function () {
      return {
        interfaces: ["TheGamma.TypeProviders.FSharpProvider.GenericTypeDefinition"]
      };
    });
  }

  return new Type("Object", [objectType]);
}
function provideFSharpTypes(lookupNamed, url) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.Bind(Http.Request("GET", url), function (_arg1) {
        var expTys = JSON.parse(_arg1);
        return builder_.Return(toList(delay(function () {
          return map$3(function (exp) {
            var ty = importProvidedType(url, lookupNamed, exp);

            if (exp.static) {
              var e = fold(function (chain, s) {
                return chain != null ? new Expression("MemberExpression", [chain, new Expression("IdentifierExpression", [s, null]), false, null]) : new Expression("IdentifierExpression", [s, null]);
              }, null, exp.instance);
              var ty_1 = mapGenericType(ty, function (gtd) {
                return toList(delay(function () {
                  return map$3(function (i) {
                    return new Type("Any", []);
                  }, range(1, gtd.TypeParameterCount));
                }));
              });
              return new ProvidedType("GlobalValue", [exp.name, new List$1(), e, ty_1]);
            } else {
              return new ProvidedType("NamedType", [exp.name, ty]);
            }
          }, expTys);
        })));
      });
    });
  }(singleton$2);
}

var AnyType = function () {
  function AnyType(kind) {
    _classCallCheck(this, AnyType);

    this.kind = kind;
  }

  _createClass(AnyType, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.RestProvider.AnyType",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          kind: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return AnyType;
}();
setType("TheGamma.TypeProviders.RestProvider.AnyType", AnyType);
var TypeNested = function () {
  function TypeNested(kind, endpoint) {
    _classCallCheck(this, TypeNested);

    this.kind = kind;
    this.endpoint = endpoint;
  }

  _createClass(TypeNested, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.RestProvider.TypeNested",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          kind: "string",
          endpoint: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return TypeNested;
}();
setType("TheGamma.TypeProviders.RestProvider.TypeNested", TypeNested);
var TypeProvider = function () {
  function TypeProvider(kind, provider, endpoint) {
    _classCallCheck(this, TypeProvider);

    this.kind = kind;
    this.provider = provider;
    this.endpoint = endpoint;
  }

  _createClass(TypeProvider, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.RestProvider.TypeProvider",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          kind: "string",
          provider: "string",
          endpoint: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return TypeProvider;
}();
setType("TheGamma.TypeProviders.RestProvider.TypeProvider", TypeProvider);
var TypePrimitive = function () {
  function TypePrimitive(kind, type, endpoint) {
    _classCallCheck(this, TypePrimitive);

    this.kind = kind;
    this.type = type;
    this.endpoint = endpoint;
  }

  _createClass(TypePrimitive, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.RestProvider.TypePrimitive",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          kind: "string",
          type: Any,
          endpoint: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return TypePrimitive;
}();
setType("TheGamma.TypeProviders.RestProvider.TypePrimitive", TypePrimitive);
var Parameter = function () {
  function Parameter(name, type) {
    _classCallCheck(this, Parameter);

    this.name = name;
    this.type = type;
  }

  _createClass(Parameter, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.RestProvider.Parameter",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          name: "string",
          type: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return Parameter;
}();
setType("TheGamma.TypeProviders.RestProvider.Parameter", Parameter);
var Documentation$1 = function () {
  function Documentation$$1(title, details) {
    _classCallCheck(this, Documentation$$1);

    this.title = title;
    this.details = details;
  }

  _createClass(Documentation$$1, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.RestProvider.Documentation",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          title: Option("string"),
          details: Option("string")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return Documentation$$1;
}();
setType("TheGamma.TypeProviders.RestProvider.Documentation", Documentation$1);
var Member$1 = function () {
  function Member$$1(name, returns, parameters, documentation, schema, trace) {
    _classCallCheck(this, Member$$1);

    this.name = name;
    this.returns = returns;
    this.parameters = parameters;
    this.documentation = documentation;
    this.schema = schema;
    this.trace = trace;
  }

  _createClass(Member$$1, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.RestProvider.Member",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          name: "string",
          returns: AnyType,
          parameters: Option(FableArray(Parameter)),
          documentation: Option(Any),
          schema: Option(Any),
          trace: FableArray("string")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return Member$$1;
}();
setType("TheGamma.TypeProviders.RestProvider.Member", Member$1);
var ResultType = function () {
  function ResultType(caseName, fields) {
    _classCallCheck(this, ResultType);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(ResultType, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.RestProvider.ResultType",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Generic: ["string", FableArray(ResultType)],
          Primitive: ["string"],
          Record: [FableArray(Tuple(["string", ResultType]))]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return ResultType;
}();
setType("TheGamma.TypeProviders.RestProvider.ResultType", ResultType);
var RawField = function () {
  function RawField(name, type) {
    _classCallCheck(this, RawField);

    this.name = name;
    this.type = type;
  }

  _createClass(RawField, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.RestProvider.RawField",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          name: "string",
          type: Any
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return RawField;
}();
setType("TheGamma.TypeProviders.RestProvider.RawField", RawField);
var RawResultType = function () {
  function RawResultType(name, fields, params) {
    _classCallCheck(this, RawResultType);

    this.name = name;
    this.fields = fields;
    this.params = params;
  }

  _createClass(RawResultType, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.RestProvider.RawResultType",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          name: "string",
          fields: FableArray(RawField),
          params: FableArray(Any)
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return RawResultType;
}();
setType("TheGamma.TypeProviders.RestProvider.RawResultType", RawResultType);
function parseDoc(json) {
  if (function () {
    return json == null;
  }(null)) {
    return new Documentation("None", []);
  } else if (typeof json === "string") {
    return new Documentation("Text", [json]);
  } else {
    var doc = json;
    var matchValue = [doc.title, doc.details];
    var $var148 = matchValue[0] != null ? matchValue[1] != null ? [0, matchValue[1], matchValue[0]] : [1] : [1];

    switch ($var148[0]) {
      case 0:
        return new Documentation("Details", [$var148[2], $var148[1]]);

      case 1:
        return new Documentation("None", []);
    }
  }
}
function fromRawType(json) {
  if (typeof json === "string") {
    return new ResultType("Primitive", [json]);
  } else {
    var res = json;

    if (res.name === "record") {
      return new ResultType("Record", [res.fields.map(function (f) {
        return [f.name, fromRawType(f.type)];
      })]);
    } else {
      return new ResultType("Generic", [res.name, _Array$from(map$3(function (json_1) {
        return fromRawType(json_1);
      }, res.params))]);
    }
  }
}
function trimLeft$1(c, s) {
  return _Array$from(skipWhile(function (y) {
    return c === y;
  }, s.split(""))).join('');
}
function trimRight$1(c, s) {
  return _Array$from(skipWhile(function (y) {
    return c === y;
  }, s.split("").slice().reverse())).slice().reverse().join('');
}
function concatUrl$1(a, b) {
  return trimRight$1("/", a) + "/" + trimLeft$1("/", b);
}
function load(url, cookies) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.Bind(Http.Request("GET", url, null, cookies), function (_arg1) {
        var members = JSON.parse(_arg1);
        return builder_.Return(members);
      });
    });
  }(singleton$2);
}
function addTraceCall(inst, trace) {
  if (isEmpty(trace)) {
    return inst;
  } else {
    return BabelOperators.op_DivideAtDivide(BabelOperators.op_Dynamic(inst, "addTrace"), ofArray$1([BabelOperators.str(join("&", trace))]));
  }
}
function propAccess(trace) {
  return new Emitter(function (inst) {
    return addTraceCall(inst, trace);
  });
}
function methCall(argNames, trace) {
  return new Emitter(function (inst) {
    return BabelOperators.funcN(count(argNames), function (args) {
      var withTrace = addTraceCall(inst, trace);
      return function () {
        var folder = function folder(inst_1) {
          return function (tupledArg) {
            var trace_1 = new Expression("BinaryExpression", [new BinaryOperator("BinaryPlus", []), BabelOperators.str(tupledArg[0] + "="), tupledArg[1], null]);
            return BabelOperators.op_DivideAtDivide(BabelOperators.op_Dynamic(inst_1, "addTrace"), ofArray$1([trace_1]));
          };
        };

        return function (source) {
          return fold(function ($var149, $var150) {
            return folder($var149)($var150);
          }, withTrace, source);
        };
      }()(zip(argNames, args));
    });
  });
}
function dataCall(parser, trace, endp) {
  return new Emitter(function (inst) {
    var tr = propAccess(trace).Emit(inst);
    var mem = new Expression("MemberExpression", [tr, new Expression("IdentifierExpression", ["getValue", null]), false, null]);
    return parser(new Expression("CallExpression", [mem, ofArray$1([new Expression("StringLiteral", [endp, null])]), null]));
  });
}
function getTypeAndEmitter(lookupNamed, ty) {
  var $var151 = ty.Case === "Generic" ? ty.Fields[0] === "seq" ? ty.Fields[1].length === 1 ? ty.Fields[1][0].Case === "Generic" ? ty.Fields[1][0].Fields[0] === "tuple" ? function () {
    var testExpr = ty.Fields[1][0].Fields[1];
    return testExpr.length === 2;
  }() ? [3, ty.Fields[1][0].Fields[1][0], ty.Fields[1][0].Fields[1][1]] : [4, ty.Fields[1][0]] : [4, ty.Fields[1][0]] : [4, ty.Fields[1][0]] : [6] : [6] : ty.Case === "Record" ? [5, ty.Fields[0]] : ty.Fields[0] === "string" ? [0] : ty.Fields[0] === "int" ? [1] : ty.Fields[0] === "float" ? [1] : ty.Fields[0] === "date" ? [2] : [6];

  var _ret = function () {
    switch ($var151[0]) {
      case 0:
        return {
          v: [new Type("Primitive", [new PrimitiveType("String", [])]), function (x) {
            return x;
          }]
        };

      case 1:
        return {
          v: [new Type("Primitive", [new PrimitiveType("Number", [])]), function (e) {
            return BabelOperators.op_DivideAtDivide(BabelOperators.ident("Number"), ofArray$1([e]));
          }]
        };

      case 2:
        return {
          v: [new Type("Primitive", [new PrimitiveType("Date", [])]), function (e_1) {
            return new Expression("NewExpression", [BabelOperators.ident("Date"), ofArray$1([BabelOperators.op_DivideAtDivide(BabelOperators.op_Dynamic(BabelOperators.ident("Date"), "parse"), ofArray$1([e_1]))]), null]);
          }]
        };

      case 3:
        var patternInput = getTypeAndEmitter(lookupNamed, $var151[1]);
        var patternInput_1 = getTypeAndEmitter(lookupNamed, $var151[2]);
        var typ = applyTypes(lookupNamed("series"), ofArray$1([patternInput[0], patternInput_1[0]]));
        return {
          v: [typ, function (d) {
            return BabelOperators.op_DivideAtDivide(BabelOperators.op_Dynamic(BabelOperators.ident("series"), "create"), ofArray$1([BabelOperators.op_DivideAtDivide(BabelOperators.ident("convertTupleSequence"), ofArray$1([BabelOperators.func("v", patternInput[1]), BabelOperators.func("v", patternInput_1[1]), d])), BabelOperators.str("key"), BabelOperators.str("value"), BabelOperators.str("")]));
          }]
        };

      case 4:
        var patternInput_2 = getTypeAndEmitter(lookupNamed, $var151[1]);
        var serTy = applyTypes(lookupNamed("series"), ofArray$1([new Type("Primitive", [new PrimitiveType("Number", [])]), patternInput_2[0]]));
        return {
          v: [serTy, function (d_1) {
            return BabelOperators.op_DivideAtDivide(BabelOperators.op_Dynamic(BabelOperators.ident("series"), "ordinal"), ofArray$1([BabelOperators.op_DivideAtDivide(BabelOperators.ident("convertSequence"), ofArray$1([BabelOperators.func("v", patternInput_2[1]), d_1])), BabelOperators.str("key"), BabelOperators.str("value"), BabelOperators.str("")]));
          }]
        };

      case 5:
        var membs = $var151[1].map(function (tupledArg) {
          var patternInput_3 = getTypeAndEmitter(lookupNamed, tupledArg[1]);
          var emitter = new Emitter(function (inst) {
            return patternInput_3[1](BabelOperators.op_Dynamic(inst, tupledArg[0]));
          });
          return new Member(tupledArg[0], patternInput_3[0], ofArray$1([ProviderHelpers.docMeta(new Documentation("Text", [""]))]), emitter);
        });
        var obj = new Type("Object", [_defineProperty({
          get Members() {
            return membs;
          },

          TypeEquals: function (_arg1) {
            return false;
          }
        }, _Symbol.reflection, function () {
          return {
            interfaces: ["TheGamma.ObjectType"]
          };
        })]);
        return {
          v: [obj, function (x_1) {
            return x_1;
          }]
        };

      case 6:
        console.log("getTypeAndEmitter: Cannot handle %O", ty);
        throw new Error("getTypeAndEmitter: Cannot handle type");
    }
  }();

  if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
}
function mapParamType(_arg1) {
  switch (_arg1) {
    case "int":
    case "float":
      return new PrimitiveType("Number", []);

    default:
      throw new Error("mapParamType: Unsupported parameter type");
  }
}
var restTypeCache = new _Map();
function createRestType(lookupNamed, resolveProvider, root, cookies, url) {
  var guid = concatUrl$1(root, url) + cookies;
  var matchValue = tryGetValue(restTypeCache, guid, null);

  if (matchValue[0]) {
    return matchValue[1];
  } else {
    var future = function (builder_) {
      return builder_.Delay(function () {
        return builder_.Bind(load(concatUrl$1(root, url), cookies), function (_arg1) {
          var members = _arg1.map(function (m) {
            var schema = m.schema != null ? ofArray$1([function () {
              var Type$$1 = m.schema["@type"];
              return new Metadata("http://schema.org", Type$$1, m.schema);
            }()]) : new List$1();
            var matchValue_1 = m.returns.kind;

            var _ret2 = function () {
              switch (matchValue_1) {
                case "provider":
                  var returns = m.returns;
                  var patternInput = resolveProvider(returns.provider)(returns.endpoint);
                  return {
                    v: new Member(m.name, patternInput[0], new List$1(ProviderHelpers.docMeta(parseDoc(m.documentation)), schema), patternInput[1])
                  };

                case "nested":
                  var returns_1 = m.returns;
                  var retTyp = createRestType(lookupNamed, resolveProvider, root, cookies, returns_1.endpoint);

                  if (m.parameters == null) {
                    return {
                      v: new Member(m.name, retTyp, new List$1(ProviderHelpers.docMeta(parseDoc(m.documentation)), schema), propAccess(m.trace))
                    };
                  } else {
                    var _ret3 = function () {
                      var args = toList(delay(function () {
                        return map$3(function (p) {
                          return [p.name, false, new Type("Primitive", [mapParamType(p.type)])];
                        }, m.parameters);
                      }));
                      var argNames = toList(delay(function () {
                        return map$3(function (p_1) {
                          return p_1.name;
                        }, m.parameters);
                      }));

                      var retFunc = function retFunc(tys) {
                        if (listsEqual(tys, toList(delay(function () {
                          return collect(function (matchValue_2) {
                            return singleton(matchValue_2[2]);
                          }, args);
                        })), function (t1) {
                          return function (t2) {
                            return typesEqual(t1, t2);
                          };
                        })) {
                          return retTyp;
                        } else {
                          return null;
                        }
                      };

                      var Metadata$$1 = ofArray$1([ProviderHelpers.docMeta(parseDoc(m.documentation))]);
                      return {
                        v: {
                          v: new Member(m.name, new Type("Method", [args, retFunc]), Metadata$$1, methCall(argNames, m.trace))
                        }
                      };
                    }();

                    if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
                  }

                case "primitive":
                  var returns_2 = m.returns;
                  var ty = fromRawType(returns_2.type);
                  var patternInput_1 = getTypeAndEmitter(lookupNamed, ty);
                  return {
                    v: new Member(m.name, patternInput_1[0], new List$1(ProviderHelpers.docMeta(parseDoc(m.documentation)), schema), dataCall(patternInput_1[1], m.trace, returns_2.endpoint))
                  };

                default:
                  throw new Error("?");
              }
            }();

            if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
          });

          return builder_.Return(new Type("Object", [_defineProperty({
            get Members() {
              return members;
            },

            TypeEquals: function (_arg2) {
              return false;
            }
          }, _Symbol.reflection, function () {
            return {
              interfaces: ["TheGamma.ObjectType"]
            };
          })]));
        });
      });
    }(singleton$2);

    var ty_1 = new Type("Delayed", [function (arg00) {
      return function (arg10) {
        return Async_CreateNamedFuture_Static(arg00, arg10);
      };
    }(guid)(future)]);
    restTypeCache.set(guid, ty_1);
    return ty_1;
  }
}
function provideRestType(lookupNamed, resolveProvider, name, root, cookies) {
  var ctx = BabelOperators.ident("RuntimeContext");
  return new ProvidedType("GlobalValue", [name, new List$1(), new Expression("NewExpression", [ctx, ofArray$1([BabelOperators.str(root), BabelOperators.str(cookies), BabelOperators.str("")]), null]), createRestType(lookupNamed, resolveProvider, root, cookies, "/")]);
}

var GroupAggregation = function () {
  function GroupAggregation(caseName, fields) {
    _classCallCheck(this, GroupAggregation);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(GroupAggregation, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.GroupAggregation",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          ConcatValues: ["string"],
          CountAll: [],
          CountDistinct: ["string"],
          GroupKey: [],
          Mean: ["string"],
          Sum: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return GroupAggregation;
}();
setType("TheGamma.TypeProviders.Pivot.GroupAggregation", GroupAggregation);
var WindowAggregation = function () {
  function WindowAggregation(caseName, fields) {
    _classCallCheck(this, WindowAggregation);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(WindowAggregation, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.WindowAggregation",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          FirstKey: [],
          LastKey: [],
          Max: ["string"],
          Mean: ["string"],
          MiddleKey: [],
          Min: ["string"],
          Sum: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return WindowAggregation;
}();
setType("TheGamma.TypeProviders.Pivot.WindowAggregation", WindowAggregation);
var SortDirection = function () {
  function SortDirection(caseName, fields) {
    _classCallCheck(this, SortDirection);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(SortDirection, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.SortDirection",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Ascending: [],
          Descending: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return SortDirection;
}();
setType("TheGamma.TypeProviders.Pivot.SortDirection", SortDirection);
var Paging = function () {
  function Paging(caseName, fields) {
    _classCallCheck(this, Paging);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Paging, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.Paging",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Skip: ["string"],
          Take: ["string"]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Paging;
}();
setType("TheGamma.TypeProviders.Pivot.Paging", Paging);
var FilterOperator = function () {
  function FilterOperator(caseName, fields) {
    _classCallCheck(this, FilterOperator);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(FilterOperator, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.FilterOperator",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          And: [],
          Or: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return FilterOperator;
}();
setType("TheGamma.TypeProviders.Pivot.FilterOperator", FilterOperator);
var RelationalOperator = function () {
  function RelationalOperator(caseName, fields) {
    _classCallCheck(this, RelationalOperator);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(RelationalOperator, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.RelationalOperator",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          Equals: [],
          GreaterThan: [],
          InRange: [],
          LessThan: [],
          NotEquals: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return RelationalOperator;
}();
setType("TheGamma.TypeProviders.Pivot.RelationalOperator", RelationalOperator);
var Transformation = function () {
  function Transformation(caseName, fields) {
    _classCallCheck(this, Transformation);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(Transformation, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.Transformation",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          DropColumns: [makeGeneric(List$1, {
            T: "string"
          })],
          Empty: [],
          ExpandBy: ["string", makeGeneric(List$1, {
            T: WindowAggregation
          })],
          FilterBy: [FilterOperator, makeGeneric(List$1, {
            T: Tuple([RelationalOperator, "string", "string"])
          })],
          GetRange: ["string"],
          GetSeries: ["string", "string"],
          GetTheData: [],
          GroupBy: [makeGeneric(List$1, {
            T: "string"
          }), makeGeneric(List$1, {
            T: GroupAggregation
          })],
          Metadata: [],
          Paging: [makeGeneric(List$1, {
            T: Paging
          })],
          SortBy: [makeGeneric(List$1, {
            T: Tuple(["string", SortDirection])
          })],
          WindowBy: ["string", "string", makeGeneric(List$1, {
            T: WindowAggregation
          })]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return Transformation;
}();
setType("TheGamma.TypeProviders.Pivot.Transformation", Transformation);
var Field = function () {
  function Field(name, type) {
    _classCallCheck(this, Field);

    this.Name = name;
    this.Type = type;
  }

  _createClass(Field, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.Field",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Name: "string",
          Type: PrimitiveType
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return Field;
}();
setType("TheGamma.TypeProviders.Pivot.Field", Field);
var Transform = function (__exports) {
  var formatGroupAgg = function formatGroupAgg(_arg1) {
    if (_arg1.Case === "CountAll") {
      return "count-all";
    } else if (_arg1.Case === "CountDistinct") {
      return "count-dist " + escapeIdent(_arg1.Fields[0]);
    } else if (_arg1.Case === "ConcatValues") {
      return "concat-vals " + escapeIdent(_arg1.Fields[0]);
    } else if (_arg1.Case === "Sum") {
      return "sum " + escapeIdent(_arg1.Fields[0]);
    } else if (_arg1.Case === "Mean") {
      return "mean " + escapeIdent(_arg1.Fields[0]);
    } else {
      return "key";
    }
  };

  var formatWinAgg = function formatWinAgg(_arg1) {
    if (_arg1.Case === "MiddleKey") {
      return "mid-key";
    } else if (_arg1.Case === "LastKey") {
      return "last-key";
    } else if (_arg1.Case === "Mean") {
      return "mean " + escapeIdent(_arg1.Fields[0]);
    } else if (_arg1.Case === "Min") {
      return "min " + escapeIdent(_arg1.Fields[0]);
    } else if (_arg1.Case === "Max") {
      return "max " + escapeIdent(_arg1.Fields[0]);
    } else if (_arg1.Case === "Sum") {
      return "sum " + escapeIdent(_arg1.Fields[0]);
    } else {
      return "first-key";
    }
  };

  var formatCondition = __exports.formatCondition = function (op, f, v) {
    var op_1 = op.Case === "NotEquals" ? "neq" : op.Case === "LessThan" ? "lte" : op.Case === "GreaterThan" ? "gte" : op.Case === "InRange" ? "in" : "eq";
    return escapeIdent(f) + " " + op_1 + " " + escapeIdent(v);
  };

  var toUrl = __exports.toUrl = function (transforms) {
    return join("$", map$5(function (tupledArg) {
      return tupledArg[1].tail == null ? tupledArg[0] : tupledArg[0] + "(" + join(",", tupledArg[1]) + ")";
    }, concat$1(toList(delay(function () {
      return map$3(function (t) {
        return t.Case === "Metadata" ? ofArray$1([["metadata", new List$1()]]) : t.Case === "GetRange" ? ofArray$1([["range", ofArray$1([t.Fields[0]])]]) : t.Case === "FilterBy" ? ofArray$1([["filter", new List$1(t.Fields[0].Case === "Or" ? "or" : "and", map$5(function (tupledArg_1) {
          return formatCondition(tupledArg_1[0], tupledArg_1[1], tupledArg_1[2]);
        }, t.Fields[1]))]]) : t.Case === "DropColumns" ? ofArray$1([["drop", t.Fields[0]]]) : t.Case === "SortBy" ? ofArray$1([["sort", map$5(function (tupledArg_2) {
          return tupledArg_2[0] + (tupledArg_2[1].Equals(new SortDirection("Ascending", [])) ? " asc" : " desc");
        }, t.Fields[0])]]) : t.Case === "GroupBy" ? ofArray$1([["groupby", append$1(map$5(function (fld) {
          return "by " + escapeIdent(fld);
        }, t.Fields[0]), map$5(function (_arg1) {
          return formatGroupAgg(_arg1);
        }, t.Fields[1]))]]) : t.Case === "WindowBy" ? ofArray$1([["windowby", ofArray$1(["by " + escapeIdent(t.Fields[0]), t.Fields[1]], map$5(function (_arg1_1) {
          return formatWinAgg(_arg1_1);
        }, t.Fields[2]))]]) : t.Case === "ExpandBy" ? ofArray$1([["expandby", new List$1("by " + escapeIdent(t.Fields[0]), map$5(function (_arg1_2) {
          return formatWinAgg(_arg1_2);
        }, t.Fields[1]))]]) : t.Case === "Paging" ? map$5(function (_arg1_3) {
          return _arg1_3.Case === "Skip" ? ["skip", ofArray$1([_arg1_3.Fields[0]])] : ["take", ofArray$1([_arg1_3.Fields[0]])];
        }, t.Fields[0]) : t.Case === "GetSeries" ? ofArray$1([["series", ofArray$1([t.Fields[0], t.Fields[1]])]]) : t.Case === "Empty" ? new List$1() : new List$1();
      }, transforms);
    })))));
  };

  var singleTransformFields = __exports.singleTransformFields = function (fields, _arg1) {
    var $var152 = _arg1.Case === "Metadata" ? [1] : _arg1.Case === "GetRange" ? [2] : _arg1.Case === "GetTheData" ? [3] : _arg1.Case === "SortBy" ? [4] : _arg1.Case === "Paging" ? [5] : _arg1.Case === "FilterBy" ? [6] : _arg1.Case === "GetSeries" ? [7] : _arg1.Case === "DropColumns" ? [8] : _arg1.Case === "ExpandBy" ? [9, _arg1.Fields[1], _arg1.Fields[0]] : _arg1.Case === "WindowBy" ? [9, _arg1.Fields[2], _arg1.Fields[0]] : _arg1.Case === "GroupBy" ? [10] : [0];

    var _ret = function () {
      switch ($var152[0]) {
        case 0:
          return {
            v: fields
          };

        case 1:
          throw new Error("Metadata should not appear in normal queries");

        case 2:
          throw new Error("GetRange should not appear in normal queries");

        case 3:
          return {
            v: fields
          };

        case 4:
          return {
            v: fields
          };

        case 5:
          return {
            v: fields
          };

        case 6:
          return {
            v: fields
          };

        case 7:
          return {
            v: ofArray$1([find(function (f) {
              return f.Name === _arg1.Fields[0];
            }, fields), find(function (f_1) {
              return f_1.Name === _arg1.Fields[1];
            }, fields)])
          };

        case 8:
          var dropped = create$5(_arg1.Fields[0], new GenericComparer(compare));
          return {
            v: filter$2(function (f_2) {
              return !dropped.has(f_2.Name);
            }, fields)
          };

        case 9:
          var oldFields = new _Map(toList(delay(function () {
            return map$3(function (f_3) {
              return [f_3.Name, f_3];
            }, fields);
          })));
          return {
            v: collect$1(function (_arg2) {
              var $var153 = _arg2.Case === "MiddleKey" ? [1] : _arg2.Case === "LastKey" ? [2] : _arg2.Case === "Mean" ? [3, _arg2.Fields[0]] : _arg2.Case === "Min" ? [3, _arg2.Fields[0]] : _arg2.Case === "Sum" ? [3, _arg2.Fields[0]] : _arg2.Case === "Max" ? [3, _arg2.Fields[0]] : [0];

              switch ($var153[0]) {
                case 0:
                  return ofArray$1([new Field("first " + $var152[2], oldFields.get($var152[2]).Type)]);

                case 1:
                  return ofArray$1([new Field("middle " + $var152[2], oldFields.get($var152[2]).Type)]);

                case 2:
                  return ofArray$1([new Field("last " + $var152[2], oldFields.get($var152[2]).Type)]);

                case 3:
                  return ofArray$1([oldFields.get($var153[1])]);
              }
            }, $var152[1])
          };

        case 10:
          var oldFields_1 = new _Map(toList(delay(function () {
            return map$3(function (f_4) {
              return [f_4.Name, f_4];
            }, fields);
          })));
          return {
            v: collect$1(function (_arg3) {
              var $var154 = _arg3.Case === "ConcatValues" ? [1, _arg3.Fields[0]] : _arg3.Case === "Sum" ? [1, _arg3.Fields[0]] : _arg3.Case === "Mean" ? [2] : _arg3.Case === "CountAll" ? [3] : _arg3.Case === "CountDistinct" ? [4] : [0];

              switch ($var154[0]) {
                case 0:
                  return map$5(function (f_5) {
                    return oldFields_1.get(f_5);
                  }, _arg1.Fields[0]);

                case 1:
                  return ofArray$1([oldFields_1.get($var154[1])]);

                case 2:
                  return ofArray$1([oldFields_1.get(_arg3.Fields[0])]);

                case 3:
                  return ofArray$1([new Field("count", new PrimitiveType("Number", []))]);

                case 4:
                  return ofArray$1([new Field(oldFields_1.get(_arg3.Fields[0]).Name, new PrimitiveType("Number", []))]);
              }
            }, _arg1.Fields[1])
          };
      }
    }();

    if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
  };

  var transformFields = __exports.transformFields = function (fields, tfs) {
    return toList(function () {
      var state = toList(fields);
      return function (list) {
        return fold(function (fields_1, _arg1) {
          return singleTransformFields(fields_1, _arg1);
        }, state, list);
      };
    }()(tfs));
  };

  return __exports;
}({});



var PivotObject = function () {
  _createClass(PivotObject, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.PivotObject",
        interfaces: ["TheGamma.ObjectType"],
        properties: {
          MemberNames: makeGeneric(List$1, {
            T: "string"
          })
        }
      };
    }
  }]);

  function PivotObject(members) {
    _classCallCheck(this, PivotObject);

    this.members = members;
  }

  _createClass(PivotObject, [{
    key: "TypeEquals",
    value: function (y) {
      if (y instanceof PivotObject) {
        return y.MemberNames.Equals(this.MemberNames);
      } else {
        return false;
      }
    }
  }, {
    key: "MemberNames",
    get: function () {
      var _this2 = this;

      return toList(delay(function () {
        return map$3(function (m) {
          return m.Name;
        }, _this2.members);
      }));
    }
  }, {
    key: "Members",
    get: function () {
      return _Array$from(this.members);
    }
  }]);

  return PivotObject;
}();
setType("TheGamma.TypeProviders.Pivot.PivotObject", PivotObject);
function makeObjectType(members) {
  return new Type("Object", [new PivotObject(members)]);
}
function isNumeric(fld) {
  return fld.Equals(new PrimitiveType("Number", []));
}
function isDate(fld) {
  return fld.Equals(new PrimitiveType("Date", []));
}
function isConcatenable(fld) {
  return fld.Equals(new PrimitiveType("String", []));
}
function getTypeAndEmitter$1(_arg1) {
  if (_arg1.Case === "Date") {
    return [new Type("Primitive", [new PrimitiveType("String", [])]), function (e) {
      return new Expression("NewExpression", [BabelOperators.ident("Date"), ofArray$1([BabelOperators.op_DivideAtDivide(BabelOperators.op_Dynamic(BabelOperators.ident("Date"), "parse"), ofArray$1([e]))]), null]);
    }];
  } else if (_arg1.Case === "Number") {
    return [new Type("Primitive", [new PrimitiveType("Number", [])]), function (e_1) {
      return BabelOperators.op_DivideAtDivide(BabelOperators.ident("Number"), ofArray$1([e_1]));
    }];
  } else if (_arg1.Case === "Bool") {
    return [new Type("Primitive", [new PrimitiveType("Number", [])]), function (e_2) {
      return BabelOperators.op_DivideAtDivide(BabelOperators.ident("Boolean"), ofArray$1([e_2]));
    }];
  } else if (_arg1.Case === "Unit") {
    return [new Type("Primitive", [new PrimitiveType("Unit", [])]), function (e_3) {
      return new Expression("NullLiteral", [null]);
    }];
  } else {
    return [new Type("Primitive", [new PrimitiveType("String", [])]), function (x) {
      return x;
    }];
  }
}
var propertyEmitter = new Emitter(function (_this) {
  return _this;
});
function makeMethodEmitter(callid, pars) {
  return new Emitter(function (_this) {
    return BabelOperators.funcN(count(pars), function (args) {
      var args_1 = BabelOperators.arr(toList(delay(function () {
        return map$3(function (v) {
          return v;
        }, args);
      })));
      return BabelOperators.op_DivideAtDivide(BabelOperators.op_Dynamic(_this, "addCall"), ofArray$1([BabelOperators.str(callid), args_1]));
    });
  });
}
function makeDataEmitter(isPreview, isSeries, convValues, tfs) {
  return new Emitter(function (_this) {
    return isSeries ? BabelOperators.op_DivideAtDivide(BabelOperators.op_Dynamic(BabelOperators.ident("series"), "create"), ofArray$1([BabelOperators.op_DivideAtDivide(BabelOperators.op_Dynamic(_this, "getData"), ofArray$1([convValues, BabelOperators.str(Transform.toUrl(reverse$1(tfs))), BabelOperators.bool(isPreview)])), BabelOperators.str("key"), BabelOperators.str("value"), BabelOperators.str("")])) : BabelOperators.op_DivideAtDivide(BabelOperators.op_Dynamic(BabelOperators.ident("series"), "ordinal"), ofArray$1([BabelOperators.op_DivideAtDivide(BabelOperators.op_Dynamic(_this, "getData"), ofArray$1([convValues, BabelOperators.str(Transform.toUrl(reverse$1(tfs))), BabelOperators.bool(isPreview)])), BabelOperators.str("key"), BabelOperators.str("value"), BabelOperators.str("")]));
  });
}
var Context = function () {
  function Context(root, ignoreFiltersInRange, lookupNamed, inputFields, fields) {
    _classCallCheck(this, Context);

    this.Root = root;
    this.IgnoreFiltersInRange = ignoreFiltersInRange;
    this.LookupNamed = lookupNamed;
    this.InputFields = inputFields;
    this.Fields = fields;
  }

  _createClass(Context, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeProviders.Pivot.Context",
        interfaces: ["FSharpRecord"],
        properties: {
          Root: "string",
          IgnoreFiltersInRange: "boolean",
          LookupNamed: "function",
          InputFields: makeGeneric(List$1, {
            T: Field
          }),
          Fields: makeGeneric(List$1, {
            T: Field
          })
        }
      };
    }
  }]);

  return Context;
}();
setType("TheGamma.TypeProviders.Pivot.Context", Context);
function makeProperty(ctx, name, tfs) {
  var meta1 = new Metadata("http://schema.thegamma.net/pivot", "Transformations", tfs);
  var meta2 = new Metadata("http://schema.thegamma.net/pivot", "Fields", ctx.Fields);
  return new Member(name, makePivotType(ctx, tfs), ofArray$1([meta1, meta2]), propertyEmitter);
}
function makeMethod(ctx, name, tfs, callid, args) {
  var meta1 = new Metadata("http://schema.thegamma.net/pivot", "Transformations", tfs);
  var meta2 = new Metadata("http://schema.thegamma.net/pivot", "Fields", ctx.Fields);
  var Metadata$$1 = ofArray$1([meta1, meta2]);
  return new Member(name, new Type("Method", [toList(delay(function () {
    return collect(function (matchValue) {
      return singleton([matchValue[0], false, new Type("Primitive", [matchValue[1]])]);
    }, args);
  })), function (ts) {
    return listsEqual(ts, args, function (t1) {
      return function (tupledArg) {
        return typesEqual(t1, new Type("Primitive", [tupledArg[1]]));
      };
    }) ? makePivotType(ctx, tfs) : null;
  }]), Metadata$$1, makeMethodEmitter(callid, args));
}
function makeDataMember(ctx, name, isPreview, tfs) {
  var fields = Transform.transformFields(ctx.InputFields, reverse$1(tfs));
  Log.trace("providers", "Make data member using transform %O. Got fields: %O", tfs, fields);
  var patternInput_2 = void 0;
  var $var155 = tfs.tail != null ? tfs.head.Case === "GetSeries" ? [0] : [1] : [1];

  (function () {
    switch ($var155[0]) {
      case 0:
        var $var156 = fields.tail != null ? fields.tail.tail != null ? fields.tail.tail.tail == null ? [0, fields.head, fields.tail.head] : [1] : [1] : [1];

        switch ($var156[0]) {
          case 0:
            patternInput_2 = [true, applyTypes(ctx.LookupNamed("series"), ofArray$1([new Type("Primitive", [$var156[1].Type]), new Type("Primitive", [$var156[2].Type])])), BabelOperators.func("o", function (arg) {
              return BabelOperators.arr(ofArray$1([getTypeAndEmitter$1($var156[1].Type)[1](BabelOperators.op_DivideQmarkDivide(arg, BabelOperators.num(0))), getTypeAndEmitter$1($var156[2].Type)[1](BabelOperators.op_DivideQmarkDivide(arg, BabelOperators.num(1)))]));
            })];
            break;

          case 1:
            throw new Error("makeDataMember: Series should have key and value");
            break;
        }

        break;

      case 1:
        var patternInput_1 = unzip(_Array$from(fields).map(function (fld) {
          var patternInput = getTypeAndEmitter$1(fld.Type);
          var emitter = new Emitter(function (inst) {
            return BabelOperators.op_DivideQmarkDivide(inst, BabelOperators.str(fld.Name));
          });
          return [[fld.Name, patternInput[1]], new Member(fld.Name, patternInput[0], ofArray$1([ProviderHelpers.docMeta(new Documentation("Text", [""]))]), emitter)];
        }));
        var recTyp = makeObjectType(patternInput_1[1]);
        patternInput_2 = [false, applyTypes(ctx.LookupNamed("series"), ofArray$1([new Type("Primitive", [new PrimitiveType("Number", [])]), recTyp])), BabelOperators.func("o", function (arg_1) {
          var mems = toList(delay(function () {
            return collect(function (matchValue) {
              return singleton(new ObjectMember("ObjectProperty", [BabelOperators.str(matchValue[0]), matchValue[1](BabelOperators.op_DivideQmarkDivide(arg_1, BabelOperators.str(matchValue[0]))), true, null]));
            }, patternInput_1[0]);
          }));
          return new Expression("ObjectExpression", [mems, null]);
        })];
        break;
    }
  })();

  var tfs_1 = patternInput_2[0] ? tfs : new List$1(new Transformation("GetTheData", []), tfs);
  var meta1 = new Metadata("http://schema.thegamma.net/pivot", "Transformations", tfs_1);
  var meta2 = new Metadata("http://schema.thegamma.net/pivot", "Fields", ctx.Fields);
  return new Member(name, patternInput_2[1], ofArray$1([meta1, meta2]), makeDataEmitter(isPreview, patternInput_2[0], patternInput_2[2], tfs_1));
}
function handleGetSeriesRequest(ctx, rest, k, v) {
  var matchValue = [k, v];
  var $var157 = matchValue[0] === "!" ? matchValue[1] === "!" ? [0] : [2] : matchValue[1] === "!" ? [1] : [2];

  switch ($var157[0]) {
    case 0:
      return makeObjectType(toList(delay(function () {
        return map$3(function (field) {
          return makeProperty(ctx, "with key " + field.Name, new List$1(new Transformation("GetSeries", [field.Name, "!"]), rest));
        }, ctx.Fields);
      })));

    case 1:
      return makeObjectType(toList(delay(function () {
        return map$3(function (field_1) {
          return makeDataMember(ctx, "and value " + field_1.Name, false, new List$1(new Transformation("GetSeries", [matchValue[0], field_1.Name]), rest));
        }, ctx.Fields);
      })));

    case 2:
      throw new Error("handleGetSeriesRequest: Should not happen");
  }
}
function handlePagingRequest(ctx, rest, pgid, ops) {
  var takeMemb = makeMethod(ctx, "take", ofArray$1([new Transformation("Empty", []), new Transformation("Paging", [reverse$1(new List$1(new Paging("Take", [pgid + "-take"]), ops))])], rest), pgid + "-take", ofArray$1([["count", new PrimitiveType("Number", [])]]));
  var skipMemb = makeMethod(ctx, "skip", new List$1(new Transformation("Paging", [new List$1(new Paging("Skip", [pgid + "-skip"]), ops)]), rest), pgid + "-skip", ofArray$1([["count", new PrimitiveType("Number", [])]]));
  var thenMemb = makeProperty(ctx, "then", ofArray$1([new Transformation("Empty", []), new Transformation("Paging", [reverse$1(ops)])], rest));
  return makeObjectType(function () {
    var $var158 = ops.tail != null ? ops.head.Case === "Skip" ? ops.tail.tail == null ? [1] : [2] : [2] : [0];

    switch ($var158[0]) {
      case 0:
        return ofArray$1([skipMemb, takeMemb, thenMemb]);

      case 1:
        return ofArray$1([takeMemb, thenMemb]);

      case 2:
        throw new Error("handlePagingRequest: Shold not happen");
    }
  }());
}
function handleDropRequest(ctx, rest, dropped) {
  var droppedFields = create$5(dropped, new GenericComparer(compare));
  return makeObjectType(toList(delay(function () {
    return append(singleton(makeProperty(ctx, "then", ofArray$1([new Transformation("Empty", []), new Transformation("DropColumns", [dropped])], rest))), delay(function () {
      return collect(function (field) {
        return !droppedFields.has(field.Name) ? singleton(makeProperty(ctx, "drop " + field.Name, new List$1(new Transformation("DropColumns", [new List$1(field.Name, dropped)]), rest))) : empty();
      }, ctx.Fields);
    }));
  })));
}
function handleSortRequest(ctx, rest, keys) {
  var usedKeys = create$5(map$5(function (tuple) {
    return tuple[0];
  }, keys), new GenericComparer(compare));
  return makeObjectType(toList(delay(function () {
    return append(singleton(makeProperty(ctx, "then", ofArray$1([new Transformation("Empty", []), new Transformation("SortBy", [keys])], rest))), delay(function () {
      return collect(function (field) {
        if (!usedKeys.has(field.Name)) {
          var _ret3 = function () {
            var doc = fsFormat("Use the field '%s' as the next sorting keys")(function (x) {
              return x;
            })(field.Name);
            var prefix = keys.Equals(new List$1()) ? "by " : "and by ";
            return {
              v: append(singleton(makeProperty(ctx, prefix + field.Name, new List$1(new Transformation("SortBy", [new List$1([field.Name, new SortDirection("Ascending", [])], keys)]), rest))), delay(function () {
                return singleton(makeProperty(ctx, prefix + field.Name + " descending", new List$1(new Transformation("SortBy", [new List$1([field.Name, new SortDirection("Descending", [])], keys)]), rest)));
              }))
            };
          }();

          if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
        } else {
          return empty();
        }
      }, ctx.Fields);
    }));
  })));
}
function handleWindowRequest(ctx, rest, wndid) {
  return makeObjectType(toList(delay(function () {
    return collect(function (field) {
      return isDate(field.Type) ? append(singleton(makeMethod(ctx, "window by " + field.Name, new List$1(new Transformation("WindowBy", [field.Name, wndid, new List$1()]), rest), wndid, ofArray$1([["size", new PrimitiveType("Number", [])]]))), delay(function () {
        return singleton(makeProperty(ctx, "expanding by " + field.Name, new List$1(new Transformation("ExpandBy", [field.Name, ofArray$1([new WindowAggregation("LastKey", [])])]), rest)));
      })) : empty();
    }, ctx.Fields);
  })));
}
function handleWindowExpandAggRequest(ctx, rest, fld, make, aggs) {
  var containsKey = exists(function (_arg1) {
    var $var159 = _arg1.Case === "FirstKey" ? [0] : _arg1.Case === "LastKey" ? [0] : _arg1.Case === "MiddleKey" ? [0] : [1];

    switch ($var159[0]) {
      case 0:
        return true;

      case 1:
        return false;
    }
  }, aggs);

  var containsField = function containsField(fld_1) {
    return exists(function (_arg2) {
      var $var160 = _arg2.Case === "Max" ? [0, _arg2.Fields[0]] : _arg2.Case === "Min" ? [0, _arg2.Fields[0]] : _arg2.Case === "Mean" ? [0, _arg2.Fields[0]] : _arg2.Case === "FirstKey" ? [1] : _arg2.Case === "LastKey" ? [1] : _arg2.Case === "MiddleKey" ? [1] : [0, _arg2.Fields[0]];

      switch ($var160[0]) {
        case 0:
          return $var160[1] === fld_1;

        case 1:
          return false;
      }
    }, aggs);
  };

  var makeAggMember = function makeAggMember(name) {
    return function (agg) {
      return makeProperty(ctx, name, new List$1(make(new List$1(agg, aggs)), rest));
    };
  };

  return makeObjectType(toList(delay(function () {
    return append(!(aggs.tail == null) ? singleton(makeProperty(ctx, "then", ofArray$1([new Transformation("Empty", []), make(aggs)], rest))) : empty(), delay(function () {
      return append(!containsKey ? append(singleton(makeAggMember("first " + fld)(new WindowAggregation("FirstKey", []))), delay(function () {
        return append(singleton(makeAggMember("last " + fld)(new WindowAggregation("LastKey", []))), delay(function () {
          return singleton(makeAggMember("middle " + fld)(new WindowAggregation("MiddleKey", [])));
        }));
      })) : empty(), delay(function () {
        return collect(function (fld_2) {
          return !containsField(fld_2.Name) ? isNumeric(fld_2.Type) ? append(singleton(makeAggMember("min " + fld_2.Name)(new WindowAggregation("Min", [fld_2.Name]))), delay(function () {
            return append(singleton(makeAggMember("sum " + fld_2.Name)(new WindowAggregation("Sum", [fld_2.Name]))), delay(function () {
              return append(singleton(makeAggMember("max " + fld_2.Name)(new WindowAggregation("Max", [fld_2.Name]))), delay(function () {
                return singleton(makeAggMember("mean " + fld_2.Name)(new WindowAggregation("Mean", [fld_2.Name])));
              }));
            }));
          })) : empty() : empty();
        }, ctx.Fields);
      }));
    }));
  })));
}
function aggregationMembers(ctx, rest, keys, aggs) {
  var containsCountAll = exists(function () {
    var x = new GroupAggregation("CountAll", []);
    return function (y) {
      return x.Equals(y);
    };
  }(), aggs);

  var containsField = function containsField(fld) {
    return exists(function (_arg3) {
      var $var161 = _arg3.Case === "ConcatValues" ? [0, _arg3.Fields[0]] : _arg3.Case === "Sum" ? [0, _arg3.Fields[0]] : _arg3.Case === "Mean" ? [0, _arg3.Fields[0]] : _arg3.Case === "CountAll" ? [1] : _arg3.Case === "GroupKey" ? [1] : [0, _arg3.Fields[0]];

      switch ($var161[0]) {
        case 0:
          return $var161[1] === fld;

        case 1:
          return false;
      }
    }, aggs);
  };

  var makeAggMember = function makeAggMember(name) {
    return function (agg) {
      return makeProperty(ctx, name, new List$1(new Transformation("GroupBy", [keys, new List$1(agg, aggs)]), rest));
    };
  };

  return toList(delay(function () {
    return append(singleton(makeProperty(ctx, "then", ofArray$1([new Transformation("Empty", []), new Transformation("GroupBy", [keys, aggs])], rest))), delay(function () {
      return append(!containsCountAll ? singleton(makeAggMember("count all")(new GroupAggregation("CountAll", []))) : empty(), delay(function () {
        return collect(function (fld_1) {
          return !containsField(fld_1.Name) ? append(singleton(makeAggMember("count distinct " + fld_1.Name)(new GroupAggregation("CountDistinct", [fld_1.Name]))), delay(function () {
            return append(isConcatenable(fld_1.Type) ? singleton(makeAggMember("concatenate values of " + fld_1.Name)(new GroupAggregation("ConcatValues", [fld_1.Name]))) : empty(), delay(function () {
              return isNumeric(fld_1.Type) ? append(singleton(makeAggMember("average " + fld_1.Name)(new GroupAggregation("Mean", [fld_1.Name]))), delay(function () {
                return singleton(makeAggMember("sum " + fld_1.Name)(new GroupAggregation("Sum", [fld_1.Name])));
              })) : empty();
            }));
          })) : empty();
        }, ctx.Fields);
      }));
    }));
  }));
}
function handleGroupAggRequest(ctx, rest, keys, aggs) {
  return makeObjectType(aggregationMembers(ctx, rest, keys, aggs));
}
function handleGroupRequest(ctx, rest, keys) {
  var prefix = keys.tail == null ? "by " : "and ";
  return makeObjectType(toList(delay(function () {
    return append(map$3(function (field) {
      return makeProperty(ctx, prefix + field.Name, new List$1(new Transformation("GroupBy", [new List$1(field.Name, keys), new List$1()]), rest));
    }, ctx.Fields), delay(function () {
      return !(keys.tail == null) ? aggregationMembers(ctx, rest, keys, ofArray$1([new GroupAggregation("GroupKey", [])])) : empty();
    }));
  })));
}
function handleFilterEqNeqRequest(ctx, rest, fld, eq, op, conds) {
  return function (builder_) {
    return builder_.Delay(function () {
      var tfs = op.Equals(new FilterOperator("Or", [])) ? rest : conds.tail == null ? rest : new List$1(new Transformation("FilterBy", [op, conds]), rest);
      var tfs_1 = ctx.IgnoreFiltersInRange ? filter$2(function (_arg4) {
        return _arg4.Case === "FilterBy" ? false : true;
      }, tfs) : tfs;
      var url = ctx.Root + "?" + Transform.toUrl(reverse$1(new List$1(new Transformation("GetRange", [fld]), tfs_1)));
      return builder_.Bind(Http.Request("GET", url), function (_arg5) {
        var options = JSON.parse(_arg5);
        return builder_.Return(makeObjectType(toList(delay(function () {
          return map$3(function (opt) {
            return makeProperty(ctx, opt, new List$1(new Transformation("FilterBy", [op, new List$1([eq, fld, opt], conds)]), rest));
          }, options);
        }))));
      });
    });
  }(singleton$2);
}
function handleFilterRequest(ctx, rest, flid, op, conds) {
  var prefixes = void 0;
  var matchValue = [conds, op];

  if (matchValue[0].tail != null) {
    if (matchValue[0].tail.tail == null) {
      prefixes = ofArray$1([["and ", new FilterOperator("And", [])], ["or ", new FilterOperator("Or", [])]]);
    } else if (matchValue[1].Case === "Or") {
      prefixes = ofArray$1([["or ", new FilterOperator("Or", [])]]);
    } else {
      prefixes = ofArray$1([["and ", new FilterOperator("And", [])]]);
    }
  } else {
    prefixes = ofArray$1([["", new FilterOperator("And", [])]]);
  }

  return makeObjectType(toList(delay(function () {
    return append(collect(function (matchValue_1) {
      return collect(function (field) {
        return append(field.Type.Equals(new PrimitiveType("String", [])) ? append(singleton(makeProperty(ctx, matchValue_1[0] + field.Name + " is", new List$1(new Transformation("FilterBy", [matchValue_1[1], new List$1([new RelationalOperator("Equals", []), field.Name, "!"], conds)]), rest))), delay(function () {
          return singleton(makeProperty(ctx, matchValue_1[0] + field.Name + " is not", new List$1(new Transformation("FilterBy", [matchValue_1[1], new List$1([new RelationalOperator("NotEquals", []), field.Name, "!"], conds)]), rest)));
        })) : empty(), delay(function () {
          return field.Type.Equals(new PrimitiveType("Number", [])) ? append(singleton(makeMethod(ctx, matchValue_1[0] + field.Name + " is less than", new List$1(new Transformation("FilterBy", [matchValue_1[1], new List$1([new RelationalOperator("LessThan", []), field.Name, flid], conds)]), rest), flid, ofArray$1([["value", new PrimitiveType("Number", [])]]))), delay(function () {
            return append(singleton(makeMethod(ctx, matchValue_1[0] + field.Name + " is greater than", new List$1(new Transformation("FilterBy", [matchValue_1[1], new List$1([new RelationalOperator("GreaterThan", []), field.Name, flid], conds)]), rest), flid, ofArray$1([["value", new PrimitiveType("Number", [])]]))), delay(function () {
              return singleton(makeMethod(ctx, matchValue_1[0] + field.Name + " is in range", new List$1(new Transformation("FilterBy", [matchValue_1[1], new List$1([new RelationalOperator("InRange", []), field.Name, flid], conds)]), rest), flid, ofArray$1([["minimum", new PrimitiveType("Number", [])], ["maximum", new PrimitiveType("Number", [])]])));
            }));
          })) : empty();
        }));
      }, ctx.Fields);
    }, prefixes), delay(function () {
      return !(conds.tail == null) ? singleton(makeProperty(ctx, "then", ofArray$1([new Transformation("Empty", []), new Transformation("FilterBy", [op, conds])], rest))) : empty();
    }));
  })));
}
function makePivotTypeImmediate(ctx, tfs) {
  return function (builder_) {
    return builder_.Delay(function () {
      var patternInput = tfs.tail != null ? [tfs.head, tfs.tail] : [new Transformation("Empty", []), new List$1()];
      var ctx_1 = void 0;
      var Fields = Transform.transformFields(ctx.InputFields, reverse$1(patternInput[1]));
      ctx_1 = new Context(ctx.Root, ctx.IgnoreFiltersInRange, ctx.LookupNamed, ctx.InputFields, Fields);
      var $var162 = patternInput[0].Case === "GetSeries" ? [1, patternInput[0].Fields[0], patternInput[0].Fields[1]] : patternInput[0].Case === "Paging" ? [2, patternInput[0].Fields[0]] : patternInput[0].Case === "SortBy" ? [3, patternInput[0].Fields[0]] : patternInput[0].Case === "DropColumns" ? [4, patternInput[0].Fields[0]] : patternInput[0].Case === "FilterBy" ? patternInput[0].Fields[1].tail != null ? patternInput[0].Fields[1].head[0].Case === "Equals" ? patternInput[0].Fields[1].head[2] === "!" ? [5, patternInput[0].Fields[1].tail, patternInput[0].Fields[1].head[1], patternInput[0].Fields[0], patternInput[0].Fields[1].head[0]] : [6, patternInput[0].Fields[1], patternInput[0].Fields[0]] : patternInput[0].Fields[1].head[0].Case === "NotEquals" ? patternInput[0].Fields[1].head[2] === "!" ? [5, patternInput[0].Fields[1].tail, patternInput[0].Fields[1].head[1], patternInput[0].Fields[0], patternInput[0].Fields[1].head[0]] : [6, patternInput[0].Fields[1], patternInput[0].Fields[0]] : [6, patternInput[0].Fields[1], patternInput[0].Fields[0]] : [6, patternInput[0].Fields[1], patternInput[0].Fields[0]] : patternInput[0].Case === "WindowBy" ? patternInput[0].Fields[0] === "!" ? patternInput[0].Fields[1] === "!" ? patternInput[0].Fields[2].tail == null ? [7] : [8, patternInput[0].Fields[2], patternInput[0].Fields[0], patternInput[0].Fields[1]] : [8, patternInput[0].Fields[2], patternInput[0].Fields[0], patternInput[0].Fields[1]] : [8, patternInput[0].Fields[2], patternInput[0].Fields[0], patternInput[0].Fields[1]] : patternInput[0].Case === "ExpandBy" ? [9, patternInput[0].Fields[1], patternInput[0].Fields[0]] : patternInput[0].Case === "GroupBy" ? patternInput[0].Fields[1].tail == null ? [10, patternInput[0].Fields[0]] : [11, patternInput[0].Fields[1], patternInput[0].Fields[0]] : patternInput[0].Case === "GetTheData" ? [12] : patternInput[0].Case === "GetRange" ? [12] : patternInput[0].Case === "Metadata" ? [12] : [0];

      switch ($var162[0]) {
        case 0:
          return builder_.Return(makeObjectType(toList(delay(function () {
            return append(singleton(makeProperty(ctx_1, "group data", new List$1(new Transformation("GroupBy", [new List$1(), new List$1()]), patternInput[1]))), delay(function () {
              return append(singleton(makeProperty(ctx_1, "filter data", new List$1(new Transformation("FilterBy", [new FilterOperator("And", []), new List$1()]), patternInput[1]))), delay(function () {
                return append(singleton(makeProperty(ctx_1, "sort data", new List$1(new Transformation("SortBy", [new List$1()]), patternInput[1]))), delay(function () {
                  return append(singleton(makeProperty(ctx_1, "drop columns", new List$1(new Transformation("DropColumns", [new List$1()]), patternInput[1]))), delay(function () {
                    return append(singleton(makeProperty(ctx_1, "paging", new List$1(new Transformation("Paging", [new List$1()]), patternInput[1]))), delay(function () {
                      return append(singleton(makeProperty(ctx_1, "get series", new List$1(new Transformation("GetSeries", ["!", "!"]), patternInput[1]))), delay(function () {
                        return append(singleton(makeDataMember(ctx_1, "get the data", false, patternInput[1])), delay(function () {
                          return exists(function (fld) {
                            return fld.Type.Equals(new PrimitiveType("Date", []));
                          }, ctx_1.Fields) ? singleton(makeProperty(ctx_1, "windowing", new List$1(new Transformation("WindowBy", ["!", "!", new List$1()]), patternInput[1]))) : empty();
                        }));
                      }));
                    }));
                  }));
                }));
              }));
            }));
          }))));

        case 1:
          return builder_.Return(handleGetSeriesRequest(ctx_1, patternInput[1], $var162[1], $var162[2]));

        case 2:
          var pgid = fsFormat("pgid-%d")(function (x) {
            return x;
          })(sumBy(function (_arg6) {
            return _arg6.Case === "Paging" ? 1 : 0;
          }, patternInput[1]));
          return builder_.Return(handlePagingRequest(ctx_1, patternInput[1], pgid, $var162[1]));

        case 3:
          return builder_.Return(handleSortRequest(ctx_1, patternInput[1], $var162[1]));

        case 4:
          return builder_.Return(handleDropRequest(ctx_1, patternInput[1], $var162[1]));

        case 5:
          return builder_.ReturnFrom(handleFilterEqNeqRequest(ctx_1, patternInput[1], $var162[2], $var162[4], $var162[3], $var162[1]));

        case 6:
          var flid = $var162[1].length + sumBy(function (_arg7) {
            return _arg7.Case === "FilterBy" ? _arg7.Fields[1].length : 0;
          }, patternInput[1]);
          return builder_.Return(handleFilterRequest(ctx_1, patternInput[1], fsFormat("flid-%d")(function (x) {
            return x;
          })(flid), $var162[2], $var162[1]));

        case 7:
          var wnid = fsFormat("wnid-%d")(function (x) {
            return x;
          })(sumBy(function (_arg8) {
            return _arg8.Case === "WindowBy" ? 1 : 0;
          }, patternInput[1]));
          return builder_.Return(handleWindowRequest(ctx_1, patternInput[1], wnid));

        case 8:
          return builder_.Return(handleWindowExpandAggRequest(ctx_1, patternInput[1], $var162[2], function (aggs) {
            return new Transformation("WindowBy", [$var162[2], $var162[3], aggs]);
          }, $var162[1]));

        case 9:
          return builder_.Return(handleWindowExpandAggRequest(ctx_1, patternInput[1], $var162[2], function (aggs_1) {
            return new Transformation("ExpandBy", [$var162[2], aggs_1]);
          }, $var162[1]));

        case 10:
          return builder_.Return(handleGroupRequest(ctx_1, patternInput[1], $var162[1]));

        case 11:
          return builder_.Return(handleGroupAggRequest(ctx_1, patternInput[1], $var162[2], $var162[1]));

        case 12:
          return builder_.Return(function () {
            throw new Error("makePivotTypeImmediate: GetTheData, GetRange and Metadata shouldn't be of pivot type");
          }());
      }
    });
  }(singleton$2);
}
function adjustForPreview(tfs) {
  var $var163 = tfs.tail != null ? tfs.head.Case === "WindowBy" ? tfs.head.Fields[1] === "!" ? [0, tfs.tail] : [4] : tfs.head.Case === "GroupBy" ? tfs.head.Fields[0].tail == null ? [1, tfs.tail] : tfs.head.Fields[1].tail == null ? [2, tfs.head.Fields[0], tfs.tail] : [4] : tfs.head.Case === "GetSeries" ? [3, tfs.tail] : [4] : [4];

  switch ($var163[0]) {
    case 0:
      return $var163[1];

    case 1:
      return $var163[1];

    case 2:
      return new List$1(new Transformation("GroupBy", [$var163[1], ofArray$1([new GroupAggregation("GroupKey", [])])]), $var163[2]);

    case 3:
      return $var163[1];

    case 4:
      return tfs;
  }
}
function withPreview(ctx, tfs, typ) {
  if (typ.Case === "Object") {
    var preview = makeDataMember(ctx, "preview", true, adjustForPreview(tfs));
    return makeObjectType([preview].concat(typ.Fields[0].Members));
  } else {
    throw new Error("withPreview: Expected object type");
  }
}
function makePivotType(ctx, tfs) {
  var guid = Transform.toUrl(tfs);

  var typ = function (builder_) {
    return builder_.Delay(function () {
      return builder_.TryWith(builder_.Delay(function () {
        return builder_.Bind(makePivotTypeImmediate(ctx, tfs), function (_arg9) {
          return builder_.Return(withPreview(ctx, tfs, _arg9));
        });
      }), function (_arg10) {
        Log.exn("providers", "Failed when generating type for %O with exception %O", tfs, _arg10);
        return builder_.Return(function () {
          throw _arg10;
        }());
      });
    });
  }(singleton$2);

  return new Type("Delayed", [function (arg00) {
    return function (arg10) {
      return Async_CreateNamedFuture_Static(arg00, arg10);
    };
  }(guid)(typ)]);
}
function makePivotExpression(root) {
  return new Expression("NewExpression", [BabelOperators.ident("PivotContext"), ofArray$1([BabelOperators.str(root), new Expression("ArrayExpression", [new List$1(), null])]), null]);
}
function makePivotGlobalValue(root, name, lookupNamed, ignoreFilter, fields) {
  var fields_1 = toList(delay(function () {
    return collect(function (matchValue) {
      return singleton(new Field(matchValue[0], matchValue[1]));
    }, fields);
  }));
  var typ = makePivotType(new Context(root, ignoreFilter, lookupNamed, fields_1, fields_1), new List$1());
  var meta1 = new Metadata("http://schema.thegamma.net/pivot", "Transformations", new List$1());
  var meta2 = new Metadata("http://schema.thegamma.net/pivot", "Fields", fields_1);
  return new ProvidedType("GlobalValue", [name, ofArray$1([meta1, meta2]), makePivotExpression(root), typ]);
}
function providePivotType(root, ignoreFilter, name, lookupNamed) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.Bind(Http.Request("GET", root + "?metadata"), function (_arg1) {
        var fields = function (o) {
          return _Object$keys(o).map(function (k) {
            return {
              "key": k,
              "value": o[k]
            };
          });
        }(JSON.parse(_arg1)).map(function (kv) {
          var typ = void 0;
          var matchValue = kv.value;

          switch (matchValue) {
            case "string":
              typ = new PrimitiveType("String", []);
              break;

            case "bool":
              typ = new PrimitiveType("Bool", []);
              break;

            case "number":
              typ = new PrimitiveType("Number", []);
              break;

            case "date":
              typ = new PrimitiveType("Date", []);
              break;

            default:
              throw new Error(fsFormat("The property '%s' has invalid type '%s'. Only 'string', 'number' and 'bool' are supported.")(function (x) {
                return x;
              })(kv.key)(matchValue));
          }

          return [kv.key, typ];
        });

        return builder_.Return(makePivotGlobalValue(root, name, lookupNamed, ignoreFilter, fields));
      });
    });
  }(singleton$2);
}

var BindingContext = function () {
  function BindingContext(variables, globalValues, root, callSite, chain, table, bound) {
    _classCallCheck(this, BindingContext);

    this.Variables = variables;
    this.GlobalValues = globalValues;
    this.Root = root;
    this.CallSite = callSite;
    this.Chain = chain;
    this.Table = table;
    this.Bound = bound;
  }

  _createClass(BindingContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Binder.BindingContext",
        interfaces: ["FSharpRecord"],
        properties: {
          Variables: makeGeneric(FableMap, {
            Key: Name,
            Value: Entity
          }),
          GlobalValues: makeGeneric(FableMap, {
            Key: Name,
            Value: Entity
          }),
          Root: Entity,
          CallSite: Option(Entity),
          Chain: Option(Entity),
          Table: makeGeneric(_Map, {
            TKey: Interface("TheGamma.Common.Symbol"),
            TValue: makeGeneric(ListDictionaryNode, {
              K: Interface("TheGamma.Common.Symbol"),
              T: makeGeneric(FableMap, {
                Key: Tuple(["number", "string"]),
                Value: Entity
              })
            })
          }),
          Bound: FableArray(Tuple([_Range, Entity]))
        }
      };
    }
  }]);

  return BindingContext;
}();
setType("TheGamma.Binder.BindingContext", BindingContext);
var BindingResult = function () {
  _createClass(BindingResult, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Binder.BindingResult",
        properties: {
          Entities: FableArray(Tuple([_Range, Entity]))
        }
      };
    }
  }]);

  function BindingResult(ents) {
    _classCallCheck(this, BindingResult);

    this.ents = ents;
    var res = new _Map();

    var add$$1 = function add$$1(a) {
      return function (e) {
        if (!res.has(a)) {
          res.set(a, []);
        }

        res.get(a).push(e);
      };
    };

    var arr = this.ents;

    for (var idx = 0; idx <= arr.length - 1; idx++) {
      var forLoopVar = arr[idx];
      var inputSequence = Entity_get_Antecedents.bind(forLoopVar[1])();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _getIterator(inputSequence), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var a_1 = _step.value;
          add$$1(a_1.Symbol)(forLoopVar[1]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    this.childrenLookup = res;
  }

  _createClass(BindingResult, [{
    key: "GetChildren",
    value: function (ent) {
      var matchValue = tryGetValue(this.childrenLookup, ent.Symbol, null);

      if (matchValue[0]) {
        return _Array$from(matchValue[1]);
      } else {
        return [];
      }
    }
  }, {
    key: "Entities",
    get: function () {
      return this.ents;
    }
  }]);

  return BindingResult;
}();
setType("TheGamma.Binder.BindingResult", BindingResult);
function bindEntity(ctx, kind) {
  var patternInput = entityCodeNameAndAntecedents(kind);
  var symbols = map$5(function (a) {
    return a.Symbol;
  }, new List$1(ctx.Root, patternInput[1]));
  var nestedDict = void 0;
  var matchValue = ListDictionaryModule.tryFind(symbols, ctx.Table);

  if (matchValue != null) {
    nestedDict = matchValue;
  } else {
    nestedDict = create$6(null, new GenericComparer(compare));
  }

  if (nestedDict.has([patternInput[0], patternInput[2]])) {
    Log.trace("binder", "Cached: binding %s %s", formatEntityKind(kind), patternInput[2]);
    return nestedDict.get([patternInput[0], patternInput[2]]);
  } else {
    Log.trace("binder", "New: binding %s %s", formatEntityKind(kind), patternInput[2]);

    var symbol = _Symbol2();

    var entity = void 0;
    var Type$$1 = null;
    var Errors = new List$1();
    var Meta = new List$1();
    entity = new Entity(kind, symbol, null, Meta, Type$$1, Errors);
    ListDictionaryModule.set(symbols, add$3([patternInput[0], patternInput[2]], entity, nestedDict), ctx.Table);
    return entity;
  }
}
function setEntity(ctx, node$$1, entity) {
  ctx.Bound.push([node$$1.Range, entity]);
  node$$1.Entity = entity;
  return entity;
}
function bindExpression(ctx, node$$1) {
  var bindCallArgExpression = function bindCallArgExpression(site) {
    return function (ctx_1) {
      var ctx_2 = void 0;
      var CallSite = site;
      var Chain = null;
      ctx_2 = new BindingContext(ctx_1.Variables, ctx_1.GlobalValues, ctx_1.Root, CallSite, Chain, ctx_1.Table, ctx_1.Bound);
      return function (node_1) {
        return bindExpression(ctx_2, node_1);
      };
    };
  };

  var bindMemberExpression = function bindMemberExpression(chain) {
    return function (ctx_3) {
      var ctx_4 = void 0;
      var CallSite_1 = null;
      var Chain_1 = chain;
      ctx_4 = new BindingContext(ctx_3.Variables, ctx_3.GlobalValues, ctx_3.Root, CallSite_1, Chain_1, ctx_3.Table, ctx_3.Bound);
      return function (node_2) {
        return bindExpression(ctx_4, node_2);
      };
    };
  };

  var bindPlaceExpression = function bindPlaceExpression(ctx_5) {
    var ctx_6 = void 0;
    var CallSite_2 = null;
    ctx_6 = new BindingContext(ctx_5.Variables, ctx_5.GlobalValues, ctx_5.Root, CallSite_2, ctx_5.Chain, ctx_5.Table, ctx_5.Bound);
    return function (node_3) {
      return bindExpression(ctx_6, node_3);
    };
  };

  var bindExpression_1 = function bindExpression_1(ctx_7) {
    var ctx_8 = void 0;
    var CallSite_3 = null;
    var Chain_2 = null;
    ctx_8 = new BindingContext(ctx_7.Variables, ctx_7.GlobalValues, ctx_7.Root, CallSite_3, Chain_2, ctx_7.Table, ctx_7.Bound);
    return function (node_4) {
      return bindExpression(ctx_8, node_4);
    };
  };

  if (node$$1.Node.Case === "Variable") {
    if (ctx.Chain != null) {
      var memberName = function (entity) {
        return setEntity(ctx, node$$1.Node.Fields[0], entity);
      }(bindEntity(ctx, new EntityKind("MemberName", [node$$1.Node.Fields[0].Node])));

      return function (entity_1) {
        return setEntity(ctx, node$$1, entity_1);
      }(bindEntity(ctx, new EntityKind("Member", [ctx.Chain, memberName])));
    } else {
      var matchValue = tryFind$1(node$$1.Node.Fields[0].Node, ctx.Variables);

      if (matchValue != null) {
        return function (entity_2) {
          return setEntity(ctx, node$$1, entity_2);
        }(bindEntity(ctx, new EntityKind("Variable", [node$$1.Node.Fields[0].Node, matchValue])));
      } else {
        var matchValue_1 = tryFind$1(node$$1.Node.Fields[0].Node, ctx.GlobalValues);

        if (matchValue_1 != null) {
          return function (entity_3) {
            return setEntity(ctx, node$$1, entity_3);
          }(matchValue_1);
        } else {
          return function (entity_4) {
            return setEntity(ctx, node$$1, entity_4);
          }(bindEntity(ctx, new EntityKind("GlobalValue", [node$$1.Node.Fields[0].Node, null])));
        }
      }
    }
  } else if (node$$1.Node.Case === "Call") {
    var _ret = function () {
      var inst = bindExpression_1(ctx)(node$$1.Node.Fields[0]);

      var site_1 = function site_1(arg) {
        return bindEntity(ctx, new EntityKind("CallSite", [inst, arg]));
      };

      var args = mapIndexed$1(function (idx, arg_1) {
        var site_2 = site_1(arg_1.Name != null ? new Choice("Choice1Of2", [arg_1.Name.Node.Name]) : new Choice("Choice2Of2", [idx]));
        var expr = bindCallArgExpression(site_2)(ctx)(arg_1.Value);

        if (arg_1.Name == null) {
          return expr;
        } else {
          return function (entity_5) {
            return setEntity(ctx, arg_1.Name, entity_5);
          }(bindEntity(ctx, new EntityKind("NamedParam", [arg_1.Name.Node, expr])));
        }
      }, node$$1.Node.Fields[1].Node);

      var args_1 = function (entity_6) {
        return setEntity(ctx, node$$1.Node.Fields[1], entity_6);
      }(bindEntity(ctx, new EntityKind("ArgumentList", [args])));

      return {
        v: function (entity_7) {
          return setEntity(ctx, node$$1, entity_7);
        }(bindEntity(ctx, new EntityKind("Call", [inst, args_1])))
      };
    }();

    if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
  } else if (node$$1.Node.Case === "Member") {
    var instEnt = bindExpression_1(ctx)(node$$1.Node.Fields[0]);
    var memEnt = bindMemberExpression(instEnt)(ctx)(node$$1.Node.Fields[1]);
    return setEntity(ctx, node$$1, memEnt);
  } else if (node$$1.Node.Case === "Binary") {
    var lEnt = bindExpression_1(ctx)(node$$1.Node.Fields[0]);
    var rEnt = bindExpression_1(ctx)(node$$1.Node.Fields[2]);
    return function (entity_8) {
      return setEntity(ctx, node$$1, entity_8);
    }(bindEntity(ctx, new EntityKind("Operator", [lEnt, node$$1.Node.Fields[1].Node, rEnt])));
  } else if (node$$1.Node.Case === "List") {
    var elEnts = map$5(bindExpression_1(ctx), node$$1.Node.Fields[0]);
    return function (entity_9) {
      return setEntity(ctx, node$$1, entity_9);
    }(bindEntity(ctx, new EntityKind("List", [elEnts])));
  } else if (node$$1.Node.Case === "Function") {
    var callSite = void 0;

    if (ctx.CallSite == null) {
      throw new Error("bindExpression: Function missing call site");
    } else {
      callSite = ctx.CallSite;
    }

    var varEnt = function (entity_10) {
      return setEntity(ctx, node$$1.Node.Fields[0], entity_10);
    }(bindEntity(ctx, new EntityKind("Binding", [node$$1.Node.Fields[0].Node, callSite])));

    var bodyEnt = bindExpression_1(new BindingContext(add$3(node$$1.Node.Fields[0].Node, varEnt, ctx.Variables), ctx.GlobalValues, ctx.Root, ctx.CallSite, ctx.Chain, ctx.Table, ctx.Bound))(node$$1.Node.Fields[1]);
    return function (entity_11) {
      return setEntity(ctx, node$$1, entity_11);
    }(bindEntity(ctx, new EntityKind("Function", [varEnt, bodyEnt])));
  } else if (node$$1.Node.Case === "Boolean") {
    return function (entity_12) {
      return setEntity(ctx, node$$1, entity_12);
    }(bindEntity(ctx, new EntityKind("Constant", [new Constant("Boolean", [node$$1.Node.Fields[0]])])));
  } else if (node$$1.Node.Case === "String") {
    return function (entity_13) {
      return setEntity(ctx, node$$1, entity_13);
    }(bindEntity(ctx, new EntityKind("Constant", [new Constant("String", [node$$1.Node.Fields[0]])])));
  } else if (node$$1.Node.Case === "Number") {
    return function (entity_14) {
      return setEntity(ctx, node$$1, entity_14);
    }(bindEntity(ctx, new EntityKind("Constant", [new Constant("Number", [node$$1.Node.Fields[0]])])));
  } else if (node$$1.Node.Case === "Empty") {
    return function (entity_15) {
      return setEntity(ctx, node$$1, entity_15);
    }(bindEntity(ctx, new EntityKind("Constant", [new Constant("Empty", [])])));
  } else {
    var bodyEnt_1 = bindPlaceExpression(ctx)(node$$1.Node.Fields[1]);

    (function (entity_16) {
      return setEntity(ctx, node$$1, entity_16);
    })(bindEntity(ctx, new EntityKind("Placeholder", [node$$1.Node.Fields[0].Node, bodyEnt_1])));

    return bodyEnt_1;
  }
}
function bindCommand(ctx, node$$1) {
  if (node$$1.Node.Case === "Expr") {
    var body = bindExpression(ctx, node$$1.Node.Fields[0]);

    var node_1 = function (entity) {
      return setEntity(ctx, node$$1, entity);
    }(bindEntity(ctx, new EntityKind("RunCommand", [body])));

    return [ctx, node_1];
  } else {
    var body_1 = bindExpression(ctx, node$$1.Node.Fields[1]);

    var _var = function (entity_1) {
      return setEntity(ctx, node$$1.Node.Fields[0], entity_1);
    }(bindEntity(ctx, new EntityKind("Variable", [node$$1.Node.Fields[0].Node, body_1])));

    var node_2 = function (entity_2) {
      return setEntity(ctx, node$$1, entity_2);
    }(bindEntity(ctx, new EntityKind("LetCommand", [_var, body_1])));

    return [new BindingContext(add$3(node$$1.Node.Fields[0].Node, _var, ctx.Variables), ctx.GlobalValues, ctx.Root, ctx.CallSite, ctx.Chain, ctx.Table, ctx.Bound), node_2];
  }
}
function bindProgram(ctx, program) {
  ctx.Bound.splice(0);
  var patternInput_1 = fold(function (tupledArg, cmd) {
    var patternInput = bindCommand(tupledArg[0], cmd);
    return [patternInput[0], new List$1(patternInput[1], tupledArg[1])];
  }, [ctx, new List$1()], program.Body.Node);
  return [bindEntity(ctx, new EntityKind("Program", [patternInput_1[1]])), new BindingResult(_Array$from(ctx.Bound))];
}
function createContext(globals, name) {
  var root = void 0;
  var Kind = new EntityKind("Root", []);
  var Errors = new List$1();

  var _Symbol$$1 = _Symbol2();

  var Type$$1 = null;
  var Meta = new List$1();
  root = new Entity(Kind, _Symbol$$1, null, Meta, Type$$1, Errors);
  var Table = new _Map();
  var Bound = [];
  return new BindingContext(create$6(null, new GenericComparer(function (x, y) {
    return x.CompareTo(y);
  })), create$6(toList(delay(function () {
    return map$3(function (e) {
      return [new Name(Entity_get_Name.bind(e)()), e];
    }, globals);
  })), new GenericComparer(function (x, y) {
    return x.CompareTo(y);
  })), root, null, null, Table, Bound);
}

var QueueCell = (function () {
    function QueueCell(message) {
        this.value = message;
    }
    return QueueCell;
}());
var MailboxQueue = (function () {
    function MailboxQueue() {
    }
    MailboxQueue.prototype.add = function (message) {
        var itCell = new QueueCell(message);
        if (this.firstAndLast) {
            this.firstAndLast[1].next = itCell;
            this.firstAndLast = [this.firstAndLast[0], itCell];
        }
        else
            this.firstAndLast = [itCell, itCell];
    };
    MailboxQueue.prototype.tryGet = function () {
        if (this.firstAndLast) {
            var value = this.firstAndLast[0].value;
            if (this.firstAndLast[0].next)
                this.firstAndLast = [this.firstAndLast[0].next, this.firstAndLast[1]];
            else
                delete this.firstAndLast;
            return value;
        }
        return void 0;
    };
    return MailboxQueue;
}());
var MailboxProcessor = (function () {
    function MailboxProcessor(body, cancellationToken$$1) {
        this.body = body;
        this.cancellationToken = cancellationToken$$1 || defaultCancellationToken;
        this.messages = new MailboxQueue();
    }
    MailboxProcessor.prototype.__processEvents = function () {
        if (this.continuation) {
            var value = this.messages.tryGet();
            if (value) {
                var cont = this.continuation;
                delete this.continuation;
                cont(value);
            }
        }
    };
    MailboxProcessor.prototype.start = function () {
        startImmediate(this.body(this), this.cancellationToken);
    };
    MailboxProcessor.prototype.receive = function () {
        var _this = this;
        return fromContinuations(function (conts) {
            if (_this.continuation)
                throw new Error("Receive can only be called once!");
            _this.continuation = conts[0];
            _this.__processEvents();
        });
    };
    MailboxProcessor.prototype.post = function (message) {
        this.messages.add(message);
        this.__processEvents();
    };
    MailboxProcessor.prototype.postAndAsyncReply = function (buildMessage) {
        var result;
        var continuation;
        function checkCompletion() {
            if (result && continuation)
                continuation(result);
        }
        var reply = {
            reply: function (res) {
                result = res;
                checkCompletion();
            }
        };
        this.messages.add(buildMessage(reply));
        this.__processEvents();
        return fromContinuations(function (conts) {
            continuation = conts[0];
            checkCompletion();
        });
    };
    return MailboxProcessor;
}());
function start$1(body, cancellationToken$$1) {
    var mbox = new MailboxProcessor(body, cancellationToken$$1);
    mbox.start();
    return mbox;
}

var Tokenizer = function (__exports) {
  var inputEndInsideString = __exports.inputEndInsideString = function (rng, s) {
    var _Number = 101;
    return new _Error(_Number, fsFormat("Missing \" at the end of the input. The string \"%s\" ends without closing double-quote.")(function (x) {
      return x;
    })(s), rng);
  };

  var missingClosingQuote = __exports.missingClosingQuote = function (rng, q) {
    var _Number = 102;
    return new _Error(_Number, fsFormat("Quoted identifier '%s' is missing closing quote.")(function (x) {
      return x;
    })(q), rng);
  };

  var unexpectedCharacter = __exports.unexpectedCharacter = function (rng, c) {
    var _Number = 103;
    return new _Error(_Number, fsFormat("Unexcpected character '%s' in the input.")(function (x) {
      return x;
    })(c), rng);
  };

  return __exports;
}({});
var Parser = function (__exports) {
  var unexpectedTokenAfterDot = __exports.unexpectedTokenAfterDot = function (rng, tok) {
    var _Number = 201;
    return new _Error(_Number, fsFormat("Unexpected %s after '.' in method chain")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var unexpectedScopeEndAfterDot = __exports.unexpectedScopeEndAfterDot = function (rng, tok) {
    var _Number = 202;
    return new _Error(_Number, fsFormat("Unexpected end of scope after %s. Did you forget to indent the rest of the member chain?")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var unexpectedTokenInPlaceholder = __exports.unexpectedTokenInPlaceholder = function (rng, tok) {
    var _Number = 203;
    return new _Error(_Number, fsFormat("Unexpected token '%s' in placeholder expression. Shold be `[ident: <expr>]`")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var unexpectedScopeEndInPlaceholder = __exports.unexpectedScopeEndInPlaceholder = function (rng, tok) {
    if (tok != null) {
      var _Number = 204;
      return new _Error(_Number, fsFormat("Unexpected end of scope in placeholder after %s. Did you forget to indent the body of the plceholder?")(function (x) {
        return x;
      })(formatTokenInfo(tok)), rng);
    } else {
      var _Number_1 = 204;
      return new _Error(_Number_1, "Unexpected end of scope in placeholder after expression. Did you forget to indent the body of the plceholder?", rng);
    }
  };

  var unexpectedEndOfPlaceholder = __exports.unexpectedEndOfPlaceholder = function (rng) {
    var _Number = 205;
    return new _Error(_Number, "Incomplete placeholder expression. Shold be `[ident: <expr>]`", rng);
  };

  var unexpectedEndAfterOperator = __exports.unexpectedEndAfterOperator = function (rng, op) {
    var _Number = 206;
    return new _Error(_Number, fsFormat("Unexpected token after operator '%s'. Expected an expression or closing parenthesis.")(function (x) {
      return x;
    })(formatTokenInfo(op)), rng);
  };

  var unexpectedTokenInArgList = __exports.unexpectedTokenInArgList = function (rng, tok) {
    var _Number = 207;
    return new _Error(_Number, fsFormat("Unexpected token '%s' in list of call arguments")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var unexpectedScopeEndInArgList = __exports.unexpectedScopeEndInArgList = function (rng) {
    var _Number = 208;
    return new _Error(_Number, "Unexpected end of argument list. Did you forget to indent the arguments?", rng);
  };

  var unexpectedTokenInParenthesizedExpr = __exports.unexpectedTokenInParenthesizedExpr = function (rng, tok) {
    var _Number = 209;
    return new _Error(_Number, fsFormat("Unexpected token '%s' in parenthesized expression. Are you missing ')'?")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var unexpectedScopeEndInParenthesizedExpr = __exports.unexpectedScopeEndInParenthesizedExpr = function (rng) {
    var _Number = 210;
    return new _Error(_Number, "Unexpected end of nested expression in `(`. Did you forget to indent the body of the expression?", rng);
  };

  var missingParenthesizedExpr = __exports.missingParenthesizedExpr = function (rng) {
    var _Number = 211;
    return new _Error(_Number, "The parenthesized expression (...) is missing body!", rng);
  };

  var unexpectedTokenInList = __exports.unexpectedTokenInList = function (rng, tok) {
    var _Number = 212;
    return new _Error(_Number, fsFormat("Unexpected token '%s' in list expression")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var unexpectedScopeEndInList = __exports.unexpectedScopeEndInList = function (rng) {
    var _Number = 213;
    return new _Error(_Number, "Unexpected end of list expression. Did youu forget to indent the elements of the list?", rng);
  };

  var unexpectedTokenInLetBinding = __exports.unexpectedTokenInLetBinding = function (rng, tok) {
    var _Number = 214;
    return new _Error(_Number, fsFormat("Unexpected token '%s' in let declaration (should be `let name = expr`)")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var missingBodyInLetBinding = __exports.missingBodyInLetBinding = function (rng) {
    var _Number = 215;
    return new _Error(_Number, "This let binding is missing body after equals (should be `let name = expr`", rng);
  };

  var unexpectedNestedTokenInCommand = __exports.unexpectedNestedTokenInCommand = function (rng, tok) {
    var _Number = 216;
    return new _Error(_Number, fsFormat("Unexpected indented token '%s' in command list. Try removing the indentation before the token.")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var unexpectedTokenAfterFun = __exports.unexpectedTokenAfterFun = function (rng, tok) {
    var _Number = 217;
    return new _Error(_Number, fsFormat("Unexpected token '%s' after `fun`. Expected variable name.")(function (x) {
      return x;
    })(formatTokenInfo(tok)), rng);
  };

  var missingArrowInFunc = __exports.missingArrowInFunc = function (rng) {
    var _Number = 218;
    return new _Error(_Number, "Missing arrow after variable in function definition", rng);
  };

  var unexpectedScopeEndInFunc = __exports.unexpectedScopeEndInFunc = function (rng) {
    var _Number = 219;
    return new _Error(_Number, "Unexpected end of function declaration. Did you forget to indent the body of the function?", rng);
  };

  var missingBodyOfFunc = __exports.missingBodyOfFunc = function (rng) {
    var _Number = 220;
    return new _Error(_Number, "The function is missing body. Did you forget to indent the body of the function?", rng);
  };

  var unexpectedScopeEndInLet = __exports.unexpectedScopeEndInLet = function (rng) {
    var _Number = 221;
    return new _Error(_Number, "Unexpected end of let declaration. Did you forget to indent the body of the let declaration?", rng);
  };

  var exceptionWhileParsing = __exports.exceptionWhileParsing = function (rng, msg) {
    var _Number = 299;
    return new _Error(_Number, "Unexpected exception while parsing: " + msg, rng);
  };

  return __exports;
}({});
var TypeChecker = function (__exports) {
  var numericOperatorExpectsNumbers = __exports.numericOperatorExpectsNumbers = function (op, idx, typ, rng) {
    var _Number = 301;
    return new _Error(_Number, fsFormat("Both operands of binary operator '%s' should be numbers but the %s operand was %s instead.")(function (x) {
      return x;
    })(formatToken(new TokenKind("Operator", [op])))(idx === 0 ? "left" : "right")(formatTypeInfo(typ)), rng);
  };

  var variableNotInScope = __exports.variableNotInScope = function (name, rng) {
    var _Number = 302;
    return new _Error(_Number, fsFormat("Variable '%s' is not in scope.")(function (x) {
      return x;
    })(name), rng);
  };

  var formatMembers = function formatMembers(members) {
    var members_1 = _Array$from(members);

    var suffix = members_1.length > 10 ? fsFormat(", (%d members)")(function (x) {
      return x;
    })(members_1.length - 10) : "";
    return join(", ", toList(delay(function () {
      return map$3(function (m) {
        return m.Name;
      }, members_1);
    }))) + suffix;
  };

  var memberMissing = __exports.memberMissing = function (name, members, rng) {
    var _Number = 303;
    return new _Error(_Number, fsFormat("Could not find property '%s' in the list '%s'.")(function (x) {
      return x;
    })(name)(formatMembers(members)), rng);
  };

  var notAnObject = __exports.notAnObject = function (name, typ, rng) {
    var _Number = 305;
    return new _Error(_Number, fsFormat("Type is not an object but %s and it does not have member `%s`")(function (x) {
      return x;
    })(formatTypeInfo(typ))(name), rng);
  };

  var listElementTypeDoesNotMatch = __exports.listElementTypeDoesNotMatch = function (listty, elty, rng) {
    var _Number = 306;
    return new _Error(_Number, fsFormat("The type of this list element is %s but it should be %s")(function (x) {
      return x;
    })(formatTypeInfo(elty))(formatTypeInfo(listty)), rng);
  };

  var nameBasedParamMustBeLast = __exports.nameBasedParamMustBeLast = function (rng) {
    var _Number = 307;
    return new _Error(_Number, "All named parameters must be at the end of parameter list.", rng);
  };

  var parameterMissingValue = __exports.parameterMissingValue = function (par, rng) {
    var _Number = 308;
    return new _Error(_Number, fsFormat("Required parameter `%s` is not given a value.")(function (x) {
      return x;
    })(par), rng);
  };

  var notAnMethod = __exports.notAnMethod = function (name, typ, rng) {
    var _Number = 309;
    return new _Error(_Number, fsFormat("The type of member %s is `%s` and not a method and so it cannot be called.")(function (x) {
      return x;
    })(name)(formatTypeInfo(typ)), rng);
  };

  var parameterConflict = __exports.parameterConflict = function (rng) {
    var _Number = 310;
    return new _Error(_Number, "Invalid argument type", rng);
  };

  var callMissingInstance = __exports.callMissingInstance = function (name, rng) {
    var _Number = 311;
    return new _Error(_Number, fsFormat("The `%s` property access or call is missing an instance")(function (x) {
      return x;
    })(name), rng);
  };

  return __exports;
}({});

var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var $export$10 = _export;
var defined$4 = _defined;
var fails$2   = _fails;
var spaces  = _stringWs;
var space   = '[' + spaces + ']';
var non     = '\u200b\u0085';
var ltrim   = RegExp('^' + space + space + '*');
var rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails$2(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim$1) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export$10($export$10.P + $export$10.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim$1 = exporter.trim = function(string, TYPE){
  string = String(defined$4(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

var _stringTrim = exporter;

var $parseFloat$1 = _global.parseFloat;
var $trim       = _stringTrim.trim;

var _parseFloat$3 = 1 / $parseFloat$1(_stringWs + '-0') !== -Infinity ? function parseFloat(str){
  var string = $trim(String(str), 3)
    , result = $parseFloat$1(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat$1;

var $export$9     = _export;
var $parseFloat = _parseFloat$3;
// 20.1.2.12 Number.parseFloat(string)
$export$9($export$9.S + $export$9.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

var _parseFloat$1 = parseFloat;

var _parseFloat = createCommonjsModule(function (module) {
module.exports = { "default": _parseFloat$1, __esModule: true };
});

var _Number$parseFloat = unwrapExports(_parseFloat);

var Context$2 = function () {
  function Context(tokens, errors, input) {
    _classCallCheck(this, Context);

    this.Tokens = tokens;
    this.Errors = errors;
    this.Input = input;
  }

  _createClass(Context, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Tokenizer.Context",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Tokens: FableArray(Token),
          Errors: FableArray(makeGeneric(_Error, {
            Range: _Range
          })),
          Input: "string"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return Context;
}();
setType("TheGamma.Tokenizer.Context", Context$2);
function startsWith(s, i, j, prefix) {
  startsWith: while (true) {
    if (j === prefix.length) {
      return true;
    } else if (i === s.length) {
      return false;
    } else if (s[i] !== prefix[j]) {
      return false;
    } else {
      s = s;
      i = i + 1;
      j = j + 1;
      prefix = prefix;
      continue startsWith;
    }
  }
}
function letter(c) {
  if (c >= "a" ? c <= "z" : false) {
    return true;
  } else if (c >= "A") {
    return c <= "Z";
  } else {
    return false;
  }
}
function number(c) {
  if (c >= "0") {
    return c <= "9";
  } else {
    return false;
  }
}
function addAndTokenize(ctx, tok, i, l) {
  (function (arg00) {
    ctx.Tokens.push(arg00);
  })(new Token(tok, new _Range(i, i + l - 1)));

  return tokenizeInput(ctx, i + l);
}
function tokenizeIdent(ctx, start, l) {
  tokenizeIdent: while (true) {
    if (start + l < ctx.Input.length ? letter(ctx.Input[start + l]) ? true : number(ctx.Input[start + l]) : false) {
      ctx = ctx;
      start = start;
      l = l + 1;
      continue tokenizeIdent;
    } else {
      return addAndTokenize(ctx, new TokenKind("Ident", [ctx.Input.substr(start, l)]), start, l);
    }
  }
}
function tokenizeString(ctx, acc, start, l) {
  tokenizeString: while (true) {
    if (start + l >= ctx.Input.length) {
      return tokenizeStringEnd(true, ctx, acc, start, l);
    } else {
      var matchValue = ctx.Input[start + l];
      var $var88 = matchValue === "\\" ? start + l + 1 >= ctx.Input.length ? [0] : [1] : [1];

      switch ($var88[0]) {
        case 0:
          return tokenizeStringEnd(true, ctx, new List$1("\\", acc), start, l + 1);

        case 1:
          if (matchValue === "\"") {
            return tokenizeStringEnd(false, ctx, acc, start, l + 1);
          } else if (matchValue === "\\") {
            var matchValue_1 = ctx.Input[start + l + 1];

            if (matchValue_1 === "\"") {
              ctx = ctx;
              acc = new List$1("\"", acc);
              start = start;
              l = l + 2;
              continue tokenizeString;
            } else if (matchValue_1 === "\\") {
              ctx = ctx;
              acc = new List$1("\\", acc);
              start = start;
              l = l + 2;
              continue tokenizeString;
            } else if (matchValue_1 === "n") {
              ctx = ctx;
              acc = new List$1("\n", acc);
              start = start;
              l = l + 2;
              continue tokenizeString;
            } else if (matchValue_1 === "t") {
              ctx = ctx;
              acc = new List$1("\t", acc);
              start = start;
              l = l + 2;
              continue tokenizeString;
            } else {
              ctx = ctx;
              acc = ofArray$1([matchValue_1, "\\"], acc);
              start = start;
              l = l + 2;
              continue tokenizeString;
            }
          } else {
            ctx = ctx;
            acc = new List$1(matchValue, acc);
            start = start;
            l = l + 1;
            continue tokenizeString;
          }

      }
    }
  }
}
function tokenizeStringEnd(error, ctx, acc, start, l) {
  var str = _Array$from(acc).slice().reverse().join('');

  var rng = new _Range(start, start + l);

  if (error) {
    ctx.Errors.push(Tokenizer.inputEndInsideString(rng, str));
  }

  return addAndTokenize(ctx, new TokenKind("String", [str]), start, l);
}
function tokenizeQuotedIdent(ctx, start, l) {
  tokenizeQuotedIdent: while (true) {
    if (start + l >= ctx.Input.length) {
      return tokenizeQuotedIdentEnd(true, ctx, start, l);
    } else {
      var matchValue = ctx.Input[start + l];

      if (matchValue === "\n") {
        return tokenizeQuotedIdentEnd(true, ctx, start, l + 1);
      } else if (matchValue === "'") {
        return tokenizeQuotedIdentEnd(false, ctx, start, l + 1);
      } else {
        ctx = ctx;
        start = start;
        l = l + 1;
        continue tokenizeQuotedIdent;
      }
    }
  }
}
function tokenizeQuotedIdentEnd(error, ctx, start, l) {
  var rng = new _Range(start, start + l);
  var qid = ctx.Input.substr(start + 1, l - (error ? 1 : 2));
  var qid_1 = endsWith(qid, "\n") ? qid.substr(0, qid.length - 1) : qid;

  if (error) {
    ctx.Errors.push(Tokenizer.missingClosingQuote(rng, qid_1));
  }

  return addAndTokenize(ctx, new TokenKind("QIdent", [qid_1]), start, l);
}
function tokenizeWhite(ctx, start, l) {
  tokenizeWhite: while (true) {
    if (start + l < ctx.Input.length ? ctx.Input[start + l] === " " : false) {
      ctx = ctx;
      start = start;
      l = l + 1;
      continue tokenizeWhite;
    } else {
      return addAndTokenize(ctx, new TokenKind("White", [ctx.Input.substr(start, l)]), start, l);
    }
  }
}
function tokenizeNumber(ctx, decimal, start, l) {
  tokenizeNumber: while (true) {
    if (start + l < ctx.Input.length ? number(ctx.Input[start + l]) : false) {
      ctx = ctx;
      decimal = decimal;
      start = start;
      l = l + 1;
      continue tokenizeNumber;
    } else if ((start + l < ctx.Input.length ? !decimal : false) ? ctx.Input[start + l] === "." : false) {
      ctx = ctx;
      decimal = true;
      start = start;
      l = l + 1;
      continue tokenizeNumber;
    } else {
      var str = ctx.Input.substr(start, l);
      return addAndTokenize(ctx, new TokenKind("Number", [str, _Number$parseFloat(str)]), start, l);
    }
  }
}
function tokenizeInput(ctx, i) {
  if (i >= ctx.Input.length) {
    return ctx;
  } else {
    var matchValue = ctx.Input[i];
    var $var89 = matchValue === "-" ? startsWith(ctx.Input, i, 0, "->") ? [0] : [1] : [1];

    switch ($var89[0]) {
      case 0:
        return addAndTokenize(ctx, new TokenKind("Arrow", []), i, 2);

      case 1:
        var $var90 = matchValue === "f" ? startsWith(ctx.Input, i, 0, "fun") ? [0] : [1] : [1];

        switch ($var90[0]) {
          case 0:
            return addAndTokenize(ctx, new TokenKind("Fun", []), i, 3);

          case 1:
            var $var91 = matchValue === "l" ? startsWith(ctx.Input, i, 0, "let") ? [0] : [1] : [1];

            switch ($var91[0]) {
              case 0:
                return addAndTokenize(ctx, new TokenKind("Let", []), i, 3);

              case 1:
                var $var92 = matchValue === "t" ? startsWith(ctx.Input, i, 0, "true") ? [0] : [1] : [1];

                switch ($var92[0]) {
                  case 0:
                    return addAndTokenize(ctx, new TokenKind("Boolean", [true]), i, 4);

                  case 1:
                    var $var93 = matchValue === "f" ? startsWith(ctx.Input, i, 0, "false") ? [0] : [1] : [1];

                    switch ($var93[0]) {
                      case 0:
                        return addAndTokenize(ctx, new TokenKind("Boolean", [false]), i, 5);

                      case 1:
                        var $var94 = matchValue === "<" ? startsWith(ctx.Input, i, 0, "<=") ? [0] : [1] : [1];

                        switch ($var94[0]) {
                          case 0:
                            return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("LessThanOrEqual", [])]), i, 2);

                          case 1:
                            var $var95 = matchValue === ">" ? startsWith(ctx.Input, i, 0, ">=") ? [0] : [1] : [1];

                            switch ($var95[0]) {
                              case 0:
                                return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("GreaterThanOrEqual", [])]), i, 2);

                              case 1:
                                if (matchValue === "\n") {
                                  return addAndTokenize(ctx, new TokenKind("Newline", []), i, 1);
                                } else if (matchValue === " ") {
                                  return tokenizeWhite(ctx, i, 1);
                                } else if (matchValue === "\"") {
                                  return tokenizeString(ctx, new List$1(), i, 1);
                                } else if (matchValue === "%") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("Modulo", [])]), i, 1);
                                } else if (matchValue === "'") {
                                  return tokenizeQuotedIdent(ctx, i, 1);
                                } else if (matchValue === "(") {
                                  return addAndTokenize(ctx, new TokenKind("LParen", []), i, 1);
                                } else if (matchValue === ")") {
                                  return addAndTokenize(ctx, new TokenKind("RParen", []), i, 1);
                                } else if (matchValue === "*") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("Multiply", [])]), i, 1);
                                } else if (matchValue === "+") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("Plus", [])]), i, 1);
                                } else if (matchValue === ",") {
                                  return addAndTokenize(ctx, new TokenKind("Comma", []), i, 1);
                                } else if (matchValue === "-") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("Minus", [])]), i, 1);
                                } else if (matchValue === ".") {
                                  return addAndTokenize(ctx, new TokenKind("Dot", []), i, 1);
                                } else if (matchValue === "/") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("Divide", [])]), i, 1);
                                } else if (matchValue === ":") {
                                  return addAndTokenize(ctx, new TokenKind("Colon", []), i, 1);
                                } else if (matchValue === "<") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("LessThan", [])]), i, 1);
                                } else if (matchValue === "=") {
                                  return addAndTokenize(ctx, new TokenKind("Equals", []), i, 1);
                                } else if (matchValue === ">") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("GreaterThan", [])]), i, 1);
                                } else if (matchValue === "[") {
                                  return addAndTokenize(ctx, new TokenKind("LSquare", []), i, 1);
                                } else if (matchValue === "]") {
                                  return addAndTokenize(ctx, new TokenKind("RSquare", []), i, 1);
                                } else if (matchValue === "^") {
                                  return addAndTokenize(ctx, new TokenKind("Operator", [new Operator("Power", [])]), i, 1);
                                } else if (letter(matchValue)) {
                                  return tokenizeIdent(ctx, i, 1);
                                } else if (number(matchValue)) {
                                  return tokenizeNumber(ctx, false, i, 1);
                                } else {
                                  ctx.Errors.push(Tokenizer.unexpectedCharacter(new _Range(i, i), matchValue));
                                  return addAndTokenize(ctx, new TokenKind("Error", [matchValue]), i, 1);
                                }

                            }

                        }

                    }

                }

            }

        }

    }
  }
}
function tokenize(input) {
  var ctx = void 0;
  var Errors = [];
  ctx = new Context$2([], Errors, input);
  var ctx_1 = tokenizeInput(ctx, 0);
  ctx_1.Tokens.push(new Token(new TokenKind("EndOfFile", []), new _Range(input.length, input.length)));
  return [_Array$from(ctx_1.Tokens), _Array$from(ctx_1.Errors)];
}

var ParsingContext = function () {
    function ParsingContext(tokens, whitespace, errors, silentMode, position) {
        _classCallCheck(this, ParsingContext);

        this.Tokens = tokens;
        this.Whitespace = whitespace;
        this.Errors = errors;
        this.SilentMode = silentMode;
        this.Position = position;
    }

    _createClass(ParsingContext, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Parser.ParsingContext",
                interfaces: ["FSharpRecord", "System.IEquatable"],
                properties: {
                    Tokens: FableArray(Token),
                    Whitespace: FableArray(Token),
                    Errors: FableArray(makeGeneric(_Error, {
                        Range: _Range
                    })),
                    SilentMode: "boolean",
                    Position: "number"
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsRecords(this, other);
        }
    }]);

    return ParsingContext;
}();
setType("TheGamma.Parser.ParsingContext", ParsingContext);
var Context$1 = function (__exports) {
    var clone = __exports.clone = function (ctx) {
        var Whitespace = _Array$from(ctx.Whitespace);

        var Errors = _Array$from(ctx.Errors);

        var Position = ctx.Position;
        return new ParsingContext(ctx.Tokens, Whitespace, Errors, ctx.SilentMode, Position);
    };

    var next = __exports.next = function (ctx) {
        ctx.Position = ctx.Position + 1;
    };

    var error = __exports.error = function (ctx, e) {
        if (!ctx.SilentMode) {
            ctx.Errors.push(e);
        }
    };

    var silent = __exports.silent = function (ctx, f) {
        ctx.SilentMode = true;
        var res = f(ctx);
        ctx.SilentMode = false;
        return res;
    };

    var tokenIndent = __exports.tokenIndent = function (ctx) {
        tokenIndent: while (true) {
            var matchValue = ctx.Tokens[ctx.Position];
            var $var96 = matchValue.Token.Case === "Newline" ? [0] : matchValue.Token.Case === "Error" ? [1, matchValue] : matchValue.Token.Case === "White" ? [1, matchValue] : [2];

            switch ($var96[0]) {
                case 0:
                    var matchValue_1 = ctx.Tokens[ctx.Position + 1];

                    if (matchValue_1.Token.Case === "White") {
                        var s = matchValue_1.Token.Fields[0];
                        next(ctx);
                        next(ctx);
                        ctx.Whitespace.push(matchValue);
                        ctx.Whitespace.push(matchValue_1);
                        ctx = ctx;
                        continue tokenIndent;
                    } else {
                        return null;
                    }

                case 1:
                    ctx.Whitespace.push($var96[1]);
                    next(ctx);
                    ctx = ctx;
                    continue tokenIndent;

                case 2:
                    var white = toList(ctx.Whitespace);
                    ctx.Whitespace.splice(0);
                    return [white, matchValue];
            }
        }
    };

    var tokenNonIndent = __exports.tokenNonIndent = function (ctx) {
        var matchValue = ctx.Tokens[ctx.Position];
        var $var97 = matchValue.Token.Case === "Newline" ? [0, matchValue] : matchValue.Token.Case === "White" ? ctx.Position === 0 ? [1] : [2] : [2];

        switch ($var97[0]) {
            case 0:
                var newNonEmptyLinePos = ctx.Position;
                var i = ctx.Position;

                while (i < ctx.Tokens.length) {
                    var matchValue_1 = ctx.Tokens[i].Token;

                    if (matchValue_1.Case === "Newline") {
                        newNonEmptyLinePos = i;
                        i = i + 1;
                    } else if (matchValue_1.Case === "White") {
                        i = i + 1;
                    } else {
                        i = ctx.Tokens.length;
                    }
                }

                ctx.Position = newNonEmptyLinePos;
                var matchValue_2 = ctx.Tokens[ctx.Position + 1];

                if (matchValue_2.Token.Case === "White") {
                    return null;
                } else {
                    next(ctx);
                    ctx.Whitespace.push($var97[1]);
                    var white = toList(ctx.Whitespace);
                    ctx.Whitespace.splice(0);
                    return [white, matchValue_2];
                }

            case 1:
                return null;

            case 2:
                if (ctx.Position === 0 ? true : ctx.Position === ctx.Tokens.length - 1) {
                    return [new List$1(), matchValue];
                } else {
                    return null;
                }

        }
    };

    return __exports;
}({});
function node$1(rng, n) {
    return new _Node(new List$1(), new List$1(), rng, n, null);
}
function whiteAfter(w, n) {
    var WhiteAfter = append$1(n.WhiteAfter, w);
    return new _Node(n.WhiteBefore, WhiteAfter, n.Range, n.Node, n.Entity);
}
function whiteBefore(w, n) {
    return new _Node(append$1(w, n.WhiteBefore), n.WhiteAfter, n.Range, n.Node, n.Entity);
}

function _Identifier___(t_0, t_1) {
    var t = [t_0, t_1];
    var $var98 = t[1].Token.Case === "Ident" ? [0, t[1].Token.Fields[0], t[1].Range, t[0]] : t[1].Token.Case === "QIdent" ? [0, t[1].Token.Fields[0], t[1].Range, t[0]] : [1];

    switch ($var98[0]) {
        case 0:
            return function (n) {
                return whiteBefore($var98[3], n);
            }(node$1($var98[2], new Name($var98[1])));

        case 1:
            return null;
    }
}

var Associativity = function () {
    function Associativity(caseName, fields) {
        _classCallCheck(this, Associativity);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(Associativity, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Parser.Associativity",
                interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
                cases: {
                    Left: [],
                    Right: []
                }
            };
        }
    }, {
        key: "Equals",
        value: function (other) {
            return equalsUnions(this, other);
        }
    }, {
        key: "CompareTo",
        value: function (other) {
            return compareUnions(this, other);
        }
    }]);

    return Associativity;
}();
setType("TheGamma.Parser.Associativity", Associativity);
function precedence(_arg1) {
    var $var99 = _arg1.Case === "GreaterThan" ? [1] : _arg1.Case === "GreaterThanOrEqual" ? [1] : _arg1.Case === "LessThan" ? [1] : _arg1.Case === "LessThanOrEqual" ? [1] : _arg1.Case === "Plus" ? [2] : _arg1.Case === "Minus" ? [2] : _arg1.Case === "Modulo" ? [3] : _arg1.Case === "Multiply" ? [3] : _arg1.Case === "Divide" ? [3] : _arg1.Case === "Power" ? [4] : [0];

    switch ($var99[0]) {
        case 0:
            return [0, new Associativity("Left", [])];

        case 1:
            return [1, new Associativity("Left", [])];

        case 2:
            return [2, new Associativity("Left", [])];

        case 3:
            return [3, new Associativity("Left", [])];

        case 4:
            return [4, new Associativity("Right", [])];
    }
}
var OpExpr = function () {
    function OpExpr(caseName, fields) {
        _classCallCheck(this, OpExpr);

        this.Case = caseName;
        this.Fields = fields;
    }

    _createClass(OpExpr, [{
        key: _Symbol.reflection,
        value: function () {
            return {
                type: "TheGamma.Parser.OpExpr",
                interfaces: ["FSharpUnion"],
                cases: {
                    OpExpr: [makeGeneric(_Node, {
                        T: Expr
                    }), Option(Tuple([makeGeneric(_Node, {
                        T: Operator
                    }), OpExpr]))]
                }
            };
        }
    }]);

    return OpExpr;
}();
setType("TheGamma.Parser.OpExpr", OpExpr);
function precClimb(minPrec, _arg1) {
    var loop = function loop(result) {
        return function (next) {
            loop: while (true) {
                var $var100 = next != null ? function () {
                    var op = next[0];
                    var next_1 = next[1];
                    return precedence(op.Node)[0] >= minPrec;
                }() ? [0, next[1], next[0]] : [1] : [1];

                switch ($var100[0]) {
                    case 0:
                        var patternInput = precedence($var100[2].Node);
                        var nextMinPrec = patternInput[1].Equals(new Associativity("Left", [])) ? patternInput[0] + 1 : patternInput[0];
                        var patternInput_1 = precClimb(nextMinPrec, $var100[1]);
                        var result_1 = node$1(unionRanges(result.Range, patternInput_1[0].Range), new Expr("Binary", [result, $var100[2], patternInput_1[0]]));
                        result = result_1;
                        next = patternInput_1[1];
                        continue loop;

                    case 1:
                        return [result, next];
                }
            }
        };
    };

    return loop(_arg1.Fields[0])(_arg1.Fields[1]);
}
function buildExpression(terms, term) {
    return precClimb(0, fold(function (oe, tupledArg) {
        return new OpExpr("OpExpr", [tupledArg[0], [tupledArg[1], oe]]);
    }, new OpExpr("OpExpr", [term, null]), terms))[0];
}
function parseExpressionOrNamedParam(ctx) {
    var lookAheadCtx = Context$1.clone(ctx);
    var matchValue = Context$1.tokenIndent(lookAheadCtx);
    var $var101 = void 0;

    if (matchValue != null) {
        var activePatternResult6102 = _Identifier___(matchValue[0], matchValue[1]);

        if (activePatternResult6102 != null) {
            $var101 = [0, activePatternResult6102];
        } else {
            $var101 = [1];
        }
    } else {
        $var101 = [1];
    }

    switch ($var101[0]) {
        case 0:
            Context$1.next(lookAheadCtx);
            var matchValue_1 = Context$1.tokenIndent(lookAheadCtx);
            var $var102 = matchValue_1 != null ? matchValue_1[1].Token.Case === "Equals" ? [0, matchValue_1[1], matchValue_1[0]] : [1] : [1];

            switch ($var102[0]) {
                case 0:
                    Context$1.tokenIndent(ctx);
                    Context$1.next(ctx);
                    Context$1.tokenIndent(ctx);
                    Context$1.next(ctx);
                    var matchValue_2 = parseExpression(new List$1(), ctx);

                    if (matchValue_2 == null) {
                        (function (e) {
                            Context$1.error(ctx, e);
                        })(Parser.unexpectedTokenInArgList($var102[1].Range, $var102[1].Token));

                        return new Choice("Choice1Of2", [[whiteAfter($var102[2], $var101[1]), node$1(new _Range($var101[1].Range.End, $var101[1].Range.End), new Expr("Empty", []))]]);
                    } else {
                        return new Choice("Choice1Of2", [[whiteAfter($var102[2], $var101[1]), matchValue_2]]);
                    }

                case 1:
                    return new Choice("Choice2Of2", [parseExpression(new List$1(), ctx)]);
            }

        case 1:
            return new Choice("Choice2Of2", [parseExpression(new List$1(), ctx)]);
    }
}
function parseCallArgList(afterComma, lastRng, acc, ctx) {
    var _loop = function _loop() {
        var patternInput = void 0;
        var matchValue = parseExpressionOrNamedParam(ctx);

        if (matchValue.Case === "Choice1Of2") {
            patternInput = [true, new List$1(new Argument(matchValue.Fields[0][0], matchValue.Fields[0][1]), acc)];
        } else if (matchValue.Fields[0] != null) {
            patternInput = [true, new List$1(new Argument(null, matchValue.Fields[0]), acc)];
        } else {
            patternInput = [false, acc];
        }

        var matchValue_1 = Context$1.tokenIndent(ctx);
        var $var103 = matchValue_1 != null ? matchValue_1[1].Token.Case === "RParen" ? [0, matchValue_1[1], matchValue_1[0]] : matchValue_1[1].Token.Case === "Comma" ? function () {
            var white = matchValue_1[0];
            var lastRng_1 = matchValue_1[1].Range;
            return patternInput[0];
        }() ? [1, matchValue_1[1].Range, matchValue_1[0]] : [2] : [2] : [2];

        var _ret2 = function () {
            switch ($var103[0]) {
                case 0:
                    Context$1.next(ctx);

                    if (afterComma ? !patternInput[0] : false) {
                        (function (e) {
                            Context$1.error(ctx, e);
                        })(Parser.unexpectedTokenInArgList(lastRng, new TokenKind("RParen", [])));
                    }

                    return {
                        v: {
                            v: [$var103[1].Range, $var103[2], reverse$1(patternInput[1])]
                        }
                    };

                case 1:
                    Context$1.next(ctx);
                    afterComma = true;
                    lastRng = $var103[1];
                    acc = patternInput[1];
                    ctx = ctx;
                    return {
                        v: "continue|parseCallArgList"
                    };

                case 2:
                    var $var104 = matchValue_1 != null ? function () {
                        var t = matchValue_1[1];
                        return !t.Token.Equals(new TokenKind("EndOfFile", []));
                    }() ? [0, matchValue_1[1]] : [1] : [1];

                    switch ($var104[0]) {
                        case 0:
                            Context$1.next(ctx);

                            (function (e_1) {
                                Context$1.error(ctx, e_1);
                            })(Parser.unexpectedTokenInArgList($var104[1].Range, $var104[1].Token));

                            return {
                                v: {
                                    v: Context$1.silent(ctx, function (ctx_1) {
                                        return parseCallArgList(afterComma, $var104[1].Range, patternInput[1], ctx_1);
                                    })
                                }
                            };

                        case 1:
                            (function (e_2) {
                                Context$1.error(ctx, e_2);
                            })(Parser.unexpectedScopeEndInArgList(lastRng));

                            return {
                                v: {
                                    v: [lastRng, new List$1(), reverse$1(patternInput[1])]
                                }
                            };
                    }

            }
        }();

        if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
    };

    parseCallArgList: while (true) {
        var _ret = _loop();

        switch (_ret) {
            case "continue|parseCallArgList":
                continue parseCallArgList;

            default:
                if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
        }
    }
}
function parsePlaceholderRecovery(silent, lastTokRng, lastTokOpt, whiteAcc, ctx) {
    var _loop2 = function _loop2() {
        var matchValue = Context$1.tokenIndent(ctx);
        var $var105 = matchValue != null ? matchValue[1].Token.Case === "RSquare" ? [0, matchValue[1].Range, matchValue[0]] : function () {
            var white = matchValue[0];
            var t = matchValue[1];
            return !t.Token.Equals(new TokenKind("EndOfFile", []));
        }() ? [1, matchValue[1], matchValue[0]] : [2] : [2];

        switch ($var105[0]) {
            case 0:
                Context$1.next(ctx);

                if (!silent) {
                    (function (e) {
                        Context$1.error(ctx, e);
                    })(Parser.unexpectedEndOfPlaceholder($var105[1]));
                }

                return {
                    v: [$var105[1], append$1(whiteAcc, $var105[2])]
                };

            case 1:
                Context$1.next(ctx);

                if (!silent) {
                    (function (e_1) {
                        Context$1.error(ctx, e_1);
                    })(Parser.unexpectedTokenInPlaceholder($var105[1].Range, $var105[1].Token));
                }

                silent = true;
                lastTokRng = $var105[1].Range;
                lastTokOpt = $var105[1].Token;
                whiteAcc = append$1(whiteAcc, append$1($var105[2], ofArray$1([$var105[1]])));
                ctx = ctx;
                return "continue|parsePlaceholderRecovery";

            case 2:
                if (!silent) {
                    (function (e_2) {
                        Context$1.error(ctx, e_2);
                    })(Parser.unexpectedScopeEndInPlaceholder(lastTokRng, lastTokOpt));
                }

                return {
                    v: [lastTokRng, whiteAcc]
                };
        }
    };

    parsePlaceholderRecovery: while (true) {
        var _ret3 = _loop2();

        switch (_ret3) {
            case "continue|parsePlaceholderRecovery":
                continue parsePlaceholderRecovery;

            default:
                if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
        }
    }
}
function parsePlaceholder(rngLSQuare, ctx) {
    var matchValue = Context$1.tokenIndent(ctx);
    var $var106 = void 0;

    if (matchValue != null) {
        var activePatternResult6114 = _Identifier___(matchValue[0], matchValue[1]);

        if (activePatternResult6114 != null) {
            $var106 = [0, activePatternResult6114, matchValue[1]];
        } else {
            $var106 = [1];
        }
    } else {
        $var106 = [1];
    }

    switch ($var106[0]) {
        case 0:
            Context$1.next(ctx);

            var _matchValue_ = Context$1.tokenIndent(ctx);

            var $var107 = _matchValue_ != null ? _matchValue_[1].Token.Case === "Colon" ? [0, _matchValue_[1].Range, _matchValue_[0]] : [1] : [1];

            switch ($var107[0]) {
                case 0:
                    Context$1.next(ctx);
                    var matchValue_2 = parseExpression(new List$1(), ctx);

                    if (matchValue_2 != null) {
                        var matchValue_3 = Context$1.tokenIndent(ctx);
                        var $var108 = matchValue_3 != null ? matchValue_3[1].Token.Case === "RSquare" ? [0, matchValue_3[1].Range, matchValue_3[0]] : [1] : [1];

                        switch ($var108[0]) {
                            case 0:
                                Context$1.next(ctx);
                                return [$var108[1], new Expr("Placeholder", [whiteAfter($var107[2], $var106[1]), whiteAfter($var108[2], matchValue_2)])];

                            case 1:
                                var _patternInput = parsePlaceholderRecovery(false, matchValue_2.Range, null, new List$1(), ctx);

                                return [_patternInput[0], new Expr("Placeholder", [$var106[1], whiteAfter(_patternInput[1], matchValue_2)])];
                        }
                    } else {
                        var patternInput_1 = parsePlaceholderRecovery(false, $var107[1], new TokenKind("Colon", []), new List$1(), ctx);
                        return [patternInput_1[0], new Expr("Placeholder", [$var106[1], whiteAfter(patternInput_1[1], node$1(patternInput_1[0], new Expr("Empty", [])))])];
                    }

                case 1:
                    var patternInput_2 = parsePlaceholderRecovery(false, $var106[1].Range, $var106[2].Token, new List$1(), ctx);
                    return [patternInput_2[0], new Expr("Placeholder", [$var106[1], whiteAfter(patternInput_2[1], node$1(patternInput_2[0], new Expr("Empty", [])))])];
            }

        case 1:
            var patternInput_3 = parsePlaceholderRecovery(false, rngLSQuare, new TokenKind("LSquare", []), new List$1(), ctx);
            return [patternInput_3[0], new Expr("Placeholder", [node$1(rngLSQuare, new Name("")), whiteAfter(patternInput_3[1], node$1(patternInput_3[0], new Expr("Empty", [])))])];
    }
}
function parseIdentAfterDot(body, prevDotRng, prevDotTok, ctx) {
    var matchValue = Context$1.tokenIndent(ctx);
    var $var109 = void 0;

    if (matchValue != null) {
        var activePatternResult6117 = _Identifier___(matchValue[0], matchValue[1]);

        if (activePatternResult6117 != null) {
            $var109 = [0, activePatternResult6117];
        } else {
            $var109 = [1];
        }
    } else {
        $var109 = [1];
    }

    var _ret4 = function () {
        switch ($var109[0]) {
            case 0:
                Context$1.next(ctx);
                var body_1 = node$1(unionRanges(body.Range, $var109[1].Range), new Expr("Member", [body, node$1($var109[1].Range, new Expr("Variable", [$var109[1]]))]));
                return {
                    v: parseCallOrMember(body_1, ctx)
                };

            case 1:
                var $var110 = matchValue == null ? [1] : matchValue[1].Token.Case === "LSquare" ? [0, matchValue[1].Range, matchValue[0]] : matchValue[1].Token.Case === "EndOfFile" ? [1] : [2, matchValue[1], matchValue[0]];

                var _ret5 = function () {
                    switch ($var110[0]) {
                        case 0:
                            Context$1.next(ctx);
                            var patternInput = parsePlaceholder($var110[1], ctx);

                            var body_2 = function (n) {
                                return whiteBefore($var110[2], n);
                            }(node$1(unionRanges($var110[1], patternInput[0]), new Expr("Member", [body, node$1(unionRanges(patternInput[0], $var110[1]), patternInput[1])])));

                            return {
                                v: {
                                    v: parseCallOrMember(body_2, ctx)
                                }
                            };

                        case 1:
                            (function (e) {
                                Context$1.error(ctx, e);
                            })(Parser.unexpectedScopeEndAfterDot(prevDotRng, prevDotTok));

                            var emptyRng = new _Range(prevDotRng.End + 1, prevDotRng.End);
                            return {
                                v: {
                                    v: node$1(unionRanges(body.Range, emptyRng), new Expr("Member", [body, node$1(emptyRng, new Expr("Variable", [node$1(emptyRng, new Name(""))]))]))
                                }
                            };

                        case 2:
                            Context$1.next(ctx);

                            (function (e_1) {
                                Context$1.error(ctx, e_1);
                            })(Parser.unexpectedTokenAfterDot($var110[1].Range, $var110[1].Token));

                            var emptyRng_1 = new _Range(prevDotRng.End + 1, prevDotRng.End);
                            var body_3 = node$1(unionRanges(body.Range, emptyRng_1), new Expr("Member", [body, node$1(emptyRng_1, new Expr("Variable", [node$1(emptyRng_1, new Name(""))]))]));
                            return {
                                v: {
                                    v: Context$1.silent(ctx, function (ctx_1) {
                                        return parseIdentAfterDot(body_3, prevDotRng, prevDotTok, ctx_1);
                                    })
                                }
                            };
                    }
                }();

                if ((typeof _ret5 === "undefined" ? "undefined" : _typeof(_ret5)) === "object") return _ret5.v;
        }
    }();

    if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
}
function parseCallOrMember(body, ctx) {
    var matchValue = Context$1.tokenIndent(ctx);
    var $var111 = matchValue != null ? matchValue[1].Token.Case === "LParen" ? [0, matchValue[1].Range, matchValue[0]] : matchValue[1].Token.Case === "Dot" ? [1, matchValue[1], matchValue[0]] : [2] : [2];

    switch ($var111[0]) {
        case 0:
            Context$1.next(ctx);

            var _patternInput2 = parseCallArgList(false, $var111[1], new List$1(), ctx);

            var body_1 = node$1(unionRanges(body.Range, _patternInput2[0]), new Expr("Call", [body, whiteAfter(_patternInput2[1], node$1(unionRanges($var111[1], _patternInput2[0]), _patternInput2[2]))]));

            var _matchValue_2 = Context$1.tokenIndent(ctx);

            var $var112 = _matchValue_2 != null ? _matchValue_2[1].Token.Case === "Dot" ? [0, _matchValue_2[1], _matchValue_2[0]] : [1] : [1];

            switch ($var112[0]) {
                case 0:
                    Context$1.next(ctx);
                    return parseIdentAfterDot(whiteAfter($var112[2], body_1), $var112[1].Range, $var112[1].Token, ctx);

                case 1:
                    return body_1;
            }

        case 1:
            Context$1.next(ctx);
            return parseIdentAfterDot(whiteAfter($var111[2], body), $var111[1].Range, $var111[1].Token, ctx);

        case 2:
            return body;
    }
}
function parseFunction(ctx, funRng) {
    var matchValue = Context$1.tokenIndent(ctx);
    var $var113 = void 0;

    if (matchValue != null) {
        var activePatternResult6128 = _Identifier___(matchValue[0], matchValue[1]);

        if (activePatternResult6128 != null) {
            $var113 = [0, activePatternResult6128];
        } else {
            $var113 = [1];
        }
    } else {
        $var113 = [1];
    }

    switch ($var113[0]) {
        case 0:
            Context$1.next(ctx);

            var _matchValue_3 = Context$1.tokenIndent(ctx);

            var $var114 = _matchValue_3 != null ? _matchValue_3[1].Token.Case === "Arrow" ? [0, _matchValue_3[1].Range, _matchValue_3[0]] : [1, _matchValue_3] : [1, _matchValue_3];

            switch ($var114[0]) {
                case 0:
                    Context$1.next(ctx);
                    var body = void 0;
                    var matchValue_2 = parseExpression(new List$1(), ctx);

                    if (matchValue_2 != null) {
                        body = matchValue_2;
                    } else {
                        (function (e) {
                            Context$1.error(ctx, e);
                        })(Parser.missingBodyOfFunc(unionRanges(funRng, $var114[1])));

                        body = node$1(new _Range($var114[1].End, $var114[1].End), new Expr("Empty", []));
                    }

                    var rng = unionRanges(funRng, body.Range);
                    return node$1(rng, new Expr("Function", [whiteAfter($var114[2], $var113[1]), body]));

                case 1:
                    var _patternInput3 = void 0;

                    if ($var114[1] != null) {
                        var whiteAfterId = $var114[1][0];
                        var t = $var114[1][1];
                        _patternInput3 = [t.Range, whiteAfterId];
                    } else {
                        _patternInput3 = [unionRanges(funRng, $var113[1].Range), new List$1()];
                    }

                    (function (e_1) {
                        Context$1.error(ctx, e_1);
                    })(Parser.missingArrowInFunc(_patternInput3[0]));

                    var body_1 = void 0;
                    var matchValue_3 = parseExpression(new List$1(), ctx);

                    if (matchValue_3 != null) {
                        body_1 = matchValue_3;
                    } else {
                        body_1 = node$1(new _Range($var113[1].Range.End, $var113[1].Range.End), new Expr("Empty", []));
                    }

                    return node$1(unionRanges(funRng, body_1.Range), new Expr("Function", [$var113[1], whiteBefore(_patternInput3[1], body_1)]));
            }

        case 1:
            if (matchValue == null) {
                (function (e_2) {
                    Context$1.error(ctx, e_2);
                })(Parser.unexpectedScopeEndInFunc(funRng));

                var rng_1 = new _Range(funRng.End, funRng.End);
                return node$1(rng_1, new Expr("Function", [node$1(rng_1, new Name("")), node$1(rng_1, new Expr("Empty", []))]));
            } else {
                var _ret6 = function () {
                    var white = matchValue[0];
                    var t_1 = matchValue[1];

                    (function (e_3) {
                        Context$1.error(ctx, e_3);
                    })(Parser.unexpectedTokenAfterFun(t_1.Range, t_1.Token));

                    var rng_2 = new _Range(funRng.End, funRng.End);
                    return {
                        v: function (n) {
                            return whiteBefore(white, n);
                        }(node$1(rng_2, new Expr("Function", [node$1(rng_2, new Name("")), node$1(rng_2, new Expr("Empty", []))])))
                    };
                }();

                if ((typeof _ret6 === "undefined" ? "undefined" : _typeof(_ret6)) === "object") return _ret6.v;
            }

    }
}
function parseListElements(afterComma, lastRng, whiteStart, startRng, acc, ctx) {
    var _loop3 = function _loop3() {
        var patternInput = void 0;
        var matchValue = parseExpression(new List$1(), ctx);

        if (matchValue != null) {
            patternInput = [true, function (white) {
                return new List$1(whiteAfter(white, matchValue), acc);
            }];
        } else {
            patternInput = [false, function (_arg1) {
                return acc;
            }];
        }

        var matchValue_1 = Context$1.tokenIndent(ctx);
        var $var115 = matchValue_1 != null ? matchValue_1[1].Token.Case === "RSquare" ? [0, matchValue_1[1].Range, matchValue_1[0]] : matchValue_1[1].Token.Case === "Comma" ? [1, matchValue_1[1].Range, matchValue_1[0]] : function () {
            var t = matchValue_1[1];
            return !t.Token.Equals(new TokenKind("EndOfFile", []));
        }() ? [2, matchValue_1[1]] : [3] : [3];

        switch ($var115[0]) {
            case 0:
                Context$1.next(ctx);

                if (!patternInput[0] ? afterComma : false) {
                    (function (e) {
                        Context$1.error(ctx, e);
                    })(Parser.unexpectedTokenInList(lastRng, new TokenKind("Comma", [])));
                }

                return {
                    v: function (n) {
                        return whiteBefore($var115[2], n);
                    }(node$1(unionRanges(startRng, $var115[1]), new Expr("List", [reverse$1(patternInput[1](new List$1()))])))
                };

            case 1:
                Context$1.next(ctx);

                if (!patternInput[0] ? afterComma : false) {
                    (function (e_1) {
                        Context$1.error(ctx, e_1);
                    })(Parser.unexpectedTokenInList($var115[1], new TokenKind("Comma", [])));
                }

                afterComma = true;
                lastRng = $var115[1];
                whiteStart = whiteStart;
                startRng = startRng;
                acc = patternInput[1]($var115[2]);
                ctx = ctx;
                return "continue|parseListElements";

            case 2:
                Context$1.next(ctx);

                (function (e_2) {
                    Context$1.error(ctx, e_2);
                })(Parser.unexpectedTokenInList($var115[1].Range, $var115[1].Token));

                return {
                    v: Context$1.silent(ctx, function (ctx_1) {
                        return parseListElements(afterComma, $var115[1].Range, whiteStart, startRng, patternInput[1](new List$1()), ctx_1);
                    })
                };

            case 3:
                (function (e_3) {
                    Context$1.error(ctx, e_3);
                })(Parser.unexpectedScopeEndInList(lastRng));

                return {
                    v: node$1(unionRanges(startRng, lastRng), new Expr("List", [reverse$1(patternInput[1](new List$1()))]))
                };
        }
    };

    parseListElements: while (true) {
        var _ret7 = _loop3();

        switch (_ret7) {
            case "continue|parseListElements":
                continue parseListElements;

            default:
                if ((typeof _ret7 === "undefined" ? "undefined" : _typeof(_ret7)) === "object") return _ret7.v;
        }
    }
}
function parseTerm(ctx) {
    var matchValue = Context$1.tokenIndent(ctx);
    var $var116 = void 0;

    if (matchValue != null) {
        var activePatternResult6146 = _Identifier___(matchValue[0], matchValue[1]);

        if (activePatternResult6146 != null) {
            $var116 = [0, activePatternResult6146];
        } else {
            $var116 = [1];
        }
    } else {
        $var116 = [1];
    }

    var _ret8 = function () {
        switch ($var116[0]) {
            case 0:
                Context$1.next(ctx);
                return {
                    v: parseCallOrMember(node$1($var116[1].Range, new Expr("Variable", [$var116[1]])), ctx)
                };

            case 1:
                var $var117 = matchValue != null ? matchValue[1].Token.Case === "Number" ? [0, matchValue[1].Token.Fields[1], matchValue[1].Range, matchValue[0]] : matchValue[1].Token.Case === "String" ? [1, matchValue[1].Range, matchValue[1].Token.Fields[0], matchValue[0]] : matchValue[1].Token.Case === "Boolean" ? [2, matchValue[1].Token.Fields[0], matchValue[1].Range, matchValue[0]] : matchValue[1].Token.Case === "LParen" ? [3, matchValue[1], matchValue[0]] : matchValue[1].Token.Case === "LSquare" ? [4, matchValue[1], matchValue[0]] : matchValue[1].Token.Case === "Fun" ? [5, matchValue[1], matchValue[0]] : [6] : [6];

                switch ($var117[0]) {
                    case 0:
                        Context$1.next(ctx);
                        return {
                            v: function (n) {
                                return whiteAfter($var117[3], n);
                            }(node$1($var117[2], new Expr("Number", [$var117[1]])))
                        };

                    case 1:
                        Context$1.next(ctx);
                        return {
                            v: function (n_1) {
                                return whiteAfter($var117[3], n_1);
                            }(node$1($var117[1], new Expr("String", [$var117[2]])))
                        };

                    case 2:
                        Context$1.next(ctx);
                        return {
                            v: function (n_2) {
                                return whiteAfter($var117[3], n_2);
                            }(node$1($var117[2], new Expr("Boolean", [$var117[1]])))
                        };

                    case 3:
                        Context$1.next(ctx);
                        return {
                            v: parseParenTermEnd(new List$1($var117[1], reverse$1($var117[2])), new List$1(), parseExpression(new List$1(), ctx), ctx)
                        };

                    case 4:
                        Context$1.next(ctx);
                        return {
                            v: parseListElements(false, $var117[1].Range, $var117[2], $var117[1].Range, new List$1(), ctx)
                        };

                    case 5:
                        Context$1.next(ctx);
                        return {
                            v: parseFunction(ctx, $var117[1].Range)
                        };

                    case 6:
                        return {
                            v: null
                        };
                }

        }
    }();

    if ((typeof _ret8 === "undefined" ? "undefined" : _typeof(_ret8)) === "object") return _ret8.v;
}
function parseParenTermEnd(wb, wa, bodyOpt, ctx) {
    var makeBody = function makeBody(wa_1) {
        var body = void 0;

        if (bodyOpt == null) {
            var rng = function (list) {
                return reduce(function (r1, r2) {
                    return unionRanges(r1, r2);
                }, list);
            }(map$5(function (t) {
                return t.Range;
            }, append$1(ofArray$1([wb.head]), wa_1)));

            (function (e) {
                Context$1.error(ctx, e);
            })(Parser.missingParenthesizedExpr(rng));

            body = node$1(rng, new Expr("Empty", []));
        } else {
            body = bodyOpt;
        }

        return whiteAfter(reverse$1(wa_1), whiteBefore(reverse$1(wb), body));
    };

    var matchValue = Context$1.tokenIndent(ctx);

    if (matchValue == null) {
        var rng_1 = bodyOpt != null ? bodyOpt.Range : wb.head.Range;

        (function (e_1) {
            Context$1.error(ctx, e_1);
        })(Parser.unexpectedScopeEndInParenthesizedExpr(rng_1));

        return makeBody(wa);
    } else if (matchValue[1].Token.Case === "RParen") {
        Context$1.next(ctx);
        return makeBody(new List$1(matchValue[1], append$1(reverse$1(matchValue[0]), wa)));
    } else {
        Context$1.next(ctx);

        (function (e_2) {
            Context$1.error(ctx, e_2);
        })(Parser.unexpectedTokenInParenthesizedExpr(matchValue[1].Range, matchValue[1].Token));

        return Context$1.silent(ctx, function (ctx_1) {
            return parseParenTermEnd(wb, new List$1(matchValue[1], append$1(reverse$1(matchValue[0]), wa)), bodyOpt, ctx_1);
        });
    }
}
function parseExpression(terms, ctx) {
    parseExpression: while (true) {
        var _matchValue = [terms, parseTerm(ctx)];

        if (_matchValue[1] == null) {
            if (_matchValue[0].tail != null) {
                var terms_1 = _matchValue[0].tail;
                var term = _matchValue[0].head[0];
                var op = _matchValue[0].head[1];

                (function (e) {
                    Context$1.error(ctx, e);
                })(Parser.unexpectedEndAfterOperator(op.Range, new TokenKind("Operator", [op.Node])));

                return buildExpression(terms_1, term);
            } else {
                return null;
            }
        } else {
            var _ret9 = function () {
                var term_1 = _matchValue[1];
                var matchValue_1 = Context$1.tokenIndent(ctx);

                if (matchValue_1 == null) {
                    return {
                        v: buildExpression(_matchValue[0], term_1)
                    };
                } else if (matchValue_1[1].Token.Case === "Equals") {
                    Context$1.next(ctx);
                    terms = new List$1([term_1, whiteBefore(matchValue_1[0], node$1(matchValue_1[1].Range, new Operator("Equals", [])))], _matchValue[0]);
                    ctx = ctx;
                    return "continue|parseExpression";
                } else if (matchValue_1[1].Token.Case === "Operator") {
                    Context$1.next(ctx);
                    terms = new List$1([term_1, whiteBefore(matchValue_1[0], node$1(matchValue_1[1].Range, matchValue_1[1].Token.Fields[0]))], _matchValue[0]);
                    ctx = ctx;
                    return "continue|parseExpression";
                } else {
                    return {
                        v: function (n) {
                            return whiteAfter(matchValue_1[0], n);
                        }(buildExpression(_matchValue[0], term_1))
                    };
                }
            }();

            switch (_ret9) {
                case "continue|parseExpression":
                    continue parseExpression;

                default:
                    if ((typeof _ret9 === "undefined" ? "undefined" : _typeof(_ret9)) === "object") return _ret9.v;
            }
        }
    }
}
function parseLetBindingBody(lastRng, ctx) {
    var matchValue = parseExpression(new List$1(), ctx);

    if (matchValue == null) {
        var _matchValue_4 = Context$1.tokenIndent(ctx);

        if (_matchValue_4 != null) {
            var _ret10 = function () {
                var white = _matchValue_4[0];
                var t = _matchValue_4[1];

                (function (e) {
                    Context$1.error(ctx, e);
                })(Parser.unexpectedTokenInLetBinding(t.Range, t.Token));

                return {
                    v: Context$1.silent(ctx, function (ctx_1) {
                        return parseLetBindingBody(t.Range, ctx_1);
                    })
                };
            }();

            if ((typeof _ret10 === "undefined" ? "undefined" : _typeof(_ret10)) === "object") return _ret10.v;
        } else {
            (function (e_1) {
                Context$1.error(ctx, e_1);
            })(Parser.unexpectedScopeEndInLet(lastRng));

            return node$1(lastRng, new Expr("Empty", []));
        }
    } else {
        return matchValue;
    }
}
function skipNestedTokens(firstTok, white, ctx) {
    skipNestedTokens: while (true) {
        var _matchValue2 = Context$1.tokenIndent(ctx);

        if (_matchValue2 != null) {
            if (_matchValue2[1].Token.Case === "EndOfFile") {
                return [equals(firstTok, null) ? _matchValue2[1] : firstTok, append$1(white, _matchValue2[0])];
            } else {
                Context$1.next(ctx);
                var firstTok_1 = equals(firstTok, null) ? _matchValue2[1] : firstTok;
                firstTok = firstTok_1;
                white = append$1(white, append$1(_matchValue2[0], ofArray$1([_matchValue2[1]])));
                ctx = ctx;
                continue skipNestedTokens;
            }
        } else {
            return [firstTok, white];
        }
    }
}
function parseLetBinding(whiteBeforeLet, rngLet, ctx) {
    var matchValue = Context$1.tokenIndent(ctx);
    var $var118 = void 0;

    if (matchValue != null) {
        var activePatternResult6167 = _Identifier___(matchValue[0], matchValue[1]);

        if (activePatternResult6167 != null) {
            $var118 = [0, activePatternResult6167];
        } else {
            $var118 = [1];
        }
    } else {
        $var118 = [1];
    }

    switch ($var118[0]) {
        case 0:
            Context$1.next(ctx);

            var _matchValue_5 = Context$1.tokenIndent(ctx);

            if (_matchValue_5 == null) {
                (function (e) {
                    Context$1.error(ctx, e);
                })(Parser.missingBodyInLetBinding($var118[1].Range));

                var body = node$1(new _Range($var118[1].Range.End, $var118[1].Range.End), new Expr("Empty", []));
                return function (n) {
                    return whiteBefore(whiteBeforeLet, n);
                }(node$1(unionRanges(rngLet, $var118[1].Range), new Command("Let", [$var118[1], body])));
            } else if (_matchValue_5[1].Token.Case === "Equals") {
                Context$1.next(ctx);
                var body_1 = parseLetBindingBody(_matchValue_5[1].Range, ctx);
                return function (n_1) {
                    return whiteBefore(whiteBeforeLet, n_1);
                }(node$1(unionRanges(rngLet, body_1.Range), new Command("Let", [whiteAfter(_matchValue_5[0], $var118[1]), body_1])));
            } else {
                (function (e_1) {
                    Context$1.error(ctx, e_1);
                })(Parser.unexpectedTokenInLetBinding(_matchValue_5[1].Range, _matchValue_5[1].Token));

                var body_2 = parseLetBindingBody(_matchValue_5[1].Range, ctx);
                return function (n_2) {
                    return whiteBefore(whiteBeforeLet, n_2);
                }(node$1(unionRanges(rngLet, $var118[1].Range), new Command("Let", [whiteAfter(_matchValue_5[0], $var118[1]), body_2])));
            }

        case 1:
            if (matchValue == null) {
                var _ret11 = function () {
                    (function (e_2) {
                        Context$1.error(ctx, e_2);
                    })(Parser.missingBodyInLetBinding(rngLet));

                    var rng = new _Range(rngLet.End, rngLet.End);
                    return {
                        v: function (n_3) {
                            return whiteBefore(whiteBeforeLet, n_3);
                        }(function (n_4) {
                            return node$1(rng, n_4);
                        }(new Command("Let", [node$1(rng, new Name("")), node$1(rng, new Expr("Empty", []))])))
                    };
                }();

                if ((typeof _ret11 === "undefined" ? "undefined" : _typeof(_ret11)) === "object") return _ret11.v;
            } else {
                var whiteAfterLet = matchValue[0];
                var t = matchValue[1];

                (function (e_3) {
                    Context$1.error(ctx, e_3);
                })(Parser.unexpectedTokenInLetBinding(t.Range, t.Token));

                var letEndRng = new _Range(rngLet.End, rngLet.End);
                var body_3 = void 0;
                var matchValue_2 = parseExpression(new List$1(), ctx);

                if (matchValue_2 == null) {
                    var _patternInput4 = skipNestedTokens(null, new List$1(), ctx);

                    var skipRng = function (list) {
                        return reduce(function (r1, r2) {
                            return unionRanges(r1, r2);
                        }, list);
                    }(map$5(function (t_1) {
                        return t_1.Range;
                    }, new List$1(t, _patternInput4[1])));

                    body_3 = whiteAfter(new List$1(t, _patternInput4[1]), node$1(skipRng, new Expr("Empty", [])));
                } else {
                    body_3 = matchValue_2;
                }

                return function (n_5) {
                    return whiteBefore(whiteBeforeLet, n_5);
                }(node$1(unionRanges(rngLet, body_3.Range), new Command("Let", [whiteBefore(whiteAfterLet, node$1(letEndRng, new Name(""))), body_3])));
            }

    }
}
function parseCommands(acc, ctx) {
    var _loop4 = function _loop4() {
        var matchValue = Context$1.tokenNonIndent(ctx);

        if (matchValue == null) {
            var _ret13 = function () {
                var patternInput = skipNestedTokens(null, new List$1(), ctx);
                var firstSkipped = patternInput[0];

                (function (e) {
                    Context$1.error(ctx, e);
                })(Parser.unexpectedNestedTokenInCommand(firstSkipped.Range, firstSkipped.Token));

                var skipRng = function (list) {
                    return reduce(function (r1, r2) {
                        return unionRanges(r1, r2);
                    }, list);
                }(map$5(function (t) {
                    return t.Range;
                }, new List$1(firstSkipped, patternInput[1])));

                var cmd = function (n) {
                    return whiteAfter(patternInput[1], n);
                }(node$1(skipRng, new Command("Expr", [node$1(skipRng, new Expr("Empty", []))])));

                acc = new List$1(cmd, acc);
                ctx = ctx;
                return {
                    v: "continue|parseCommands"
                };
            }();

            if ((typeof _ret13 === "undefined" ? "undefined" : _typeof(_ret13)) === "object") return _ret13.v;
        } else if (matchValue[1].Token.Case === "EndOfFile") {
            if (acc.tail == null) {
                return {
                    v: new List$1()
                };
            } else {
                return {
                    v: reverse$1(new List$1(new _Node(acc.head.WhiteBefore, matchValue[0], acc.head.Range, acc.head.Node, acc.head.Entity), acc.tail))
                };
            }
        } else if (matchValue[1].Token.Case === "Let") {
            Context$1.next(ctx);
            var cmd_1 = parseLetBinding(matchValue[0], matchValue[1].Range, ctx);
            acc = new List$1(cmd_1, acc);
            ctx = ctx;
            return "continue|parseCommands";
        } else {
            var _matchValue_6 = parseExpression(new List$1(), ctx);

            if (_matchValue_6 == null) {
                var patternInput_1 = skipNestedTokens(null, new List$1(), ctx);

                (function (e_1) {
                    Context$1.error(ctx, e_1);
                })(Parser.unexpectedNestedTokenInCommand(matchValue[1].Range, matchValue[1].Token));

                var skipRng_1 = function (list_1) {
                    return reduce(function (r1_1, r2_1) {
                        return unionRanges(r1_1, r2_1);
                    }, list_1);
                }(map$5(function (t_1) {
                    return t_1.Range;
                }, new List$1(matchValue[1], patternInput_1[1])));

                var cmd_2 = whiteAfter(new List$1(matchValue[1], patternInput_1[1]), node$1(skipRng_1, new Command("Expr", [node$1(skipRng_1, new Expr("Empty", []))])));
                acc = new List$1(cmd_2, acc);
                ctx = ctx;
                return "continue|parseCommands";
            } else {
                var cmd_3 = function (n_1) {
                    return whiteBefore(matchValue[0], n_1);
                }(node$1(_matchValue_6.Range, new Command("Expr", [_matchValue_6])));

                acc = new List$1(cmd_3, acc);
                ctx = ctx;
                return "continue|parseCommands";
            }
        }
    };

    parseCommands: while (true) {
        var _ret12 = _loop4();

        switch (_ret12) {
            case "continue|parseCommands":
                continue parseCommands;

            default:
                if ((typeof _ret12 === "undefined" ? "undefined" : _typeof(_ret12)) === "object") return _ret12.v;
        }
    }
}
function parseProgram(input) {
    try {
        var _patternInput5 = tokenize(input);

        var ctx = void 0;
        var Position = 0;
        var SilentMode = false;
        var Errors = [];
        ctx = new ParsingContext(_patternInput5[0], [], Errors, SilentMode, Position);
        var cmds = parseCommands(new List$1(), ctx);

        var errors = _patternInput5[1].concat(_Array$from(ctx.Errors));

        var rng_1 = fold(function (rng, cmd) {
            return unionRanges(rng, cmd.Range);
        }, new _Range(0, 0), cmds);
        return [new Program$$1(node$1(rng_1, cmds)), errors];
    } catch (e) {
        Log.exn("parsing", "Exception while parsing program: %O", e);
        var rng_2 = new _Range(0, 0);
        var error = Parser.exceptionWhileParsing(rng_2, toString$2(e));
        return [new Program$$1(node$1(rng_2, new List$1())), [error]];
    }
}

var CheckingContext = function () {
  function CheckingContext(errors, globals, ranges) {
    _classCallCheck(this, CheckingContext);

    this.Errors = errors;
    this.Globals = globals;
    this.Ranges = ranges;
  }

  _createClass(CheckingContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.TypeChecker.CheckingContext",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          Errors: FableArray(makeGeneric(_Error, {
            Range: _Range
          })),
          Globals: Interface("System.Collections.Generic.IDictionary"),
          Ranges: Interface("System.Collections.Generic.IDictionary")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return CheckingContext;
}();
setType("TheGamma.TypeChecker.CheckingContext", CheckingContext);
function addError(ctx, ent, err) {
  ctx.Errors.push(err(ctx.Ranges.get(ent.Symbol)));
}
function inferListType(typs) {
  return reduce(function (f) {
    return function (x, y) {
      return f(x) > f(y) ? x : y;
    };
  }(function (tuple) {
    return tuple[1];
  }), append$1(ofArray$1([[new Type("Any", []), 0]]), map$5(function (g) {
    return [g.head, g.length];
  }, function (list) {
    return List.groupWith(function (t1) {
      return function (t2) {
        return typesEqual(t1, t2);
      };
    }, list);
  }(filter$2(function (_arg1) {
    return _arg1.Case === "Any" ? false : true;
  }, typs)))))[0];
}
function resolveParameterType(instTy, parSpec) {
  if (instTy.Case === "Method") {
    var par = parSpec.Case === "Choice2Of2" ? function (source) {
      return tryItem(parSpec.Fields[0], source);
    }(instTy.Fields[0]) : tryFind(function (tupledArg) {
      return tupledArg[0] === parSpec.Fields[0];
    }, instTy.Fields[0]);

    if (par != null) {
      var t = par[2];
      return t;
    } else {
      throw new Error("resolveParameterType: Parameter specification was incorrect");
    }
  } else {
    throw new Error("resolveParameterType: Instance is not an object");
  }
}
function checkMethodCall(methodName, ctx, parameterTypes, resultTypeFunc, argList, args) {
  var patternInput = void 0;
  var pb = toList(takeWhile(function (_arg1) {
    return _arg1.Kind.Case === "NamedParam" ? false : true;
  }, args));
  var nb = toList(skipWhile(function (_arg2) {
    return _arg2.Kind.Case === "NamedParam" ? false : true;
  }, args));
  patternInput = [_Array$from(pb), create$6(choose$1(function (arg) {
    if (arg.Kind.Case === "NamedParam") {
      return [arg.Kind.Fields[0].Name, arg.Kind.Fields[1]];
    } else {
      (function (err) {
        addError(ctx, arg, err);
      })(function (rng) {
        return TypeChecker.nameBasedParamMustBeLast(rng);
      });

      return null;
    }
  }, nb), new GenericComparer(compare))];
  var matchedArguments = mapIndexed$1(function (index, tupledArg) {
    var arg_1 = index < patternInput[0].length ? patternInput[0][index] : tryFind$1(tupledArg[0], patternInput[1]);

    if (arg_1 == null) {
      if (tupledArg[1]) {
        return [tupledArg[0], tupledArg[2], null];
      } else if (arg_1 == null) {
        (function (err_1) {
          addError(ctx, argList, err_1);
        })(function (rng_1) {
          return TypeChecker.parameterMissingValue(tupledArg[0], rng_1);
        });

        return [tupledArg[0], new Type("Any", []), null];
      } else {
        throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\thegamma\\analyzer/typechecker.fs", 73, 12);
      }
    } else {
      return [tupledArg[0], getType$1(ctx, arg_1), arg_1];
    }
  }, parameterTypes);
  var matchValue_1 = resultTypeFunc(toList(delay(function () {
    return collect(function (matchValue) {
      return singleton(matchValue[1]);
    }, matchedArguments);
  })));

  if (matchValue_1 == null) {
    Log.trace("typechecker", "Invalid argument type when calling '%s'. Argument types: %O", methodName, _Array$from(delay(function () {
      return collect(function (matchValue_2) {
        return singleton(matchValue_2[1]);
      }, matchedArguments);
    })));

    (function (err_2) {
      addError(ctx, argList, err_2);
    })(function (rng_2) {
      return TypeChecker.parameterConflict(rng_2);
    });

    return new Type("Any", []);
  } else {
    return matchValue_1;
  }
}
function getType$1(ctx, e) {
  if (function () {
    return e.Type == null;
  }(null)) {
    (function () {
      var errorCount = ctx.Errors.length;
      e.Type = typeCheckEntity(ctx, e);
      e.Errors = toList(delay(function () {
        return map$3(function (i) {
          return ctx.Errors[i];
        }, range(errorCount, ctx.Errors.length - 1));
      }));
    })();
  }

  return e.Type;
}
function typeCheckEntity(ctx, e) {
  if (e.Kind.Case === "Variable") {
    return getType$1(ctx, e.Kind.Fields[1]);
  } else if (e.Kind.Case === "Member") {
    if (e.Kind.Fields[1].Kind.Case === "MemberName") {
      var _ret2 = function () {
        var matchValue = getType$1(ctx, e.Kind.Fields[0]);
        var $var124 = void 0;

        if (matchValue.Case === "Any") {
          $var124 = [0];
        } else if (matchValue.Case === "Object") {
          var activePatternResult6392 = function (obj) {
            return _FindMember___(e.Kind.Fields[1].Kind.Fields[0], obj);
          }(matchValue.Fields[0]);

          if (activePatternResult6392 != null) {
            $var124 = [1, activePatternResult6392];
          } else {
            $var124 = [2];
          }
        } else {
          $var124 = [2];
        }

        switch ($var124[0]) {
          case 0:
            return {
              v: new Type("Any", [])
            };

          case 1:
            e.Meta = $var124[1].Metadata;
            return {
              v: $var124[1].Type
            };

          case 2:
            if (matchValue.Case === "Object") {
              (function (err) {
                addError(ctx, e.Kind.Fields[1], err);
              })(function () {
                var members = matchValue.Fields[0].Members;
                return function (rng) {
                  return TypeChecker.memberMissing(e.Kind.Fields[1].Kind.Fields[0].Name, members, rng);
                };
              }());

              return {
                v: new Type("Any", [])
              };
            } else {
              (function (err_1) {
                addError(ctx, e.Kind.Fields[0], err_1);
              })(function (rng_1) {
                return TypeChecker.notAnObject(e.Kind.Fields[1].Kind.Fields[0].Name, matchValue, rng_1);
              });

              return {
                v: new Type("Any", [])
              };
            }

        }
      }();

      if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
    } else {
      Log.error("typechecker", "typeCheckEntity: Member access is missing member name!");
      throw new Error("typeCheckEntity: Member access is missing member name!");
    }
  } else if (e.Kind.Case === "Call") {
    if (e.Kind.Fields[1].Kind.Case === "ArgumentList") {
      var _ret3 = function () {
        var lastName = lastChainElement(e.Kind.Fields[0]);
        var matchValue_1 = getType$1(ctx, e.Kind.Fields[0]);

        if (matchValue_1.Case === "Any") {
          return {
            v: new Type("Any", [])
          };
        } else if (matchValue_1.Case === "Method") {
          return {
            v: checkMethodCall(Entity_get_Name.bind(e.Kind.Fields[0])(), ctx, matchValue_1.Fields[0], matchValue_1.Fields[1], e.Kind.Fields[1], e.Kind.Fields[1].Kind.Fields[0])
          };
        } else {
          (function (err_2) {
            addError(ctx, e.Kind.Fields[0], err_2);
          })(function () {
            var name = Entity_get_Name.bind(lastName)();
            return function (rng_2) {
              return TypeChecker.notAnMethod(name, matchValue_1, rng_2);
            };
          }());

          return {
            v: new Type("Any", [])
          };
        }
      }();

      if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
    } else {
      Log.error("typechecker", "typeCheckEntity: Call to %s is missing argument list!", Entity_get_Name.bind(lastChainElement(e.Kind.Fields[0]))());
      return fsFormat("typeCheckEntity: Call to %s is missing argument list!")(function (x) {
        throw new Error(x);
      })(Entity_get_Name.bind(lastChainElement(e.Kind.Fields[0]))());
    }
  } else if (e.Kind.Case === "Placeholder") {
    return getType$1(ctx, e.Kind.Fields[1]);
  } else if (e.Kind.Case === "Operator") {
    iterateIndexed(function (idx, operand) {
      var typ = getType$1(ctx, operand);

      if (!typesEqual(typ, new Type("Primitive", [new PrimitiveType("Number", [])]))) {
        (function (err_3) {
          addError(ctx, operand, err_3);
        })(function (rng_3) {
          return TypeChecker.numericOperatorExpectsNumbers(e.Kind.Fields[1], idx, typ, rng_3);
        });
      }
    }, ofArray$1([e.Kind.Fields[0], e.Kind.Fields[2]]));
    var $var125 = e.Kind.Fields[1].Case === "Equals" ? [0] : e.Kind.Fields[1].Case === "LessThan" ? [0] : e.Kind.Fields[1].Case === "GreaterThan" ? [0] : e.Kind.Fields[1].Case === "LessThanOrEqual" ? [0] : e.Kind.Fields[1].Case === "GreaterThanOrEqual" ? [0] : [1];

    switch ($var125[0]) {
      case 0:
        return new Type("Primitive", [new PrimitiveType("Bool", [])]);

      case 1:
        return new Type("Primitive", [new PrimitiveType("Number", [])]);
    }
  } else if (e.Kind.Case === "List") {
    var _ret4 = function () {
      var typs = map$5(function (e_1) {
        return getType$1(ctx, e_1);
      }, e.Kind.Fields[0]);
      var typ_1 = inferListType(typs);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var a = _step.value;
          var elty = getType$1(ctx, a);

          if (!typesEqual(typ_1, elty)) {
            (function (err_4) {
              addError(ctx, a, err_4);
            })(function (rng_4) {
              return TypeChecker.listElementTypeDoesNotMatch(typ_1, elty, rng_4);
            });
          }
        };

        for (var _iterator = _getIterator(e.Kind.Fields[0]), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return {
        v: new Type("List", [typ_1])
      };
    }();

    if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
  } else if (e.Kind.Case === "Binding") {
    if (e.Kind.Fields[1].Kind.Case === "CallSite") {
      var matchValue_2 = resolveParameterType(getType$1(ctx, e.Kind.Fields[1].Kind.Fields[0]), e.Kind.Fields[1].Kind.Fields[1]);
      var $var126 = matchValue_2.Case === "Method" ? matchValue_2.Fields[0].tail != null ? matchValue_2.Fields[0].tail.tail == null ? [0, matchValue_2.Fields[0].head[2]] : [1] : [1] : [1];

      switch ($var126[0]) {
        case 0:
          return $var126[1];

        case 1:
          throw new Error("typeCheckEntity: Expected parameter of function type");
      }
    } else {
      return fsFormat("typeCheckEntity: Variable binding %s is missing call site!")(function (x) {
        throw new Error(x);
      })(e.Kind.Fields[0].Name);
    }
  } else if (e.Kind.Case === "Function") {
    var _ret6 = function () {
      var resTyp = getType$1(ctx, e.Kind.Fields[1]);
      return {
        v: new Type("Method", [ofArray$1([["", false, getType$1(ctx, e.Kind.Fields[0])]]), function (_arg1) {
          return resTyp;
        }])
      };
    }();

    if ((typeof _ret6 === "undefined" ? "undefined" : _typeof(_ret6)) === "object") return _ret6.v;
  } else if (e.Kind.Case === "Constant") {
    if (e.Kind.Fields[0].Case === "String") {
      return new Type("Primitive", [new PrimitiveType("String", [])]);
    } else if (e.Kind.Fields[0].Case === "Boolean") {
      return new Type("Primitive", [new PrimitiveType("Bool", [])]);
    } else if (e.Kind.Fields[0].Case === "Empty") {
      return new Type("Any", []);
    } else {
      return new Type("Primitive", [new PrimitiveType("Number", [])]);
    }
  } else if (e.Kind.Case === "Root") {
    return new Type("Any", []);
  } else if (e.Kind.Case === "LetCommand") {
    return new Type("Any", []);
  } else if (e.Kind.Case === "RunCommand") {
    return new Type("Any", []);
  } else if (e.Kind.Case === "ArgumentList") {
    return new Type("Any", []);
  } else if (e.Kind.Case === "NamedParam") {
    return new Type("Any", []);
  } else if (e.Kind.Case === "CallSite") {
    return new Type("Any", []);
  } else if (e.Kind.Case === "Program") {
    return new Type("Any", []);
  } else if (e.Kind.Case === "MemberName") {
    return new Type("Any", []);
  } else if (!ctx.Globals.has(e.Kind.Fields[0].Name)) {
    (function (err_5) {
      addError(ctx, e, err_5);
    })(function (rng_5) {
      return TypeChecker.variableNotInScope(e.Kind.Fields[0].Name, rng_5);
    });

    return new Type("Any", []);
  } else {
    return getType$1(ctx, ctx.Globals.get(e.Kind.Fields[0].Name));
  }
}
function evaluateDelayedType(topLevel, t) {
  return function (builder_) {
    return builder_.Delay(function () {
      return t.Case === "Delayed" ? builder_.Bind(Async_AwaitFuture_Static(t.Fields[0]), function (_arg1) {
        return builder_.ReturnFrom(evaluateDelayedType(topLevel, _arg1));
      }) : builder_.Return(t);
    });
  }(singleton$2);
}
function typeCheckEntityAsync(ctx, e) {
  return function (builder_) {
    return builder_.Delay(function () {
      var visited = new _Map();

      var loop = function loop(e_1) {
        return function (builder__1) {
          return builder__1.Delay(function () {
            var isGlobal = e_1.Kind.Case === "GlobalValue" ? true : false;

            if (!visited.has(e_1.Symbol) ? isGlobal ? true : function () {
              return e_1.Type == null;
            }(null) : false) {
              visited.set(e_1.Symbol, true);
              return builder__1.Combine(builder__1.For(Entity_get_Antecedents.bind(e_1)(), function (_arg1) {
                return builder__1.Bind(loop(_arg1), function () {
                  return builder__1.Return(null);
                });
              }), builder__1.Delay(function () {
                Log.trace("typechecker", "Type of entity '%s' (%s) is: %s", Entity_get_Name.bind(e_1)(), formatEntityKind(e_1.Kind), formatType(getType$1(ctx, e_1)));
                return builder__1.Bind(evaluateDelayedType(true, getType$1(ctx, e_1)), function (_arg3) {
                  Log.trace("typechecker", "Type of entity '%s' (%s) reduced to: %s", Entity_get_Name.bind(e_1)(), formatEntityKind(e_1.Kind), formatType(_arg3));
                  e_1.Type = _arg3;
                  return builder__1.Zero();
                });
              }));
            } else {
              return builder__1.Zero();
            }
          });
        }(singleton$2);
      };

      return builder_.Bind(loop(e), function () {
        return builder_.Return(getType$1(ctx, e));
      });
    });
  }(singleton$2);
}
function collectTypeErrors(entity) {
  var errors = [];
  var visited = new _Map();

  var loop = function loop(e) {
    if (!visited.has(e.Symbol)) {
      visited.set(e.Symbol, true);
      var inputSequence = Entity_get_Antecedents.bind(e)();
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _getIterator(inputSequence), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var e_1 = _step2.value;
          loop(e_1);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      addRangeInPlace(e.Errors, errors);
    }
  };

  loop(entity);
  return _Array$from(errors);
}
function typeCheckProgram(globals, bound, prog) {
  return function (builder_) {
    return builder_.Delay(function () {
      Log.trace("typechecker", "Type checking program");
      return builder_.TryWith(builder_.Delay(function () {
        var rangeLookup = new _Map(toList(delay(function () {
          return collect(function (matchValue) {
            return singleton([matchValue[1].Symbol, matchValue[0]]);
          }, bound.Entities);
        })));
        var vars = new _Map(toList(delay(function () {
          return map$3(function (e) {
            return [Entity_get_Name.bind(e)(), e];
          }, globals);
        })));
        var ctx = new CheckingContext([], vars, rangeLookup);
        return builder_.Bind(typeCheckEntityAsync(ctx, prog), function (_arg1) {
          Log.trace("typechecker", "Completed type checking");
          return builder_.Zero();
        });
      }), function (_arg2) {
        Log.exn("typechecker", "Type checking program failed: %O", _arg2);
        return builder_.Zero();
      });
    });
  }(singleton$2);
}

var LineColumnRange = function () {
  function LineColumnRange(startLineNumber, startColumn, endLineNumber, endColumn) {
    _classCallCheck(this, LineColumnRange);

    this.StartLineNumber = startLineNumber;
    this.StartColumn = startColumn;
    this.EndLineNumber = endLineNumber;
    this.EndColumn = endColumn;
  }

  _createClass(LineColumnRange, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.LineColumnRange",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          StartLineNumber: "number",
          StartColumn: "number",
          EndLineNumber: "number",
          EndColumn: "number"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return LineColumnRange;
}();
setType("TheGamma.LineColumnRange", LineColumnRange);
var LocationMapper = function () {
  _createClass(LocationMapper, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.LocationMapper",
        properties: {}
      };
    }
  }]);

  function LocationMapper(code) {
    _classCallCheck(this, LocationMapper);

    this.lengths = _Array$from(map$3(function (s) {
      return s.length;
    }, split$$1(code, "\n")));
  }

  _createClass(LocationMapper, [{
    key: "AbsoluteToLineCol",
    value: function (offs) {
      var line = 0;
      var col = 0;
      var offs_1 = offs;

      while (line <= this.lengths.length ? offs_1 > this.lengths[line] : false) {
        offs_1 = offs_1 - this.lengths[line] - 1;
        line = line + 1;
      }

      return [line + 1, offs_1 + 1];
    }
  }, {
    key: "LineColToAbsolute",
    value: function (line, col) {
      var offs = 0;

      for (var l = 1; l <= line - 1; l++) {
        offs = offs + this.lengths[l - 1] + 1;
      }

      return offs + col - 1;
    }
  }]);

  return LocationMapper;
}();
setType("TheGamma.LocationMapper", LocationMapper);

var LiveEditorZone = function () {
  function LiveEditorZone(line, preview) {
    _classCallCheck(this, LiveEditorZone);

    this.Line = line;
    this.Preview = preview;
  }

  _createClass(LiveEditorZone, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Common.LiveEditorZone",
        interfaces: ["FSharpRecord"],
        properties: {
          Line: "number",
          Preview: DomNode
        }
      };
    }
  }]);

  return LiveEditorZone;
}();
setType("TheGamma.Live.Common.LiveEditorZone", LiveEditorZone);
var LivePreview = function () {
  function LivePreview(update, render$$1, initialState) {
    _classCallCheck(this, LivePreview);

    this.Update = update;
    this.Render = render$$1;
    this.InitialState = initialState;
  }

  _createClass(LivePreview, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Common.LivePreview",
        interfaces: ["FSharpRecord"],
        properties: {
          Update: "function",
          Render: "function",
          InitialState: GenericParam("TState")
        }
      };
    }
  }]);

  return LivePreview;
}();
setType("TheGamma.Live.Common.LivePreview", LivePreview);
var LiveState = function () {
  function LiveState(globals, code, program, mapper, location, selection, state, currentPreview) {
    _classCallCheck(this, LiveState);

    this.Globals = globals;
    this.Code = code;
    this.Program = program;
    this.Mapper = mapper;
    this.Location = location;
    this.Selection = selection;
    this.State = state;
    this.CurrentPreview = currentPreview;
  }

  _createClass(LiveState, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Common.LiveState",
        interfaces: ["FSharpRecord"],
        properties: {
          Globals: Interface("System.Collections.Generic.IEnumerable"),
          Code: "string",
          Program: Program$$1,
          Mapper: LocationMapper,
          Location: "number",
          Selection: Option(LineColumnRange),
          State: GenericParam("T"),
          CurrentPreview: Option(makeGeneric(LivePreview, {
            TState: Interface("TheGamma.Live.Common.CustomLiveState"),
            TEvent: Interface("TheGamma.Live.Common.CustomLiveEvent")
          }))
        }
      };
    }
  }]);

  return LiveState;
}();
setType("TheGamma.Live.Common.LiveState", LiveState);
var LiveEvent = function () {
  function LiveEvent(caseName, fields) {
    _classCallCheck(this, LiveEvent);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(LiveEvent, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Common.LiveEvent",
        interfaces: ["FSharpUnion"],
        cases: {
          CustomEvent: [GenericParam("T")],
          InitializeGlobals: [Interface("System.Collections.Generic.IEnumerable")],
          UpdateLocation: ["number"],
          UpdateSource: ["string", "number", Program$$1, LocationMapper]
        }
      };
    }
  }]);

  return LiveEvent;
}();
setType("TheGamma.Live.Common.LiveEvent", LiveEvent);
function updateLiveState(state, event) {
  if (event.Case === "UpdateLocation") {
    return new LiveState(state.Globals, state.Code, state.Program, state.Mapper, event.Fields[0], state.Selection, state.State, state.CurrentPreview);
  } else if (event.Case === "UpdateSource") {
    return new LiveState(state.Globals, event.Fields[0], event.Fields[2], event.Fields[3], event.Fields[1], state.Selection, state.State, state.CurrentPreview);
  } else if (event.Case === "CustomEvent") {
    return state;
  } else {
    return new LiveState(event.Fields[0], state.Code, state.Program, state.Mapper, state.Location, state.Selection, state.State, state.CurrentPreview);
  }
}

var CheckingMessage = function () {
  function CheckingMessage(caseName, fields) {
    _classCallCheck(this, CheckingMessage);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(CheckingMessage, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Services.CheckingMessage",
        interfaces: ["FSharpUnion", "System.IEquatable"],
        cases: {
          IsWellTyped: ["string", Any],
          TypeCheck: ["string", Any]
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }]);

  return CheckingMessage;
}();
setType("TheGamma.Services.CheckingMessage", CheckingMessage);
var Position$1 = function () {
  function Position(line, column) {
    _classCallCheck(this, Position);

    this.Line = line;
    this.Column = column;
  }

  _createClass(Position, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Services.Position",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Line: "number",
          Column: "number"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return Position;
}();
setType("TheGamma.Services.Position", Position$1);
var LineRange = function () {
  function LineRange(start$$1, end) {
    _classCallCheck(this, LineRange);

    this.Start = start$$1;
    this.End = end;
  }

  _createClass(LineRange, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Services.LineRange",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          Start: Position$1,
          End: Position$1
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return LineRange;
}();
setType("TheGamma.Services.LineRange", LineRange);
function offsetToLocation(lines, offs, lengths) {
  offsetToLocation: while (true) {
    var $var199 = lengths.tail != null ? offs <= lengths.head ? [0, lengths.head, lengths.tail] : [1] : [1];

    switch ($var199[0]) {
      case 0:
        return new Position$1(lines, offs);

      case 1:
        if (lengths.tail == null) {
          return new Position$1(lines, offs);
        } else {
          lines = lines + 1;
          offs = offs - lengths.head - 1;
          lengths = lengths.tail;
          continue offsetToLocation;
        }

    }
  }
}
function rangeToLoc(lengths, rng) {
  return new LineRange(offsetToLocation(1, rng.Start, lengths), offsetToLocation(1, rng.Start, lengths));
}
var CheckingService = function () {
  _createClass(CheckingService, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Services.CheckingService",
        properties: {
          ErrorsReported: Interface("Microsoft.FSharp.Control.IEvent")
        }
      };
    }
  }]);

  function CheckingService(article, globals) {
    var _this = this;

    _classCallCheck(this, CheckingService);

    this.globals = globals;
    this.errorsReported = new Event$2();
    var emptyProg = new Program$$1(node(new _Range(0, 0), new List$1()));
    this.bindingContext = Async_StartAsFuture_Static(function (builder_) {
      return builder_.Delay(function () {
        return builder_.Bind(Async_AwaitFuture_Static(_this.globals), function (_arg1) {
          return builder_.Return(createContext(_arg1, article));
        });
      });
    }(singleton$2));
    this.agent = start$1(function (inbox) {
      var loop = function loop(lastCode) {
        return function (lastResult) {
          return function (builder__1) {
            return builder__1.Delay(function () {
              return builder__1.Bind(inbox.receive(), function (_arg6) {
                if (_arg6.Case === "TypeCheck") {
                  if (_arg6.Fields[0] === lastCode) {
                    Log.trace("service", "Returning previous result");

                    _arg6.Fields[1].reply(lastResult);

                    return builder__1.ReturnFrom(loop(lastCode)(lastResult));
                  } else if (_arg6.Case === "TypeCheck") {
                    Log.trace("service", "Type checking source code");
                    return builder__1.Bind(_this.typeCheck(_arg6.Fields[0]), function (_arg8) {
                      if (_arg8 == null) {
                        _arg6.Fields[1].reply([false, new BindingResult([]), emptyProg]);

                        return builder__1.ReturnFrom(loop(lastCode)(lastResult));
                      } else {
                        var prog = _arg8[0];
                        var errors = _arg8[2];
                        var ents = _arg8[1];

                        _this.errorsReported.Trigger([_arg6.Fields[0], errors]);

                        var result = [errors.length === 0, ents, prog];

                        _arg6.Fields[1].reply(result);

                        return builder__1.ReturnFrom(loop(_arg6.Fields[0])(result));
                      }
                    });
                  } else {
                    throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\thegamma\\services.fs", 61, 12);
                  }
                } else {
                  return builder__1.Bind(_this.typeCheck(_arg6.Fields[0]), function (_arg7) {
                    return builder__1.Combine(function () {
                      var $var200 = _arg7 != null ? function () {
                        var errs = _arg7[2];
                        return errs.length === 0;
                      }() ? [0, _arg7[2]] : [1] : [1];

                      switch ($var200[0]) {
                        case 0:
                          _arg6.Fields[1].reply(true);

                          return builder__1.Zero();

                        case 1:
                          _arg6.Fields[1].reply(false);

                          return builder__1.Zero();
                      }
                    }(), builder__1.Delay(function () {
                      return builder__1.ReturnFrom(loop(lastCode)(lastResult));
                    }));
                  });
                }
              });
            });
          }(singleton$2);
        };
      };

      return loop("")([false, new BindingResult([]), emptyProg]);
    });
  }

  _createClass(CheckingService, [{
    key: "TypeCheck",
    value: function (code) {
      return this.agent.postAndAsyncReply(function (ch) {
        return new CheckingMessage("TypeCheck", [code, ch]);
      });
    }
  }, {
    key: "IsWellTyped",
    value: function (code) {
      return this.agent.postAndAsyncReply(function (ch) {
        return new CheckingMessage("IsWellTyped", [code, ch]);
      });
    }
  }, {
    key: "errorsToLineCol",
    value: function (code, errors) {
      var lengths = map$5(function (l) {
        return l.length;
      }, toList(split$$1(code, "\n")));
      return errors.map(function (e) {
        return new _Error(e.Number, e.Message, rangeToLoc(lengths, e.Range));
      });
    }
  }, {
    key: "typeCheck",
    value: function (code) {
      var _this2 = this;

      return function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(Async_AwaitFuture_Static(_this2.globals), function (_arg2) {
            return builder_.TryWith(builder_.Delay(function () {
              var patternInput = parseProgram(code);
              return builder_.Bind(Async_AwaitFuture_Static(_this2.bindingContext), function (_arg3) {
                var patternInput_1 = bindProgram(_arg3, patternInput[0]);
                return builder_.Bind(typeCheckProgram(_arg2, patternInput_1[1], patternInput_1[0]), function () {
                  var typeErrors = collectTypeErrors(patternInput_1[0]);
                  Log.trace("service", "Type checking completed");
                  var errors_1 = void 0;
                  var errors = patternInput[1].concat(typeErrors);
                  errors_1 = _this2.errorsToLineCol(code, errors);
                  return builder_.Return([patternInput[0], patternInput_1[1], errors_1]);
                });
              });
            }), function (_arg5) {
              Log.exn("service", "Type checking failed: %O", _arg5);
              return builder_.Return(null);
            });
          });
        });
      }(singleton$2);
    }
  }, {
    key: "ErrorsReported",
    get: function () {
      return this.errorsReported.Publish;
    }
  }]);

  return CheckingService;
}();
setType("TheGamma.Services.CheckingService", CheckingService);
var PreviewService = function () {
  _createClass(PreviewService, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Services.PreviewService",
        properties: {
          ZoneHeight: "number",
          ZoneSizeChanged: Interface("Microsoft.FSharp.Control.IEvent")
        }
      };
    }
  }]);

  function PreviewService(checker, globals, ed, livePreviews) {
    var _this3 = this;

    _classCallCheck(this, PreviewService);

    this.checker = checker;
    this.globals = globals;
    this.ed = ed;
    this.livePreviews = livePreviews;
    this.zoneSizeChanged = new Event$2();
    this.currentZone = null;
    this.zoneHeight = 0;
    this.tree = {};
    this.container = document.createElement("div");
    this.lastCode = "";
    this.lastMapper = new LocationMapper("");
    this.changingEditor = false;

    var trigger = function (ed_1) {
      return _this3.createLivePreview(ed_1);
    }(this.ed);

    this.ed.onDidChangeCursorPosition(function (ce) {
      if (!_this3.changingEditor) {
        var code = _this3.ed.getModel().getValue(1, false);

        Log.trace("live", "Cursor position changed: code <> lastCode = %s", code !== _this3.lastCode);

        (function (arg00) {
          startImmediate(arg00);
        })(function (builder_) {
          return builder_.Delay(function () {
            return builder_.Bind(_this3.getUpdateEventAfterChange(), function (_arg6) {
              trigger(_arg6);
              return builder_.Zero();
            });
          });
        }(singleton$2));
      }
    });
  }

  _createClass(PreviewService, [{
    key: "removeZone",
    value: function () {
      var _this4 = this;

      var matchValue = this.currentZone;

      if (matchValue == null) {} else {
        (function () {
          var id = matchValue[0];

          _this4.ed.changeViewZones(function (accessor) {
            accessor.removeZone(id);
          });
        })();
      }

      this.currentZone = null;
      this.zoneSizeChanged.Trigger(null);
    }
  }, {
    key: "createAndAddZone",
    value: function (endLine) {
      var _this5 = this;

      var zoneId = -1;
      var zone = {};
      var node$$1 = document.createElement('div');
      node$$1.style.width = "1000px";
      node$$1.style.height = "1000px";
      this.container = document.createElement('div');
      this.tree = {};
      node$$1.appendChild(this.container);
      this.ed.changeViewZones(function (accessor) {
        var matchValue = _this5.currentZone;

        if (matchValue != null) {
          var id = matchValue[0];
          accessor.removeZone(id);
        }

        zone.afterLineNumber = endLine;
        zone.heightInPx = 1;
        zone.domNode = node$$1;
        _this5.zoneHeight = 1;
        zoneId = accessor.addZone(zone);
        _this5.currentZone = [zoneId, zone];
      });
    }
  }, {
    key: "updateZones",
    value: function (trigger, liveState) {
      var _this6 = this;

      var dom = defaultArg(liveState.CurrentPreview, null, function (p) {
        return p.Render(trigger)(liveState);
      });

      if (dom != null) {
        (function () {
          if (function () {
            return _this6.currentZone == null;
          }(null)) {
            var endLine = dom.Line;

            _this6.createAndAddZone(endLine);
          }

          var patternInput = _this6.currentZone;
          var newTree = renderVirtual(dom.Preview);
          var patches = diff(_this6.tree, newTree);
          _this6.container = patch(_this6.container, patches);
          _this6.tree = newTree;

          var waitForActualHeight = function waitForActualHeight(n) {
            return function (builder_) {
              return builder_.Delay(function () {
                var newHeight = _this6.container.clientHeight;

                if (n === 10 ? true : newHeight !== 0) {
                  return builder_.Return(newHeight);
                } else {
                  return builder_.Bind(sleep(n * n), function () {
                    return builder_.ReturnFrom(waitForActualHeight(n + 1));
                  });
                }
              });
            }(singleton$2);
          };

          (function (arg00) {
            startImmediate(arg00);
          })(function (builder__1) {
            return builder__1.Delay(function () {
              return builder__1.Bind(waitForActualHeight(1), function (_arg2) {
                Log.trace("live", "Old height: %s, New height: %s", _this6.zoneHeight, _arg2);

                if (_this6.zoneHeight !== _arg2 ? true : patternInput[1].afterLineNumber !== dom.Line) {
                  patternInput[1].afterLineNumber = dom.Line;
                  patternInput[1].heightInPx = _arg2;
                  _this6.zoneHeight = _arg2;

                  _this6.ed.changeViewZones(function (accessor) {
                    accessor.layoutZone(patternInput[0]);
                  });

                  _this6.zoneSizeChanged.Trigger(null);

                  return builder__1.Zero();
                } else {
                  return builder__1.Zero();
                }
              });
            });
          }(singleton$2));
        })();
      } else {
        this.removeZone();
      }
    }
  }, {
    key: "getUpdateEventAfterChange",
    value: function () {
      var _this7 = this;

      return function (builder_) {
        return builder_.Delay(function () {
          var code = _this7.ed.getModel().getValue(1, false);

          var position = _this7.ed.getPosition();

          if (code !== _this7.lastCode) {
            var _ret3 = function () {
              _this7.lastCode = code;
              _this7.lastMapper = new LocationMapper(code);

              var loc = _this7.lastMapper.LineColToAbsolute(~~position.lineNumber, ~~position.column);

              return {
                v: builder_.Bind(_this7.checker.TypeCheck(code), function (_arg3) {
                  return builder_.Return(new LiveEvent("UpdateSource", [code, loc, _arg3[2], _this7.lastMapper]));
                })
              };
            }();

            if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
          } else {
            var loc_1 = _this7.lastMapper.LineColToAbsolute(~~position.lineNumber, ~~position.column);

            return builder_.Return(new LiveEvent("UpdateLocation", [loc_1]));
          }
        });
      }(singleton$2);
    }
  }, {
    key: "createLivePreview",
    value: function (ed) {
      var _this8 = this;

      var liveEvent = new Event$2();
      var noState = void 0;
      var $var201 = this;
      noState = _defineProperty({}, _Symbol.reflection, function () {
        return {
          interfaces: ["TheGamma.Live.Common.CustomLiveState"]
        };
      });
      var liveState = void 0;
      var Mapper = new LocationMapper("");
      var Location = 0;
      var Program$$2 = new Program$$1(node(new _Range(0, 0), new List$1()));
      liveState = new LiveState(new List$1(), "", Program$$2, Mapper, Location, null, noState, null);

      var applyEvent = function applyEvent(evt) {
        var liveState_1 = updateLiveState(liveState, evt);
        var newState = liveState_1.CurrentPreview == null ? null : liveState_1.CurrentPreview.Update(function (arg00) {
          liveEvent.Trigger(arg00);
        })(liveState_1)(evt);
        var matchValue = [newState, evt];
        var $var202 = matchValue[0] != null ? [0] : matchValue[1].Case === "UpdateSource" ? [1] : matchValue[1].Case === "UpdateLocation" ? [1] : [2];

        switch ($var202[0]) {
          case 0:
            var newState_1 = matchValue[0];
            return newState_1;

          case 1:
            Log.trace("live", "Searching for available previews");
            var state_1 = tryPick(function (lp) {
              var state = void 0;
              var CurrentPreview = lp;
              state = new LiveState(liveState_1.Globals, liveState_1.Code, liveState_1.Program, liveState_1.Mapper, liveState_1.Location, liveState_1.Selection, lp.InitialState, CurrentPreview);
              return lp.Update(function (arg00_1) {
                liveEvent.Trigger(arg00_1);
              })(state)(evt);
            }, _this8.livePreviews);

            if (state_1 != null) {
              return state_1;
            } else {
              var CurrentPreview_1 = null;
              return new LiveState(liveState_1.Globals, liveState_1.Code, liveState_1.Program, liveState_1.Mapper, liveState_1.Location, liveState_1.Selection, noState, CurrentPreview_1);
            }

          case 2:
            var CurrentPreview_2 = null;
            return new LiveState(liveState_1.Globals, liveState_1.Code, liveState_1.Program, liveState_1.Mapper, liveState_1.Location, liveState_1.Selection, noState, CurrentPreview_2);
        }
      };

      add$5(function (evt_1) {
        try {
          Log.trace("live", "Updating state %O with event %O", liveState, evt_1);
          var oldState = liveState;
          liveState = applyEvent(evt_1);

          if ((evt_1.Case === "UpdateSource" ? false : true) ? oldState.Code !== liveState.Code : false) {
            _this8.changingEditor = true;
            ed.getModel().setValue(liveState.Code);
          }

          var matchValue_1 = liveState.Selection;

          if (matchValue_1 != null) {
            _this8.changingEditor = true;
            var mrng = {};
            mrng.startColumn = matchValue_1.StartColumn;
            mrng.startLineNumber = matchValue_1.StartLineNumber;
            mrng.endColumn = matchValue_1.EndColumn;
            mrng.endLineNumber = matchValue_1.EndLineNumber;
            ed.setSelection(mrng);
            var Selection = null;
            liveState = new LiveState(liveState.Globals, liveState.Code, liveState.Program, liveState.Mapper, liveState.Location, Selection, liveState.State, liveState.CurrentPreview);
          }

          if (_this8.changingEditor === true) {
            _this8.changingEditor = false;

            (function (arg00_2) {
              startImmediate(arg00_2);
            })(function (builder_) {
              return builder_.Delay(function () {
                Log.trace("live", "Editor changed. Getting after change event...");
                return builder_.Bind(_this8.getUpdateEventAfterChange(), function (_arg4) {
                  Log.trace("live", "Editor changed. Updating state %O with event %O", liveState, _arg4);
                  liveState = applyEvent(_arg4);
                  Log.trace("live", "Editor changed. New state %O", liveState);

                  var trigger = function trigger(arg00_3) {
                    liveEvent.Trigger(arg00_3);
                  };

                  _this8.updateZones(trigger, liveState);

                  return builder_.Zero();
                });
              });
            }(singleton$2));
          } else {
            var trigger_1 = function trigger_1(arg00_4) {
              liveEvent.Trigger(arg00_4);
            };

            _this8.updateZones(trigger_1, liveState);
          }
        } catch (e) {
          Log.exn("live", "Error when updating state %O with event %O: %O", liveState, evt_1, e);
        }
      }, liveEvent.Publish);

      (function (arg00_5) {
        startImmediate(arg00_5);
      })(function (builder__1) {
        return builder__1.Delay(function () {
          return builder__1.Bind(Async_AwaitFuture_Static(_this8.globals), function (_arg5) {
            liveEvent.Trigger(new LiveEvent("InitializeGlobals", [_arg5]));
            return builder__1.Zero();
          });
        });
      }(singleton$2));

      return function (arg00_6) {
        liveEvent.Trigger(arg00_6);
      };
    }
  }, {
    key: "ZoneSizeChanged",
    get: function () {
      return this.zoneSizeChanged.Publish;
    }
  }, {
    key: "ZoneHeight",
    get: function () {
      if (!equals(this.currentZone, null)) {
        return this.zoneHeight;
      } else {
        return 0;
      }
    }
  }]);

  return PreviewService;
}();
setType("TheGamma.Services.PreviewService", PreviewService);

var CompilationContext = function () {
  function CompilationContext(lineLengths, globals) {
    _classCallCheck(this, CompilationContext);

    this.LineLengths = lineLengths;
    this.Globals = globals;
  }

  _createClass(CompilationContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.CodeGenerator.CompilationContext",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          LineLengths: makeGeneric(List$1, {
            T: "number"
          }),
          Globals: makeGeneric(FableMap, {
            Key: "string",
            Value: Expression
          })
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return CompilationContext;
}();
setType("TheGamma.CodeGenerator.CompilationContext", CompilationContext);
function offsetToLocation$1(lines, offs, lengths) {
  offsetToLocation$1: while (true) {
    var $var121 = lengths.tail != null ? offs <= lengths.head ? [0, lengths.head, lengths.tail] : [1] : [1];

    switch ($var121[0]) {
      case 0:
        return new Position(lines, offs);

      case 1:
        if (lengths.tail == null) {
          throw new Error("offsetToLocation: Out of range");
        } else {
          lines = lines + 1;
          offs = offs - lengths.head - 1;
          lengths = lengths.tail;
          continue offsetToLocation$1;
        }

    }
  }
}
function rangeToLoc$1(ctx, rng) {
  return new SourceLocation(offsetToLocation$1(1, rng.Start, ctx.LineLengths), offsetToLocation$1(1, rng.Start, ctx.LineLengths));
}
function getMember(name, typ) {
  if (typ.Case === "Object") {
    var matchValue = tryPick(function (m) {
      return m.Name === name ? m : null;
    }, typ.Fields[0].Members);

    if (matchValue != null) {
      return matchValue;
    } else {
      Log.exn("codegen", "getMember: Member %s not found in object %O", name, typ.Fields[0]);
      throw new Error("getMember: Member not found");
    }
  } else {
    Log.exn("codegen", "getMember: Not an object %O", typ);
    throw new Error("getMember: Not an object");
  }
}
function compileExpression(ctx, expr) {
  var _loop = function _loop() {
    Log.trace("codegen", "Compiling expression: %O", expr);
    var $var122 = expr.Node.Case === "Binary" ? expr.Node.Fields[1].Node.Case === "Power" ? [0, expr.Node.Fields[0], expr.Node.Fields[2]] : [1, expr.Node.Fields[0], expr.Node.Fields[1], expr.Node.Fields[2]] : expr.Node.Case === "Member" ? expr.Node.Fields[1].Node.Case === "Placeholder" ? expr.Node.Fields[1].Node.Fields[1].Node.Case === "Variable" ? [2, expr.Node.Fields[0], expr.Node.Fields[1].Node.Fields[1].Node.Fields[0]] : [3, expr.Node.Fields[0]] : expr.Node.Fields[1].Node.Case === "Variable" ? [2, expr.Node.Fields[0], expr.Node.Fields[1].Node.Fields[0]] : [3, expr.Node.Fields[0]] : expr.Node.Case === "Call" ? [4, expr.Node.Fields[1], expr.Node.Fields[0]] : expr.Node.Case === "Variable" ? ctx.Globals.has(expr.Node.Fields[0].Node.Name) ? [5, expr.Node.Fields[0]] : [6] : [6];

    var _ret2 = function () {
      switch ($var122[0]) {
        case 0:
          var l = compileExpression(ctx, $var122[1]);
          var r = compileExpression(ctx, $var122[2]);
          var rng = rangeToLoc$1(ctx, expr.Range);
          var pow = BabelOperators.op_Dynamic(BabelOperators.ident("Math"), "pow");
          return {
            v: {
              v: new Expression("CallExpression", [pow, ofArray$1([l, r]), rangeToLoc$1(ctx, expr.Range)])
            }
          };

        case 1:
          var l_1 = compileExpression(ctx, $var122[1]);
          var r_1 = compileExpression(ctx, $var122[3]);
          var op = void 0;

          if ($var122[2].Node.Case === "Equals") {
            op = new BinaryOperator("BinaryEqualStrict", []);
          } else if ($var122[2].Node.Case === "Plus") {
            op = new BinaryOperator("BinaryPlus", []);
          } else if ($var122[2].Node.Case === "Minus") {
            op = new BinaryOperator("BinaryMinus", []);
          } else if ($var122[2].Node.Case === "Multiply") {
            op = new BinaryOperator("BinaryMultiply", []);
          } else if ($var122[2].Node.Case === "Divide") {
            op = new BinaryOperator("BinaryDivide", []);
          } else if ($var122[2].Node.Case === "GreaterThan") {
            op = new BinaryOperator("BinaryGreater", []);
          } else if ($var122[2].Node.Case === "LessThan") {
            op = new BinaryOperator("BinaryLess", []);
          } else if ($var122[2].Node.Case === "GreaterThanOrEqual") {
            op = new BinaryOperator("BinaryGreaterOrEqual", []);
          } else if ($var122[2].Node.Case === "LessThanOrEqual") {
            op = new BinaryOperator("BinaryLessOrEqual", []);
          } else if ($var122[2].Node.Case === "Power") {
            throw new Error("compileExpression: Power is not a binary operator");
          } else {
            op = new BinaryOperator("BinaryModulus", []);
          }

          return {
            v: {
              v: new Expression("BinaryExpression", [op, l_1, r_1, rangeToLoc$1(ctx, expr.Range)])
            }
          };

        case 2:
          var mem = getMember($var122[2].Node.Name, $var122[1].Entity.Type);
          var inst = compileExpression(ctx, $var122[1]);
          return {
            v: {
              v: mem.Emitter.Emit(inst)
            }
          };

        case 3:
          throw new Error("compileExpression: Member in member access is not a variable");

        case 4:
          var compiledArgs = map$5(function (a) {
            return [a.Name, compileExpression(ctx, a.Value)];
          }, $var122[1].Node);

          var positionArgs = _Array$from(map$3(function (tuple) {
            return tuple[1];
          }, takeWhile(function (tupledArg) {
            return function () {
              return tupledArg[0] == null;
            }(null);
          }, compiledArgs)));

          var namedArgs = new _Map(choose(function (_arg1) {
            if (_arg1[0] != null) {
              var n = _arg1[0];
              return [n.Node.Name, _arg1[1]];
            } else {
              return null;
            }
          }, compiledArgs));
          var expectedArgs = void 0;
          var matchValue = $var122[2].Entity.Type;

          if (matchValue.Case === "Method") {
            expectedArgs = matchValue.Fields[0];
          } else {
            expectedArgs = new List$1();
          }

          var inst_1 = compileExpression(ctx, $var122[2]);
          var pars = mapIndexed$1(function (i, tupledArg_1) {
            return i < positionArgs.length ? positionArgs[i] : namedArgs.has(tupledArg_1[0]) ? namedArgs.get(tupledArg_1[0]) : new Expression("NullLiteral", [rangeToLoc$1(ctx, $var122[1].Range)]);
          }, expectedArgs);
          return {
            v: {
              v: new Expression("CallExpression", [inst_1, pars, rangeToLoc$1(ctx, expr.Range)])
            }
          };

        case 5:
          return {
            v: {
              v: ctx.Globals.get($var122[1].Node.Name)
            }
          };

        case 6:
          if (expr.Node.Case === "Variable") {
            return {
              v: {
                v: new Expression("IdentifierExpression", [expr.Node.Fields[0].Node.Name, rangeToLoc$1(ctx, expr.Node.Fields[0].Range)])
              }
            };
          } else if (expr.Node.Case === "Number") {
            return {
              v: {
                v: new Expression("NumericLiteral", [expr.Node.Fields[0], rangeToLoc$1(ctx, expr.Range)])
              }
            };
          } else if (expr.Node.Case === "String") {
            return {
              v: {
                v: new Expression("StringLiteral", [expr.Node.Fields[0], rangeToLoc$1(ctx, expr.Range)])
              }
            };
          } else if (expr.Node.Case === "Boolean") {
            return {
              v: {
                v: new Expression("BooleanLiteral", [expr.Node.Fields[0], rangeToLoc$1(ctx, expr.Range)])
              }
            };
          } else if (expr.Node.Case === "Placeholder") {
            ctx = ctx;
            expr = expr.Node.Fields[1];
            return {
              v: "continue|compileExpression"
            };
          } else if (expr.Node.Case === "List") {
            var es = map$5(function (expr_1) {
              return compileExpression(ctx, expr_1);
            }, expr.Node.Fields[0]);
            return {
              v: {
                v: new Expression("ArrayExpression", [es, rangeToLoc$1(ctx, expr.Range)])
              }
            };
          } else if (expr.Node.Case === "Function") {
            var _ret3 = function () {
              var _var = new Expression("IdentifierExpression", [expr.Node.Fields[0].Node.Name, rangeToLoc$1(ctx, expr.Node.Fields[0].Range)]);

              var ce = compileExpression(function () {
                var Globals = add$3(expr.Node.Fields[0].Node.Name, _var, ctx.Globals);
                return new CompilationContext(ctx.LineLengths, Globals);
              }(), expr.Node.Fields[1]);
              var body = new Statement("BlockStatement", [ofArray$1([new Statement("ReturnStatement", [ce, rangeToLoc$1(ctx, expr.Node.Fields[1].Range)])]), rangeToLoc$1(ctx, expr.Node.Fields[1].Range)]);
              return {
                v: {
                  v: {
                    v: new Expression("FunctionExpression", [null, ofArray$1([new Pattern("IdentifierPattern", [expr.Node.Fields[0].Node.Name, rangeToLoc$1(ctx, expr.Node.Fields[0].Range)])]), body, false, false, rangeToLoc$1(ctx, expr.Range)])
                  }
                }
              };
            }();

            if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
          } else if (expr.Node.Case === "Empty") {
            Log.error("codegen", "getEmitterAndParams: Empty expression in the AST");
            return {
              v: {
                v: new Expression("NullLiteral", [rangeToLoc$1(ctx, expr.Range)])
              }
            };
          } else {
            throw new Error("C:\\Tomas\\Public\\thegamma\\thegamma-script\\src\\thegamma\\codegen/codegen.fs", 43, 8);
          }

      }
    }();

    if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
  };

  compileExpression: while (true) {
    var _ret = _loop();

    switch (_ret) {
      case "continue|compileExpression":
        continue compileExpression;

      default:
        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
    }
  }
}
function compileCommand(ctx, idx, cmd) {
  var loc = rangeToLoc$1(ctx, cmd.Range);
  var patternInput = void 0;

  if (cmd.Node.Case === "Expr") {
    patternInput = [new List$1(), BabelOperators.num(idx), compileExpression(ctx, cmd.Node.Fields[0])];
  } else {
    var e = compileExpression(ctx, cmd.Node.Fields[1]);
    var name = new Pattern("IdentifierPattern", [cmd.Node.Fields[0].Node.Name, rangeToLoc$1(ctx, cmd.Node.Fields[0].Range)]);
    var decl = new VariableDeclarator("VariableDeclarator", [name, e, loc]);
    patternInput = [ofArray$1([new Statement("VariableDeclaration", [new VariableDeclarationKind("Var", []), ofArray$1([decl]), rangeToLoc$1(ctx, cmd.Range)])]), BabelOperators.str(cmd.Node.Fields[0].Node.Name), BabelOperators.ident(cmd.Node.Fields[0].Node.Name)];
  }

  var res = new Expression("MemberExpression", [BabelOperators.ident("_results"), patternInput[1], true, loc]);
  return append$1(patternInput[0], ofArray$1([new Statement("ExpressionStatement", [new Expression("AssignmentExpression", [new AssignmentOperator("AssignEqual", []), res, patternInput[2], loc]), loc])]));
}
function compileProgram(ctx, prog) {
  var decl = new VariableDeclarator("VariableDeclarator", [new Pattern("IdentifierPattern", ["_results", null]), new Expression("ArrayExpression", [new List$1(), null]), null]);
  var res = new Statement("VariableDeclaration", [new VariableDeclarationKind("Var", []), ofArray$1([decl]), null]);
  var body = concat$1(mapIndexed$1(function (idx, cmd) {
    return compileCommand(ctx, idx, cmd);
  }, prog.Body.Node));
  var ret = new Statement("ReturnStatement", [BabelOperators.ident("_results"), null]);
  var body_1 = new Statement("BlockStatement", [append$1(new List$1(res, body), ofArray$1([ret])), null]);
  var body_2 = new Expression("CallExpression", [new Expression("FunctionExpression", [null, new List$1(), body_1, false, false, null]), new List$1(), null]);
  return new Program$1(rangeToLoc$1(ctx, prog.Body.Range), ofArray$1([new Statement("ExpressionStatement", [body_2, null])]));
}
function compile(globals, text, prog) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.TryWith(builder_.Delay(function () {
        return builder_.Bind(Async_AwaitFuture_Static(globals), function (_arg1) {
          var globals_1 = create$6(choose$1(function (_arg2) {
            var $var123 = _arg2.Kind.Case === "GlobalValue" ? _arg2.Kind.Fields[1] != null ? [0, _arg2.Kind.Fields[1], _arg2.Kind.Fields[0]] : [1] : [1];

            switch ($var123[0]) {
              case 0:
                return [$var123[2].Name, $var123[1]];

              case 1:
                return null;
            }
          }, _arg1), new GenericComparer(compare));
          var ctx = new CompilationContext(toList(delay(function () {
            return map$3(function (l) {
              return l.length;
            }, split$$1(text, "\n"));
          })), globals_1);
          var res = compileProgram(ctx, prog);
          var code = Babel.transformFromAst(Serializer.serializeProgram(res), text, new BabelOptions(["es2015"]));
          Log.trace("codegen", "Evaluating: %O", code);
          return builder_.Return(code.code);
        });
      }), function (_arg3) {
        Log.exn("codegen", "Evaluating code failed: %O", _arg3);
        return builder_.Return("");
      });
    });
  }(singleton$2);
}

function pickMetaByType(ctx, typ, metas) {
  return tryPick(function (m) {
    return (m.Context === ctx ? m.Type === typ : false) ? m.Data : null;
  }, metas);
}
function pickPivotFields(expr) {
  var matchValue = expr.Entity;
  var $var164 = matchValue != null ? matchValue.Kind.Case === "Member" ? [0, matchValue.Meta] : matchValue.Kind.Case === "GlobalValue" ? [0, matchValue.Meta] : matchValue.Kind.Case === "Variable" ? [0, matchValue.Kind.Fields[1].Meta] : [1] : [1];

  switch ($var164[0]) {
    case 0:
      var matchValue_1 = pickMetaByType("http://schema.thegamma.net/pivot", "Fields", $var164[1]);

      if (matchValue_1 != null) {
        return matchValue_1;
      } else {
        return null;
      }

    case 1:
      return null;
  }
}
function pickPivotTransformations(expr) {
  var $var165 = expr.Node.Case === "Call" ? expr.Node.Fields[0].Entity != null ? expr.Node.Fields[0].Entity.Kind.Case === "Member" ? [0, expr.Node.Fields[0].Entity.Meta] : expr.Entity != null ? expr.Entity.Kind.Case === "Member" ? [0, expr.Entity.Meta] : expr.Entity.Kind.Case === "GlobalValue" ? [1, expr.Entity.Meta] : [2] : [2] : expr.Entity != null ? expr.Entity.Kind.Case === "Member" ? [0, expr.Entity.Meta] : expr.Entity.Kind.Case === "GlobalValue" ? [1, expr.Entity.Meta] : [2] : [2] : expr.Entity != null ? expr.Entity.Kind.Case === "Member" ? [0, expr.Entity.Meta] : expr.Entity.Kind.Case === "GlobalValue" ? [1, expr.Entity.Meta] : [2] : [2];

  switch ($var165[0]) {
    case 0:
      var matchValue = pickMetaByType("http://schema.thegamma.net/pivot", "Transformations", $var165[1]);

      if (matchValue != null) {
        return matchValue;
      } else {
        return null;
      }

    case 1:
      return new List$1();

    case 2:
      return null;
  }
}
function commandAtLocation(loc, program) {
  return tryFind(function (cmd) {
    return cmd.Range.Start <= loc ? cmd.Range.End + 1 >= loc : false;
  }, program.Body.Node);
}
var NestedChain = function () {
  function NestedChain(chain) {
    _classCallCheck(this, NestedChain);

    this.Chain = chain;
  }

  _createClass(NestedChain, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Pivot.NestedChain",
        interfaces: ["FSharpRecord"],
        properties: {
          Chain: makeGeneric(List$1, {
            T: Tuple(["number", makeGeneric(_Node, {
              T: Expr
            })])
          })
        }
      };
    }
  }]);

  return NestedChain;
}();
setType("TheGamma.Live.Pivot.NestedChain", NestedChain);
var PivotSection = function () {
  function PivotSection(transformation, nodes) {
    _classCallCheck(this, PivotSection);

    this.Transformation = transformation;
    this.Nodes = nodes;
  }

  _createClass(PivotSection, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Pivot.PivotSection",
        interfaces: ["FSharpRecord"],
        properties: {
          Transformation: Transformation,
          Nodes: makeGeneric(List$1, {
            T: makeGeneric(_Node, {
              T: Expr
            })
          })
        }
      };
    }
  }]);

  return PivotSection;
}();
setType("TheGamma.Live.Pivot.PivotSection", PivotSection);
function transformName(_arg1) {
  var $var166 = _arg1.Case === "Empty" ? [1] : _arg1.Case === "FilterBy" ? [2] : _arg1.Case === "GetSeries" ? [3] : _arg1.Case === "GetTheData" ? [4] : _arg1.Case === "GroupBy" ? [5] : _arg1.Case === "WindowBy" ? [6] : _arg1.Case === "ExpandBy" ? [7] : _arg1.Case === "Paging" ? [8] : _arg1.Case === "SortBy" ? [9] : _arg1.Case === "GetRange" ? [10] : _arg1.Case === "Metadata" ? [10] : [0];

  switch ($var166[0]) {
    case 0:
      return "drop columns";

    case 1:
      return "empty";

    case 2:
      return "filter by";

    case 3:
      return "get series";

    case 4:
      return "get the data";

    case 5:
      return "group by";

    case 6:
      return "window by";

    case 7:
      return "expand by";

    case 8:
      return "paging";

    case 9:
      return "sort by";

    case 10:
      throw new Error("Unexpected get range or metadata");
  }
}
function createPivotSections(ch) {
  var loop = function loop(acc) {
    return function (tupledArg) {
      return function (_arg1) {
        loop: while (true) {
          var $var167 = _arg1.tail != null ? function () {
            var tfs_1 = _arg1.head[1];
            var e_1 = _arg1.head[0];

            if (transformName(tfs_1.head) === transformName(tupledArg[0])) {
              return tfs_1.length === tupledArg[2];
            } else {
              return false;
            }
          }() ? [0, _arg1.head[0], _arg1.head[1], _arg1.tail] : [1] : [1];

          switch ($var167[0]) {
            case 0:
              acc = acc;
              tupledArg = [$var167[2].head, new List$1($var167[1], tupledArg[1]), tupledArg[2]];
              _arg1 = $var167[3];
              continue loop;

            case 1:
              if (_arg1.tail == null) {
                var current = new PivotSection(tupledArg[0], reverse$1(tupledArg[1]));
                return reverse$1(new List$1(current, acc));
              } else {
                var tfs = _arg1.head[1];
                var e = _arg1.head[0];
                var current_1 = new PivotSection(tupledArg[0], reverse$1(tupledArg[1]));
                acc = new List$1(current_1, acc);
                tupledArg = [tfs.head, ofArray$1([e]), tfs.length];
                _arg1 = _arg1.tail;
                continue loop;
              }

          }
        }
      };
    };
  };

  var tfss = choose$1(function (tupledArg_1) {
    var matchValue = pickPivotTransformations(tupledArg_1[1]);

    if (matchValue == null) {
      return null;
    } else {
      var tfs_2 = filter$2(function (_arg2) {
        return _arg2.Case === "Empty" ? false : true;
      }, matchValue);

      if (tfs_2.tail == null) {
        return null;
      } else {
        return [tupledArg_1[1], tfs_2];
      }
    }
  }, ch.Chain);

  if (tfss.tail == null) {
    return new List$1();
  } else {
    var tfs_3 = tfss.head[1];
    var e_2 = tfss.head[0];
    return loop(new List$1())([tfs_3.head, ofArray$1([e_2]), tfs_3.length])(tfss.tail);
  }
}
function collectChain(acc, node$$1) {
  collectChain: while (true) {
    if (node$$1.Node.Case === "Call") {
      acc = new List$1([node$$1.Node.Fields[1].Range.Start, node$$1], acc);
      node$$1 = node$$1.Node.Fields[0];
      continue collectChain;
    } else if (node$$1.Node.Case === "Member") {
      acc = new List$1([node$$1.Node.Fields[1].Range.Start, node$$1], acc);
      node$$1 = node$$1.Node.Fields[0];
      continue collectChain;
    } else if (node$$1.Node.Case === "Variable") {
      return new List$1([node$$1.Node.Fields[0].Range.Start, node$$1], acc);
    } else {
      return null;
    }
  }
}
function collectFirstChain(expr) {
  var matchValue = collectChain(new List$1(), expr);
  var $var168 = matchValue != null ? matchValue.tail != null ? [0, matchValue] : [1] : [1];

  switch ($var168[0]) {
    case 0:
      return new NestedChain($var168[1]);

    case 1:
      var activePatternResult7339 = _ExprLeaf_ExprNode_(expr.Node);

      if (activePatternResult7339.Case === "Choice2Of2") {
        return tryPick(function (expr_1) {
          return collectFirstChain(expr_1);
        }, activePatternResult7339.Fields[0][0]);
      } else {
        return null;
      }

  }
}
var PivotEditorMenus = function () {
  function PivotEditorMenus(caseName, fields) {
    _classCallCheck(this, PivotEditorMenus);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(PivotEditorMenus, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Pivot.PivotEditorMenus",
        interfaces: ["FSharpUnion", "System.IEquatable", "System.IComparable"],
        cases: {
          AddDropdownOpen: [],
          ContextualDropdownOpen: [],
          Hidden: []
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsUnions(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareUnions(this, other);
    }
  }]);

  return PivotEditorMenus;
}();
setType("TheGamma.Live.Pivot.PivotEditorMenus", PivotEditorMenus);
var PivotEditorAction = function () {
  function PivotEditorAction(caseName, fields) {
    _classCallCheck(this, PivotEditorAction);

    this.Case = caseName;
    this.Fields = fields;
  }

  _createClass(PivotEditorAction, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Pivot.PivotEditorAction",
        interfaces: ["FSharpUnion"],
        cases: {
          AddElement: [Interface("TheGamma.Common.Symbol"), "string", Option(makeGeneric(List$1, {
            T: Expr
          }))],
          AddTransform: [Transformation],
          RemoveElement: [Interface("TheGamma.Common.Symbol")],
          RemoveSection: [Interface("TheGamma.Common.Symbol")],
          ReplaceElement: [Interface("TheGamma.Common.Symbol"), "string", Option(makeGeneric(List$1, {
            T: Expr
          }))],
          ReplaceRange: [_Range, "string"],
          SelectChainElement: ["number"],
          SelectRange: [_Range],
          SwitchMenu: [PivotEditorMenus],
          UpdatePreview: [DomNode]
        }
      };
    }
  }]);

  return PivotEditorAction;
}();
setType("TheGamma.Live.Pivot.PivotEditorAction", PivotEditorAction);
var PivotEditorState = function () {
  function PivotEditorState(body, firstNode, preview, sections, selectedEntity, menus, focus) {
    _classCallCheck(this, PivotEditorState);

    this.Body = body;
    this.FirstNode = firstNode;
    this.Preview = preview;
    this.Sections = sections;
    this.SelectedEntity = selectedEntity;
    this.Menus = menus;
    this.Focus = focus;
  }

  _createClass(PivotEditorState, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Pivot.PivotEditorState",
        interfaces: ["FSharpRecord"],
        properties: {
          Body: makeGeneric(_Node, {
            T: Expr
          }),
          FirstNode: makeGeneric(_Node, {
            T: Expr
          }),
          Preview: DomNode,
          Sections: makeGeneric(List$1, {
            T: PivotSection
          }),
          SelectedEntity: Entity,
          Menus: PivotEditorMenus,
          Focus: Option(Tuple(["string", Option("number")]))
        }
      };
    }
  }]);

  return PivotEditorState;
}();
setType("TheGamma.Live.Pivot.PivotEditorState", PivotEditorState);
function withPivotState(pivotState, state) {
  return new LiveState(state.Globals, state.Code, state.Program, state.Mapper, state.Location, state.Selection, pivotState, state.CurrentPreview);
}
function findPreview(trigger, globals, ent) {
  var nm = new Name("preview");
  var matchValue = ent.Type;
  var $var169 = void 0;

  if (matchValue != null) {
    if (matchValue.Case === "Object") {
      var activePatternResult7372 = function (obj) {
        return _FindMember___(nm, obj);
      }(matchValue.Fields[0]);

      if (activePatternResult7372 != null) {
        $var169 = [0];
      } else {
        $var169 = [1];
      }
    } else {
      $var169 = [1];
    }
  } else {
    $var169 = [1];
  }

  var _ret = function () {
    switch ($var169[0]) {
      case 0:
        var res = evaluate(globals, ent);
        var res_1 = defaultArg(res, null, function (p) {
          return p.Preview.value;
        });

        if (res_1 != null) {
          var _ret2 = function () {
            Log.trace("live", "Found preview value: %O", res_1);

            var node$$1 = function (arg0) {
              return function (arg1) {
                return El.op_Dynamic(arg0, arg1);
              };
            }(h$$1)("div")(ofArray$1([op_EqualsGreater("class", "placeholder")]))(ofArray$1([text("Loading preview...")]));

            var returned = false;

            (function (arg00) {
              startImmediate(arg00);
            })(function (builder_) {
              return builder_.Delay(function () {
                return builder_.Bind(table.create(res_1).render(), function (_arg4) {
                  return builder_.Combine(returned ? function () {
                    trigger(new LiveEvent("CustomEvent", [new PivotEditorAction("UpdatePreview", [_arg4])]));
                    return builder_.Zero();
                  }() : function () {
                    node$$1 = _arg4;
                    return builder_.Zero();
                  }(), builder_.Delay(function () {
                    Log.trace("live", "Evaluated to a node");
                    return builder_.Zero();
                  }));
                });
              });
            }(singleton$2));

            returned = true;
            Log.trace("live", "After evaluation started: %O", node$$1);
            return {
              v: {
                v: node$$1
              }
            };
          }();

          if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
        } else {
          return {
            v: function (arg0_1) {
              return function (arg1_1) {
                return El.op_Dynamic(arg0_1, arg1_1);
              };
            }(h$$1)("div")(ofArray$1([op_EqualsGreater("class", "placeholder")]))(ofArray$1([text("Preview could not be evaluated")]))
          };
        }

      case 1:
        return {
          v: function (arg0_2) {
            return function (arg1_2) {
              return El.op_Dynamic(arg0_2, arg1_2);
            };
          }(h$$1)("div")(ofArray$1([op_EqualsGreater("class", "placeholder")]))(ofArray$1([text("This block does not have a preview")]))
        };
    }
  }();

  if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
}
function updateBody(trigger, state) {
  var matchValue = commandAtLocation(state.Location, state.Program);

  if (matchValue != null) {
    var patternInput = state.Mapper.AbsoluteToLineCol(matchValue.Range.End + 1);
    var $var170 = matchValue.Node.Case === "Let" ? [0, matchValue.Node.Fields[1]] : [0, matchValue.Node.Fields[0]];

    switch ($var170[0]) {
      case 0:
        var matchValue_1 = collectFirstChain($var170[1]);

        if (matchValue_1 != null) {
          var _ret3 = function () {
            var sections = createPivotSections(matchValue_1);
            var patternInput_1 = matchValue_1.Chain.head;
            var matchValue_2 = tryLast(filter$2(function (tupledArg) {
              return state.Location >= tupledArg[0];
            }, matchValue_1.Chain));
            var $var171 = matchValue_2 != null ? function () {
              var selNode = matchValue_2[1];
              return !(sections.tail == null);
            }() ? [0, matchValue_2[1]] : [1] : [1];

            var _ret4 = function () {
              switch ($var171[0]) {
                case 0:
                  var preview = findPreview(trigger, state.Globals, $var171[1].Entity);
                  var ps = void 0;
                  var Menus = new PivotEditorMenus("Hidden", []);
                  var Focus = null;
                  var SelectedEntity = $var171[1].Entity;
                  ps = new PivotEditorState($var170[1], patternInput_1[1], preview, sections, SelectedEntity, Menus, Focus);
                  return {
                    v: {
                      v: function (state_1) {
                        return withPivotState(ps, state_1);
                      }(state)
                    }
                  };

                case 1:
                  return {
                    v: {
                      v: null
                    }
                  };
              }
            }();

            if ((typeof _ret4 === "undefined" ? "undefined" : _typeof(_ret4)) === "object") return _ret4.v;
          }();

          if ((typeof _ret3 === "undefined" ? "undefined" : _typeof(_ret3)) === "object") return _ret3.v;
        } else {
          return null;
        }

    }
  } else {
    return null;
  }
}
function hideMenus(state) {
  var State = void 0;
  var Menus = new PivotEditorMenus("Hidden", []);
  State = new PivotEditorState(state.State.Body, state.State.FirstNode, state.State.Preview, state.State.Sections, state.State.SelectedEntity, Menus, state.State.Focus);
  return new LiveState(state.Globals, state.Code, state.Program, state.Mapper, state.Location, state.Selection, State, state.CurrentPreview);
}
function editorLocation(mapper, startIndex, endIndex) {
  var patternInput = mapper.AbsoluteToLineCol(startIndex);
  var patternInput_1 = mapper.AbsoluteToLineCol(endIndex);
  var rng = {};
  return new LineColumnRange(patternInput[0], patternInput[1], patternInput_1[0], patternInput_1[1]);
}
function selectName(nd, state) {
  var rng = void 0;

  if (nd.Node.Case === "Member") {
    var n = nd.Node.Fields[1];
    rng = n.Range;
  } else {
    rng = nd.Range;
  }

  var loc = editorLocation(state.Mapper, rng.Start, rng.End + 1);
  var Selection = loc;
  return new LiveState(state.Globals, state.Code, state.Program, state.Mapper, state.Location, Selection, state.State, state.CurrentPreview);
}
function tryTransformChain(f, state) {
  var matchValue = collectFirstChain(state.State.Body);

  if (matchValue != null) {
    var sections = createPivotSections(matchValue);
    return hideMenus(f(state.State.Body)(map$5(function (tuple) {
      return tuple[1];
    }, matchValue.Chain))(sections));
  } else {
    return hideMenus(state);
  }
}
var marker = "InsertPropertyHere";
function replaceAndSelectMarker(newName, state) {
  var startIndex = state.Code.indexOf(marker);
  var newCode = replace$$1(state.Code, marker, escapeIdent(newName));
  var mapper = new LocationMapper(state.Code);
  var rng = editorLocation(mapper, startIndex, startIndex + escapeIdent(newName).length);
  var Selection = rng;
  return new LiveState(state.Globals, newCode, state.Program, state.Mapper, state.Location, Selection, state.State, state.CurrentPreview);
}
function reconstructChain(state, body, newNodes) {
  var newBody = fold(function (prev, part) {
    if (part.Node.Case === "Member") {
      var _Node$$1 = new Expr("Member", [prev, part.Node.Fields[1]]);

      return new _Node(part.WhiteBefore, part.WhiteAfter, part.Range, _Node$$1, part.Entity);
    } else if (part.Node.Case === "Call") {
      var _Node_1 = new Expr("Call", [prev, part.Node.Fields[1]]);

      return new _Node(part.WhiteBefore, part.WhiteAfter, part.Range, _Node_1, part.Entity);
    } else {
      throw new Error("reconstructChain: Unexpected node in call chain");
    }
  }, newNodes.head, newNodes.tail);
  var newCode = trim(formatSingleExpression(newBody), "both");
  var newCode_1 = state.Code.substr(0, body.Range.Start) + newCode + state.Code.substr(body.Range.End + 1);
  return new LiveState(state.Globals, newCode_1, state.Program, state.Mapper, state.Location, state.Selection, state.State, state.CurrentPreview);
}
function createChainNodes(args, name) {
  var node$$1 = function node$$1(nd) {
    return node(new _Range(0, 0), nd);
  };

  var mem = node$$1(new Expr("Member", [node$$1(new Expr("Empty", [])), node$$1(new Expr("Variable", [node$$1(new Name(name))]))]));

  if (args != null) {
    var args_1 = map$5(function (a) {
      return new Argument(null, node$$1(a));
    }, args);
    return ofArray$1([mem, node$$1(new Expr("Call", [mem, node$$1(args_1)]))]);
  } else {
    return ofArray$1([mem]);
  }
}
function getWhiteBeforeAndAfterSections(firstNode, sections) {
  var dominantWhite = function dominantWhite(whites) {
    var whites_1 = toList(toList(countBy(function (x) {
      return x;
    }, whites)));
    return reduce(function (f) {
      return function (x, y) {
        return f(x) > f(y) ? x : y;
      };
    }(function (tupledArg) {
      return tupledArg[0] === "" ? 0 : tupledArg[1];
    }), new List$1(["", 0], whites_1))[0];
  };

  var patternInput = [dominantWhite(function (list) {
    return map$5(function (nd) {
      return formatWhiteBeforeExpr(nd);
    }, list);
  }(map$5(function (sec) {
    return sec.Nodes.head;
  }, sections))), dominantWhite(function (list_1) {
    return map$5(function (nd_1) {
      return formatWhiteAfterExpr(nd_1);
    }, list_1);
  }(append$1(ofArray$1([firstNode]), map$5(function (sec_1) {
    return last(sec_1.Nodes);
  }, sections))))];
  Log.trace("live", "Inserting whitespace before '%s' and after '%s' for sections: %O", patternInput[0], patternInput[1], sections);
  return [ofArray$1([new Token(new TokenKind("White", [patternInput[0]]), new _Range(0, 0))]), ofArray$1([new Token(new TokenKind("White", [patternInput[1]]), new _Range(0, 0))])];
}
function insertWhiteAroundSection(before, after, section) {
  var lastIdx = section.Nodes.length - 1;
  return new PivotSection(section.Transformation, mapIndexed$1(function (i, node$$1) {
    var node_1 = void 0;
    var matchValue = [before, node$$1];
    var $var172 = matchValue[0] != null ? matchValue[1].Node.Case === "Member" ? function () {
      var n = matchValue[1].Node.Fields[1];
      var inst = matchValue[1].Node.Fields[0];
      var before_1 = matchValue[0];
      return i === 0;
    }() ? [0, matchValue[0], matchValue[1].Node.Fields[0], matchValue[1].Node.Fields[1]] : [1] : [1] : [1];

    switch ($var172[0]) {
      case 0:
        var _Node$$1 = new Expr("Member", [$var172[2], new _Node($var172[1], $var172[3].WhiteAfter, $var172[3].Range, $var172[3].Node, $var172[3].Entity)]);

        node_1 = new _Node(node$$1.WhiteBefore, node$$1.WhiteAfter, node$$1.Range, _Node$$1, node$$1.Entity);
        break;

      case 1:
        node_1 = node$$1;
        break;
    }

    var node_2 = void 0;
    var matchValue_1 = [after, node_1];
    var $var173 = matchValue_1[0] != null ? function () {
      var after_1 = matchValue_1[0];
      return i === lastIdx;
    }() ? [0, matchValue_1[0], matchValue_1[1]] : [1] : [1];

    switch ($var173[0]) {
      case 0:
        node_2 = new _Node($var173[2].WhiteBefore, $var173[1], $var173[2].Range, $var173[2].Node, $var173[2].Entity);
        break;

      case 1:
        node_2 = node_1;
        break;
    }

    return node_2;
  }, section.Nodes));
}
function updatePivotState(trigger, state, event) {
  var $var174 = event.Case === "UpdateLocation" ? [0] : event.Case === "InitializeGlobals" ? [1] : event.Case === "CustomEvent" ? [2] : [0];

  switch ($var174[0]) {
    case 0:
      return function (state_1) {
        return updateBody(trigger, state_1);
      }(hideMenus(state));

    case 1:
      return state;

    case 2:
      if (event.Fields[0].Case === "SwitchMenu") {
        return withPivotState(new PivotEditorState(state.State.Body, state.State.FirstNode, state.State.Preview, state.State.Sections, state.State.SelectedEntity, event.Fields[0].Fields[0], state.State.Focus), state);
      } else if (event.Fields[0].Case === "SelectChainElement") {
        return tryTransformChain(function (body) {
          return function (chain) {
            return function (sections) {
              var loop = function loop(before) {
                return function (chain_1) {
                  loop: while (true) {
                    var $var175 = chain_1.tail != null ? chain_1.head.Range.End + 1 < state.Location ? [0, chain_1.head, chain_1.tail] : [1] : [1];

                    switch ($var175[0]) {
                      case 0:
                        before = $var175[1];
                        chain_1 = $var175[2];
                        continue loop;

                      case 1:
                        if (chain_1.tail == null) {
                          return [before, before, before];
                        } else if (chain_1.tail.tail == null) {
                          return [before, chain_1.head, chain_1.head];
                        } else {
                          return [before, chain_1.head, chain_1.tail.head];
                        }

                    }
                  }
                };
              };

              var patternInput = loop(chain.head)(chain.tail);
              return selectName(event.Fields[0].Fields[0] < 0 ? patternInput[0] : event.Fields[0].Fields[0] > 0 ? patternInput[2] : patternInput[1], state);
            };
          };
        }, state);
      } else if (event.Fields[0].Case === "SelectRange") {
        return function () {
          var Selection = editorLocation(state.Mapper, event.Fields[0].Fields[0].Start, event.Fields[0].Fields[0].End + 1);
          return new LiveState(state.Globals, state.Code, state.Program, state.Mapper, state.Location, Selection, state.State, state.CurrentPreview);
        }();
      } else if (event.Fields[0].Case === "ReplaceRange") {
        var _ret5 = function () {
          Log.trace("live", "Replace '%s' with '%s'", state.Code.substr(event.Fields[0].Fields[0].Start, event.Fields[0].Fields[0].End - event.Fields[0].Fields[0].Start + 1), event.Fields[0].Fields[1]);
          var newCode = state.Code.substr(0, event.Fields[0].Fields[0].Start) + event.Fields[0].Fields[1] + state.Code.substr(event.Fields[0].Fields[0].End + 1);
          var location = editorLocation(new LocationMapper(newCode), event.Fields[0].Fields[0].Start, event.Fields[0].Fields[0].Start + event.Fields[0].Fields[1].length);
          return {
            v: function () {
              var Selection_1 = location;
              return new LiveState(state.Globals, newCode, state.Program, state.Mapper, state.Location, Selection_1, state.State, state.CurrentPreview);
            }()
          };
        }();

        if ((typeof _ret5 === "undefined" ? "undefined" : _typeof(_ret5)) === "object") return _ret5.v;
      } else if (event.Fields[0].Case === "AddElement") {
        return tryTransformChain(function (body_1) {
          return function (chain_2) {
            return function (sections_1) {
              var newNodes = collect$1(function (nd) {
                return !equals(nd.Entity.Symbol, event.Fields[0].Fields[0]) ? ofArray$1([nd]) : new List$1(nd, createChainNodes(event.Fields[0].Fields[2], marker));
              }, chain_2);
              return function (state_2) {
                return replaceAndSelectMarker(event.Fields[0].Fields[1], state_2);
              }(reconstructChain(state, body_1, newNodes));
            };
          };
        }, state);
      } else if (event.Fields[0].Case === "ReplaceElement") {
        return tryTransformChain(function (body_2) {
          return function (chain_3) {
            return function (sections_2) {
              var newNodes_1 = collect$1(function (nd_1) {
                return !equals(nd_1.Entity.Symbol, event.Fields[0].Fields[0]) ? ofArray$1([nd_1]) : createChainNodes(event.Fields[0].Fields[2], marker);
              }, chain_3);
              return function (state_3) {
                return replaceAndSelectMarker(event.Fields[0].Fields[1], state_3);
              }(reconstructChain(state, body_2, newNodes_1));
            };
          };
        }, state);
      } else if (event.Fields[0].Case === "RemoveElement") {
        return tryTransformChain(function (body_3) {
          return function (chain_4) {
            return function (sections_3) {
              var beforeDropped = tryLast(toList(takeWhile(function (nd_2) {
                return !equals(nd_2.Entity.Symbol, event.Fields[0].Fields[0]);
              }, chain_4)));
              var beforeDropped_1 = beforeDropped != null ? beforeDropped : chain_4.head;
              var newNodes_2 = filter$2(function (nd_3) {
                return !equals(nd_3.Entity.Symbol, event.Fields[0].Fields[0]);
              }, chain_4);
              return function (state_4) {
                return selectName(beforeDropped_1, state_4);
              }(reconstructChain(state, body_3, newNodes_2));
            };
          };
        }, state);
      } else if (event.Fields[0].Case === "RemoveSection") {
        return tryTransformChain(function (body_4) {
          return function (chain_5) {
            return function (sections_4) {
              var beforeDropped_2 = tryLast(toList(takeWhile(function (nd_4) {
                return !equals(nd_4.Entity.Symbol, event.Fields[0].Fields[0]);
              }, map$5(function (sec) {
                return sec.Nodes.head;
              }, sections_4))));
              var beforeDropped_3 = beforeDropped_2 != null ? beforeDropped_2 : chain_5.head;
              var newSections = filter$2(function (sec_1) {
                return !equals(sec_1.Nodes.head.Entity.Symbol, event.Fields[0].Fields[0]);
              }, sections_4);
              var newNodes_3 = collect$1(function (sec_2) {
                return sec_2.Nodes;
              }, newSections);
              return function (state_5) {
                return selectName(beforeDropped_3, state_5);
              }(reconstructChain(state, body_4, newNodes_3));
            };
          };
        }, state);
      } else if (event.Fields[0].Case === "AddTransform") {
        return tryTransformChain(function (body_5) {
          return function (chain_6) {
            return function (sections_5) {
              Log.trace("live", "Adding transform to chain: %O", _Array$from(chain_6));
              Log.trace("live", "Existing sections are: %O", _Array$from(sections_5));
              var patternInput_1 = getWhiteBeforeAndAfterSections(chain_6.head, sections_5);

              var node$$1 = function node$$1(n) {
                return node(new _Range(0, 0), n);
              };

              var fields = tryPick(function (expr) {
                return pickPivotFields(expr);
              }, reverse$1(collect$1(function (s$$1) {
                return s$$1.Nodes;
              }, sections_5)));
              var patternInput_2 = void 0;
              var $var176 = event.Fields[0].Fields[0].Case === "Metadata" ? [0] : event.Fields[0].Fields[0].Case === "DropColumns" ? [1] : event.Fields[0].Fields[0].Case === "SortBy" ? [2] : event.Fields[0].Fields[0].Case === "FilterBy" ? [3] : event.Fields[0].Fields[0].Case === "WindowBy" ? [4] : event.Fields[0].Fields[0].Case === "ExpandBy" ? [5] : event.Fields[0].Fields[0].Case === "Paging" ? [6] : event.Fields[0].Fields[0].Case === "GetSeries" ? [7] : event.Fields[0].Fields[0].Case === "GetTheData" ? [8] : event.Fields[0].Fields[0].Case === "GroupBy" ? [9] : event.Fields[0].Fields[0].Case === "Empty" ? [10] : [0];

              switch ($var176[0]) {
                case 0:
                  throw new Error("Unexpected get range or metadata");
                  break;

                case 1:
                  patternInput_2 = ["drop columns", ofArray$1([marker, "then"])];
                  break;

                case 2:
                  patternInput_2 = ["sort data", ofArray$1([marker, "then"])];
                  break;

                case 3:
                  patternInput_2 = ["filter data", ofArray$1([marker, "then"])];
                  break;

                case 4:
                  patternInput_2 = ["windowing", ofArray$1([marker, "then"])];
                  break;

                case 5:
                  patternInput_2 = ["expanding", ofArray$1([marker, "then"])];
                  break;

                case 6:
                  patternInput_2 = ["paging", ofArray$1([marker, "then"])];
                  break;

                case 7:
                  patternInput_2 = ["get series", ofArray$1([marker])];
                  break;

                case 8:
                  patternInput_2 = ["get the data", ofArray$1([marker])];
                  break;

                case 9:
                  patternInput_2 = ["group data", function () {
                    var $var177 = fields != null ? fields.tail != null ? [0, fields.head] : [1] : [1];

                    switch ($var177[0]) {
                      case 0:
                        return ofArray$1([marker, "by " + $var177[1].Name, "then"]);

                      case 1:
                        return ofArray$1([marker, "by Property", "then"]);
                    }
                  }()];
                  break;

                case 10:
                  patternInput_2 = ["", new List$1()];
                  break;
              }

              var newSection = insertWhiteAroundSection(patternInput_1[0], patternInput_1[1], new PivotSection(event.Fields[0].Fields[0], collect$1(function () {
                var args = null;
                return function (name) {
                  return createChainNodes(args, name);
                };
              }(), patternInput_2[1])));

              var closeFirstSection = function closeFirstSection(_arg1) {
                if (_arg1.tail == null) {
                  return new List$1();
                } else {
                  var _ret6 = function () {
                    var section = void 0;
                    var matchValue = [_arg1.head.Transformation, last(_arg1.head.Nodes)];
                    var $var178 = matchValue[0].Case === "Paging" ? matchValue[1].Node.Case === "Call" ? matchValue[1].Node.Fields[0].Node.Case === "Member" ? matchValue[1].Node.Fields[0].Node.Fields[1].Node.Case === "Variable" ? function () {
                      var n_2 = matchValue[1].Node.Fields[0].Node.Fields[1].Node.Fields[0];
                      return n_2.Node.Name === "take";
                    }() ? [0, matchValue[1].Node.Fields[0].Node.Fields[1].Node.Fields[0]] : [1] : [1] : [1] : [1] : [1];

                    switch ($var178[0]) {
                      case 0:
                        section = _arg1.head;
                        break;

                      case 1:
                        var $var179 = matchValue[1].Node.Case === "Member" ? matchValue[1].Node.Fields[1].Node.Case === "Variable" ? function () {
                          var n_1 = matchValue[1].Node.Fields[1].Node.Fields[0];
                          return n_1.Node.Name === "then";
                        }() ? [0, matchValue[1].Node.Fields[1].Node.Fields[0]] : [1] : [1] : [1];

                        switch ($var179[0]) {
                          case 0:
                            section = _arg1.head;
                            break;

                          case 1:
                            var Nodes = append$1(_arg1.head.Nodes, createChainNodes(null, "then"));
                            section = new PivotSection(_arg1.head.Transformation, Nodes);
                            break;
                        }

                        break;
                    }

                    return {
                      v: new List$1(insertWhiteAroundSection(null, patternInput_1[1], section), _arg1.tail)
                    };
                  }();

                  if ((typeof _ret6 === "undefined" ? "undefined" : _typeof(_ret6)) === "object") return _ret6.v;
                }
              };

              var newSections_1 = void 0;
              var matchValue_1 = reverse$1(sections_5);
              var $var180 = matchValue_1.tail != null ? matchValue_1.head.Transformation.Case === "GetSeries" ? [0, matchValue_1.head, matchValue_1.tail] : matchValue_1.head.Transformation.Case === "GetTheData" ? [0, matchValue_1.head, matchValue_1.tail] : [1, matchValue_1] : [1, matchValue_1];

              switch ($var180[0]) {
                case 0:
                  newSections_1 = reverse$1(ofArray$1([$var180[1], newSection], closeFirstSection($var180[2])));
                  break;

                case 1:
                  newSections_1 = reverse$1(new List$1(newSection, closeFirstSection($var180[1])));
                  break;
              }

              Log.trace("live", "Inserted section: %O", _Array$from(newSections_1));
              var newNodes_4 = collect$1(function (sec_3) {
                return sec_3.Nodes;
              }, newSections_1);
              return function (state_6) {
                return replaceAndSelectMarker(patternInput_2[0], state_6);
              }(reconstructChain(state, body_5, newNodes_4));
            };
          };
        }, state);
      } else {
        return withPivotState(new PivotEditorState(state.State.Body, state.State.FirstNode, event.Fields[0].Fields[0], state.State.Sections, state.State.SelectedEntity, state.State.Menus, state.State.Focus), state);
      }

  }
}
function renderNodeList(trigger, nodes) {
  return toList(delay(function () {
    return collect(function (nd) {
      var $var181 = nd.Node.Case === "Member" ? nd.Node.Fields[1].Node.Case === "Variable" ? function () {
        var n = nd.Node.Fields[1].Node.Fields[0];
        return n.Node.Name !== "then";
      }() ? [0, nd.Node.Fields[1].Node.Fields[0]] : [1] : [1] : [1];

      switch ($var181[0]) {
        case 0:
          return singleton(function (arg0) {
            return function (arg1) {
              return El.op_Dynamic(arg0, arg1);
            };
          }(h$$1)("span")(new List$1())(ofArray$1([function (arg0_1) {
            return function (arg1_1) {
              return El.op_Dynamic(arg0_1, arg1_1);
            };
          }(h$$1)("a")(ofArray$1([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectRange", [$var181[1].Range])))]))(ofArray$1([text($var181[1].Node.Name)])), function (arg0_2) {
            return function (arg1_2) {
              return El.op_Dynamic(arg0_2, arg1_2);
            };
          }(h$$1)("a")(ofArray$1([op_EqualsBangGreater("click", trigger(new PivotEditorAction("RemoveElement", [nd.Entity.Symbol])))]))(ofArray$1([function (arg0_3) {
            return function (arg1_3) {
              return El.op_Dynamic(arg0_3, arg1_3);
            };
          }(h$$1)("i")(ofArray$1([op_EqualsGreater("class", "gfa gfa-times")]))(new List$1())]))])));

        case 1:
          return empty();
      }
    }, nodes);
  }));
}
function renderContextMenu(trigger) {
  return function (arg0) {
    return function (arg1) {
      return El.op_Dynamic(arg0, arg1);
    };
  }(h$$1)("a")(ofArray$1([op_EqualsGreater("class", "right"), op_EqualsBangGreater("click", trigger(new PivotEditorAction("SwitchMenu", [new PivotEditorMenus("ContextualDropdownOpen", [])])))]))(ofArray$1([function (arg0_1) {
    return function (arg1_1) {
      return El.op_Dynamic(arg0_1, arg1_1);
    };
  }(h$$1)("i")(ofArray$1([op_EqualsGreater("class", "gfa gfa-plus")]))(new List$1())]));
}
function renderAddPropertyMenu(trigger, f, nodes) {
  return toList(delay(function () {
    var lastNode = find(function (_arg1) {
      var $var182 = _arg1.Node.Case === "Member" ? _arg1.Node.Fields[1].Node.Case === "Variable" ? [0, _arg1.Node.Fields[1].Node.Fields[0]] : [1] : [1];

      switch ($var182[0]) {
        case 0:
          return $var182[1].Node.Name !== "then";

        case 1:
          return true;
      }
    }, reverse$1(nodes));
    var matchValue = lastNode.Entity.Type;
    var $var183 = matchValue != null ? matchValue.Case === "Object" ? [0, matchValue.Fields[0]] : [1] : [1];

    var _ret7 = function () {
      switch ($var183[0]) {
        case 0:
          var members = sortWith(function (x, y) {
            return compare(x, y);
          }, choose(function (m) {
            return f(m.Name) ? m.Name : null;
          }, $var183[1].Members));
          return {
            v: singleton(function (arg0) {
              return function (arg1) {
                return El.op_Dynamic(arg0, arg1);
              };
            }(h$$1)("ul")(new List$1())(toList(delay(function () {
              return map$3(function (n) {
                return function (arg0_1) {
                  return function (arg1_1) {
                    return El.op_Dynamic(arg0_1, arg1_1);
                  };
                }(h$$1)("li")(new List$1())(ofArray$1([function (arg0_2) {
                  return function (arg1_2) {
                    return El.op_Dynamic(arg0_2, arg1_2);
                  };
                }(h$$1)("a")(ofArray$1([op_EqualsBangGreater("click", trigger(new PivotEditorAction("AddElement", [lastNode.Entity.Symbol, n, null])))]))(ofArray$1([text(n)]))]));
              }, members);
            }))))
          };

        case 1:
          return {
            v: empty()
          };
      }
    }();

    if ((typeof _ret7 === "undefined" ? "undefined" : _typeof(_ret7)) === "object") return _ret7.v;
  }));
}
function renderSection(triggerEvent, section) {
  var trigger = function trigger(action) {
    return function (_arg1) {
      return function (e) {
        e.cancelBubble = true;
        triggerEvent(new LiveEvent("CustomEvent", [action]));
      };
    };
  };

  var triggerWith = function triggerWith(f) {
    return function (el) {
      return function (e_1) {
        e_1.cancelBubble = true;
        triggerEvent(new LiveEvent("CustomEvent", [f(el)]));
      };
    };
  };

  var getNodeNameAndSymbol = function getNodeNameAndSymbol(_arg1_1) {
    var $var184 = _arg1_1 != null ? _arg1_1.Node.Case === "Member" ? _arg1_1.Node.Fields[1].Node.Case === "Variable" ? _arg1_1.Entity != null ? [0, _arg1_1.Entity, _arg1_1.Node.Fields[1].Node.Fields[0]] : [1] : [1] : [1] : [1];

    switch ($var184[0]) {
      case 0:
        return [$var184[2].Node.Name, $var184[1].Symbol];

      case 1:
        return ["", null];
    }
  };

  return toList(delay(function () {
    var $var185 = section != null ? section.Transformation.Case === "GetSeries" ? [0, section.Nodes] : section.Transformation.Case === "GroupBy" ? [1, section.Nodes] : section.Transformation.Case === "Paging" ? [2, section.Nodes] : section.Transformation.Case === "SortBy" ? [3, section.Nodes] : section.Transformation.Case === "DropColumns" ? [4, section.Nodes] : [5] : [5];

    var _ret8 = function () {
      switch ($var185[0]) {
        case 0:
          var patternInput = void 0;

          if ($var185[1].tail != null) {
            if ($var185[1].tail.tail != null) {
              if ($var185[1].tail.tail.tail != null) {
                patternInput = [$var185[1].head, $var185[1].tail.head, $var185[1].tail.tail.head];
              } else {
                patternInput = [$var185[1].head, $var185[1].tail.head, null];
              }
            } else {
              patternInput = [$var185[1].head, null, null];
            }
          } else {
            throw new Error("No get series node in get series transformation");
          }

          var patternInput_1 = getNodeNameAndSymbol(patternInput[1]);
          var patternInput_2 = getNodeNameAndSymbol(patternInput[2]);
          return {
            v: append(function () {
              var matchValue = patternInput[0].Entity.Type;
              var $var186 = matchValue != null ? matchValue.Case === "Object" ? [0, matchValue.Fields[0]] : [1] : [1];

              switch ($var186[0]) {
                case 0:
                  return append(singleton(function (arg0) {
                    return function (arg1) {
                      return El.op_Dynamic(arg0, arg1);
                    };
                  }(h$$1)("span")(new List$1())(ofArray$1([text("with key")]))), delay(function () {
                    return singleton(function (arg0_1) {
                      return function (arg1_1) {
                        return El.op_Dynamic(arg0_1, arg1_1);
                      };
                    }(h$$1)("select")(ofArray$1([op_EqualsBangGreater("change", triggerWith(function (el_1) {
                      return patternInput_1[1] != null ? new PivotEditorAction("ReplaceElement", [patternInput_1[1], el_1.value, null]) : new PivotEditorAction("AddElement", [patternInput[0].Entity.Symbol, el_1.value, null]);
                    }))]))(toList(delay(function () {
                      return append(patternInput_1[0] === "" ? singleton(function (arg0_2) {
                        return function (arg1_2) {
                          return El.op_Dynamic(arg0_2, arg1_2);
                        };
                      }(h$$1)("option")(ofArray$1([op_EqualsGreater("value", ""), op_EqualsGreater("selected", "selected")]))(ofArray$1([text("")]))) : empty(), delay(function () {
                        return collect(function (m) {
                          return m.Name.indexOf("with key") === 0 ? singleton(function (arg0_3) {
                            return function (arg1_3) {
                              return El.op_Dynamic(arg0_3, arg1_3);
                            };
                          }(h$$1)("option")(toList(delay(function () {
                            return append(singleton(op_EqualsGreater("value", m.Name)), delay(function () {
                              return patternInput_1[0] === m.Name ? singleton(op_EqualsGreater("selected", "selected")) : empty();
                            }));
                          })))(ofArray$1([text(replace$$1(m.Name, "with key ", ""))]))) : empty();
                        }, $var186[1].Members);
                      }));
                    }))));
                  }));

                case 1:
                  return empty();
              }
            }(), delay(function () {
              var $var187 = patternInput[1] != null ? patternInput[1].Entity != null ? patternInput[1].Entity.Type != null ? patternInput[1].Entity.Type.Case === "Object" ? [0, patternInput[1].Entity, patternInput[1].Entity.Type.Fields[0]] : [1] : [1] : [1] : [1];

              switch ($var187[0]) {
                case 0:
                  return append(singleton(function (arg0_4) {
                    return function (arg1_4) {
                      return El.op_Dynamic(arg0_4, arg1_4);
                    };
                  }(h$$1)("span")(new List$1())(ofArray$1([text("and value")]))), delay(function () {
                    return singleton(function (arg0_5) {
                      return function (arg1_5) {
                        return El.op_Dynamic(arg0_5, arg1_5);
                      };
                    }(h$$1)("select")(ofArray$1([op_EqualsBangGreater("change", triggerWith(function (el_2) {
                      return patternInput_2[1] != null ? new PivotEditorAction("ReplaceElement", [patternInput_2[1], el_2.value, null]) : new PivotEditorAction("AddElement", [$var187[1].Symbol, el_2.value, null]);
                    }))]))(toList(delay(function () {
                      return append(patternInput_2[0] === "" ? singleton(function (arg0_6) {
                        return function (arg1_6) {
                          return El.op_Dynamic(arg0_6, arg1_6);
                        };
                      }(h$$1)("option")(ofArray$1([op_EqualsGreater("value", ""), op_EqualsGreater("selected", "selected")]))(ofArray$1([text("")]))) : empty(), delay(function () {
                        return collect(function (m_1) {
                          return m_1.Name.indexOf("and value") === 0 ? singleton(function (arg0_7) {
                            return function (arg1_7) {
                              return El.op_Dynamic(arg0_7, arg1_7);
                            };
                          }(h$$1)("option")(toList(delay(function () {
                            return append(singleton(op_EqualsGreater("value", m_1.Name)), delay(function () {
                              return patternInput_2[0] === m_1.Name ? singleton(op_EqualsGreater("selected", "selected")) : empty();
                            }));
                          })))(ofArray$1([text(replace$$1(m_1.Name, "and value ", ""))]))) : empty();
                        }, $var187[2].Members);
                      }));
                    }))));
                  }));

                case 1:
                  return empty();
              }
            }))
          };

        case 1:
          var patternInput_3 = void 0;

          if ($var185[1].tail != null) {
            if ($var185[1].tail.tail != null) {
              patternInput_3 = [$var185[1].head, $var185[1].tail.head, $var185[1].tail.tail];
            } else {
              patternInput_3 = [$var185[1].head, null, new List$1()];
            }
          } else {
            throw new Error("No group by node in group by transformation");
          }

          var patternInput_4 = getNodeNameAndSymbol(patternInput_3[1]);
          return {
            v: append(function () {
              var matchValue_1 = patternInput_3[0].Entity.Type;
              var $var188 = matchValue_1 != null ? matchValue_1.Case === "Object" ? [0, matchValue_1.Fields[0]] : [1] : [1];

              switch ($var188[0]) {
                case 0:
                  return singleton(function (arg0_8) {
                    return function (arg1_8) {
                      return El.op_Dynamic(arg0_8, arg1_8);
                    };
                  }(h$$1)("select")(ofArray$1([op_EqualsBangGreater("change", triggerWith(function (el_3) {
                    return patternInput_4[1] != null ? new PivotEditorAction("ReplaceElement", [patternInput_4[1], el_3.value, null]) : new PivotEditorAction("AddElement", [patternInput_3[0].Entity.Symbol, el_3.value, null]);
                  }))]))(toList(delay(function () {
                    return append(patternInput_4[0] === "" ? singleton(function (arg0_9) {
                      return function (arg1_9) {
                        return El.op_Dynamic(arg0_9, arg1_9);
                      };
                    }(h$$1)("option")(ofArray$1([op_EqualsGreater("value", ""), op_EqualsGreater("selected", "selected")]))(ofArray$1([text("")]))) : empty(), delay(function () {
                      return collect(function (m_2) {
                        return m_2.Name.indexOf("by") === 0 ? singleton(function (arg0_10) {
                          return function (arg1_10) {
                            return El.op_Dynamic(arg0_10, arg1_10);
                          };
                        }(h$$1)("option")(toList(delay(function () {
                          return append(singleton(op_EqualsGreater("value", m_2.Name)), delay(function () {
                            return patternInput_4[0] === m_2.Name ? singleton(op_EqualsGreater("selected", "selected")) : empty();
                          }));
                        })))(ofArray$1([text(m_2.Name)]))) : empty();
                      }, $var188[1].Members);
                    }));
                  }))));

                case 1:
                  return empty();
              }
            }(), delay(function () {
              return append(renderNodeList(trigger, patternInput_3[2]), delay(function () {
                return singleton(renderContextMenu(trigger));
              }));
            }))
          };

        case 2:
          var methods = create$5(map$5(function (_arg35) {
            var $var189 = _arg35.Node.Case === "Member" ? _arg35.Node.Fields[1].Node.Case === "Variable" ? [0, _arg35.Node.Fields[1].Node.Fields[0]] : [1] : [1];

            switch ($var189[0]) {
              case 0:
                return $var189[1].Node.Name;

              case 1:
                return "";
            }
          }, $var185[1]), new GenericComparer(compare));
          return {
            v: append(collect(function (nd) {
              Log.error("live", "Paging node: %O", nd);
              var $var190 = nd.Node.Case === "Call" ? nd.Node.Fields[0].Node.Case === "Member" ? nd.Node.Fields[0].Node.Fields[1].Node.Case === "Variable" ? nd.Node.Fields[1].Node.tail != null ? nd.Node.Fields[1].Node.tail.tail == null ? [0, nd.Node.Fields[1].Node.head, nd.Node.Fields[0].Node.Fields[1].Node.Fields[0]] : [1] : [1] : [1] : [1] : [1];

              switch ($var190[0]) {
                case 0:
                  var removeOp = $var190[2].Node.Name === "take" ? new PivotEditorAction("ReplaceElement", [nd.Entity.Symbol, "then", null]) : new PivotEditorAction("RemoveElement", [nd.Entity.Symbol]);
                  return singleton(function (arg0_11) {
                    return function (arg1_11) {
                      return El.op_Dynamic(arg0_11, arg1_11);
                    };
                  }(h$$1)("span")(new List$1())(ofArray$1([function (arg0_12) {
                    return function (arg1_12) {
                      return El.op_Dynamic(arg0_12, arg1_12);
                    };
                  }(h$$1)("a")(ofArray$1([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectRange", [$var190[2].Range])))]))(ofArray$1([text($var190[2].Node.Name)])), function (arg0_13) {
                    return function (arg1_13) {
                      return El.op_Dynamic(arg0_13, arg1_13);
                    };
                  }(h$$1)("input")(ofArray$1([op_EqualsGreater("id", "input-pg-" + $var190[2].Node.Name), op_EqualsBangGreater("input", function (el_4) {
                    return function (_arg2) {
                      var input = el_4;
                      var patternInput_5 = parseProgram(input.value);

                      if (patternInput_5[1].length === 0 ? patternInput_5[0].Body.Node.length === 1 : false) {
                        el_4.setCustomValidity("");
                        triggerEvent(new LiveEvent("CustomEvent", [new PivotEditorAction("ReplaceRange", [$var190[1].Value.Range, input.value])]));
                      } else {
                        el_4.setCustomValidity("Cannot parse expression");
                      }
                    };
                  }), op_EqualsGreater("value", formatSingleExpression($var190[1].Value))]))(new List$1()), function (arg0_14) {
                    return function (arg1_14) {
                      return El.op_Dynamic(arg0_14, arg1_14);
                    };
                  }(h$$1)("a")(ofArray$1([op_EqualsBangGreater("click", trigger(removeOp))]))(ofArray$1([function (arg0_15) {
                    return function (arg1_15) {
                      return El.op_Dynamic(arg0_15, arg1_15);
                    };
                  }(h$$1)("i")(ofArray$1([op_EqualsGreater("class", "gfa gfa-times")]))(new List$1())]))])));

                case 1:
                  return empty();
              }
            }, $var185[1]), delay(function () {
              return !(methods.has("take") ? methods.has("skip") : false) ? singleton(renderContextMenu(trigger)) : empty();
            }))
          };

        case 3:
          var props = choose$1(function (_arg51) {
            var $var191 = _arg51.Node.Case === "Member" ? _arg51.Node.Fields[1].Node.Case === "Variable" ? _arg51.Entity != null ? function () {
              var sym = _arg51.Entity.Symbol;
              var n = _arg51.Node.Fields[1].Node.Fields[0];

              if (n.Node.Name !== "then") {
                return n.Node.Name !== "sort data";
              } else {
                return false;
              }
            }() ? [0, _arg51.Node.Fields[1].Node.Fields[0], _arg51.Entity.Symbol] : [1] : [1] : [1] : [1];

            switch ($var191[0]) {
              case 0:
                return [$var191[2], $var191[1]];

              case 1:
                return null;
            }
          }, $var185[1]);
          var last$$1 = tryLast(props);
          return {
            v: append(collect(function (matchValue_2) {
              return singleton(function (arg0_16) {
                return function (arg1_16) {
                  return El.op_Dynamic(arg0_16, arg1_16);
                };
              }(h$$1)("span")(new List$1())(toList(delay(function () {
                return append(singleton(function (arg0_17) {
                  return function (arg1_17) {
                    return El.op_Dynamic(arg0_17, arg1_17);
                  };
                }(h$$1)("a")(ofArray$1([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectRange", [matchValue_2[1].Range])))]))(ofArray$1([text(matchValue_2[1].Node.Name)]))), delay(function () {
                  return matchValue_2[1].Node.Name === last$$1[1].Node.Name ? singleton(function (arg0_18) {
                    return function (arg1_18) {
                      return El.op_Dynamic(arg0_18, arg1_18);
                    };
                  }(h$$1)("a")(ofArray$1([op_EqualsBangGreater("click", trigger(new PivotEditorAction("RemoveElement", [matchValue_2[0]])))]))(ofArray$1([function (arg0_19) {
                    return function (arg1_19) {
                      return El.op_Dynamic(arg0_19, arg1_19);
                    };
                  }(h$$1)("i")(ofArray$1([op_EqualsGreater("class", "gfa gfa-times")]))(new List$1())]))) : empty();
                }));
              }))));
            }, props), delay(function () {
              return singleton(renderContextMenu(trigger));
            }))
          };

        case 4:
          return {
            v: append(renderNodeList(trigger, $var185[1].tail), delay(function () {
              return singleton(renderContextMenu(trigger));
            }))
          };

        case 5:
          return {
            v: empty()
          };
      }
    }();

    if ((typeof _ret8 === "undefined" ? "undefined" : _typeof(_ret8)) === "object") return _ret8.v;
  }));
}
function renderPivot(triggerEvent, state) {
  var trigger = function trigger(action) {
    return function (_arg1) {
      return function (e) {
        e.cancelBubble = true;
        triggerEvent(new LiveEvent("CustomEvent", [action]));
      };
    };
  };

  var triggerWith = function triggerWith(f) {
    return function (el) {
      return function (e_1) {
        e_1.cancelBubble = true;
        triggerEvent(new LiveEvent("CustomEvent", [f(el)]));
      };
    };
  };

  var selSec = tryFind(function (sec) {
    return exists(function (secEnt) {
      return equals(state.State.SelectedEntity.Symbol, secEnt.Entity.Symbol);
    }, sec.Nodes);
  }, state.State.Sections);
  var firstNode = state.State.FirstNode;

  var dom = function (arg0) {
    return function (arg1) {
      return El.op_Dynamic(arg0, arg1);
    };
  }(h$$1)("div")(toList(delay(function () {
    return append(singleton(op_EqualsGreater("class", "pivot-preview")), delay(function () {
      return !state.State.Menus.Equals(new PivotEditorMenus("Hidden", [])) ? singleton(op_EqualsBangGreater("click", trigger(new PivotEditorAction("SwitchMenu", [new PivotEditorMenus("Hidden", [])])))) : empty();
    }));
  })))(ofArray$1([function (arg0_1) {
    return function (arg1_1) {
      return El.op_Dynamic(arg0_1, arg1_1);
    };
  }(h$$1)("ul")(ofArray$1([op_EqualsGreater("class", "tabs")]))(toList(delay(function () {
    return append(singleton(function (arg0_2) {
      return function (arg1_2) {
        return El.op_Dynamic(arg0_2, arg1_2);
      };
    }(h$$1)("li")(ofArray$1([op_EqualsGreater("class", equals(state.State.SelectedEntity.Symbol, firstNode.Entity.Symbol) ? "selected" : "")]))(ofArray$1([function (arg0_3) {
      return function (arg1_3) {
        return El.op_Dynamic(arg0_3, arg1_3);
      };
    }(h$$1)("a")(ofArray$1([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectRange", [firstNode.Range])))]))(toList(delay(function () {
      return firstNode.Node.Case === "Variable" ? singleton(text(firstNode.Node.Fields[0].Node.Name)) : singleton(text("data"));
    })))]))), delay(function () {
      return append(map$3(function (sec_1) {
        var selected = exists(function (secEnt_1) {
          return equals(state.State.SelectedEntity.Symbol, secEnt_1.Entity.Symbol);
        }, sec_1.Nodes);
        var secSymbol = sec_1.Nodes.head.Entity.Symbol;
        var identRange = void 0;
        var $var192 = sec_1.Nodes.tail != null ? sec_1.Nodes.head.Node.Case === "Variable" ? [0, sec_1.Nodes.head.Node.Fields[0]] : sec_1.Nodes.head.Node.Case === "Member" ? sec_1.Nodes.head.Node.Fields[1].Node.Case === "Variable" ? [0, sec_1.Nodes.head.Node.Fields[1].Node.Fields[0]] : [1] : [1] : [1];

        switch ($var192[0]) {
          case 0:
            identRange = $var192[1].Range;
            break;

          case 1:
            throw new Error("Unexpected node in pivot call chain");
            break;
        }

        return function (arg0_4) {
          return function (arg1_4) {
            return El.op_Dynamic(arg0_4, arg1_4);
          };
        }(h$$1)("li")(ofArray$1([op_EqualsGreater("class", selected ? "selected" : "")]))(ofArray$1([function (arg0_5) {
          return function (arg1_5) {
            return El.op_Dynamic(arg0_5, arg1_5);
          };
        }(h$$1)("a")(ofArray$1([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectRange", [identRange])))]))(ofArray$1([text(transformName(sec_1.Transformation))])), function (arg0_6) {
          return function (arg1_6) {
            return El.op_Dynamic(arg0_6, arg1_6);
          };
        }(h$$1)("a")(ofArray$1([op_EqualsBangGreater("click", trigger(new PivotEditorAction("RemoveSection", [secSymbol])))]))(ofArray$1([function (arg0_7) {
          return function (arg1_7) {
            return El.op_Dynamic(arg0_7, arg1_7);
          };
        }(h$$1)("i")(ofArray$1([op_EqualsGreater("class", "gfa gfa-times")]))(new List$1())]))]));
      }, state.State.Sections), delay(function () {
        return singleton(function (arg0_8) {
          return function (arg1_8) {
            return El.op_Dynamic(arg0_8, arg1_8);
          };
        }(h$$1)("li")(ofArray$1([op_EqualsGreater("class", state.State.Menus.Equals(new PivotEditorMenus("AddDropdownOpen", [])) ? "add selected" : "add")]))(ofArray$1([function (arg0_9) {
          return function (arg1_9) {
            return El.op_Dynamic(arg0_9, arg1_9);
          };
        }(h$$1)("a")(ofArray$1([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SwitchMenu", [new PivotEditorMenus("AddDropdownOpen", [])])))]))(ofArray$1([function (arg0_10) {
          return function (arg1_10) {
            return El.op_Dynamic(arg0_10, arg1_10);
          };
        }(h$$1)("i")(ofArray$1([op_EqualsGreater("class", "gfa gfa-plus")]))(new List$1())]))])));
      }));
    }));
  }))), function (arg0_11) {
    return function (arg1_11) {
      return El.op_Dynamic(arg0_11, arg1_11);
    };
  }(h$$1)("div")(ofArray$1([op_EqualsGreater("class", "add-menu")]))(toList(delay(function () {
    var clickHandler = function clickHandler(tfs) {
      return op_EqualsBangGreater("click", trigger(new PivotEditorAction("AddTransform", [tfs])));
    };

    if (state.State.Menus.Equals(new PivotEditorMenus("AddDropdownOpen", []))) {
      return singleton(function (arg0_12) {
        return function (arg1_12) {
          return El.op_Dynamic(arg0_12, arg1_12);
        };
      }(h$$1)("ul")(new List$1())(toList(delay(function () {
        return append(singleton(function (arg0_13) {
          return function (arg1_13) {
            return El.op_Dynamic(arg0_13, arg1_13);
          };
        }(h$$1)("li")(new List$1())(ofArray$1([function (arg0_14) {
          return function (arg1_14) {
            return El.op_Dynamic(arg0_14, arg1_14);
          };
        }(h$$1)("a")(ofArray$1([clickHandler(new Transformation("DropColumns", [new List$1()]))]))(ofArray$1([text("drop columns")]))]))), delay(function () {
          return append(singleton(function (arg0_15) {
            return function (arg1_15) {
              return El.op_Dynamic(arg0_15, arg1_15);
            };
          }(h$$1)("li")(new List$1())(ofArray$1([function (arg0_16) {
            return function (arg1_16) {
              return El.op_Dynamic(arg0_16, arg1_16);
            };
          }(h$$1)("a")(ofArray$1([clickHandler(new Transformation("GroupBy", [new List$1(), new List$1()]))]))(ofArray$1([text("group by")]))]))), delay(function () {
            return append(singleton(function (arg0_17) {
              return function (arg1_17) {
                return El.op_Dynamic(arg0_17, arg1_17);
              };
            }(h$$1)("li")(new List$1())(ofArray$1([function (arg0_18) {
              return function (arg1_18) {
                return El.op_Dynamic(arg0_18, arg1_18);
              };
            }(h$$1)("a")(ofArray$1([clickHandler(new Transformation("Paging", [new List$1()]))]))(ofArray$1([text("paging")]))]))), delay(function () {
              return append(singleton(function (arg0_19) {
                return function (arg1_19) {
                  return El.op_Dynamic(arg0_19, arg1_19);
                };
              }(h$$1)("li")(new List$1())(ofArray$1([function (arg0_20) {
                return function (arg1_20) {
                  return El.op_Dynamic(arg0_20, arg1_20);
                };
              }(h$$1)("a")(ofArray$1([clickHandler(new Transformation("SortBy", [new List$1()]))]))(ofArray$1([text("sort by")]))]))), delay(function () {
                var getDataCalled = exists(function (_arg64) {
                  var $var193 = _arg64.Transformation.Case === "GetTheData" ? [0] : _arg64.Transformation.Case === "GetSeries" ? [0] : [1];

                  switch ($var193[0]) {
                    case 0:
                      return true;

                    case 1:
                      return false;
                  }
                }, state.State.Sections);

                if (!getDataCalled) {
                  return append(singleton(function (arg0_21) {
                    return function (arg1_21) {
                      return El.op_Dynamic(arg0_21, arg1_21);
                    };
                  }(h$$1)("li")(new List$1())(ofArray$1([function (arg0_22) {
                    return function (arg1_22) {
                      return El.op_Dynamic(arg0_22, arg1_22);
                    };
                  }(h$$1)("a")(ofArray$1([clickHandler(new Transformation("GetTheData", []))]))(ofArray$1([text("get the data")]))]))), delay(function () {
                    return singleton(function (arg0_23) {
                      return function (arg1_23) {
                        return El.op_Dynamic(arg0_23, arg1_23);
                      };
                    }(h$$1)("li")(new List$1())(ofArray$1([function (arg0_24) {
                      return function (arg1_24) {
                        return El.op_Dynamic(arg0_24, arg1_24);
                      };
                    }(h$$1)("a")(ofArray$1([clickHandler(new Transformation("GetSeries", ["!", "!"]))]))(ofArray$1([text("get series")]))])));
                  }));
                } else {
                  return empty();
                }
              }));
            }));
          }));
        }));
      }))));
    } else {
      return empty();
    }
  }))), function (arg0_25) {
    return function (arg1_25) {
      return El.op_Dynamic(arg0_25, arg1_25);
    };
  }(h$$1)("div")(ofArray$1([op_EqualsGreater("class", "toolbar")]))(toList(delay(function () {
    return append(singleton(function (arg0_26) {
      return function (arg1_26) {
        return El.op_Dynamic(arg0_26, arg1_26);
      };
    }(h$$1)("span")(ofArray$1([op_EqualsGreater("class", "navig")]))(ofArray$1([function (arg0_27) {
      return function (arg1_27) {
        return El.op_Dynamic(arg0_27, arg1_27);
      };
    }(h$$1)("a")(new List$1())(ofArray$1([function (arg0_28) {
      return function (arg1_28) {
        return El.op_Dynamic(arg0_28, arg1_28);
      };
    }(h$$1)("i")(ofArray$1([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectChainElement", [-1]))), op_EqualsGreater("class", "gfa gfa-chevron-left")]))(new List$1())])), function (arg0_29) {
      return function (arg1_29) {
        return El.op_Dynamic(arg0_29, arg1_29);
      };
    }(h$$1)("a")(new List$1())(ofArray$1([function (arg0_30) {
      return function (arg1_30) {
        return El.op_Dynamic(arg0_30, arg1_30);
      };
    }(h$$1)("i")(ofArray$1([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectChainElement", [0]))), op_EqualsGreater("class", "gfa gfa-circle")]))(new List$1())])), function (arg0_31) {
      return function (arg1_31) {
        return El.op_Dynamic(arg0_31, arg1_31);
      };
    }(h$$1)("a")(new List$1())(ofArray$1([function (arg0_32) {
      return function (arg1_32) {
        return El.op_Dynamic(arg0_32, arg1_32);
      };
    }(h$$1)("i")(ofArray$1([op_EqualsBangGreater("click", trigger(new PivotEditorAction("SelectChainElement", [1]))), op_EqualsGreater("class", "gfa gfa-chevron-right")]))(new List$1())]))]))), delay(function () {
      return renderSection(triggerEvent, selSec);
    }));
  }))), function (arg0_33) {
    return function (arg1_33) {
      return El.op_Dynamic(arg0_33, arg1_33);
    };
  }(h$$1)("div")(ofArray$1([op_EqualsGreater("class", "add-menu")]))(toList(delay(function () {
    var matchValue = [state.State.Menus, selSec];
    var $var194 = matchValue[0].Case === "ContextualDropdownOpen" ? matchValue[1] != null ? matchValue[1].Transformation.Case === "Paging" ? [0, matchValue[1].Nodes] : matchValue[1].Transformation.Case === "GroupBy" ? [1, matchValue[1].Nodes] : matchValue[1].Transformation.Case === "SortBy" ? [2, matchValue[1].Nodes] : matchValue[1].Transformation.Case === "DropColumns" ? [3, matchValue[1].Nodes] : [4] : [4] : [4];

    var _ret9 = function () {
      switch ($var194[0]) {
        case 0:
          var methods = new _Map(choose$1(function (_arg104) {
            var $var195 = _arg104.Node.Case === "Member" ? _arg104.Node.Fields[1].Node.Case === "Variable" ? [0, _arg104.Entity, _arg104.Node.Fields[1].Node.Fields[0]] : [1] : [1];

            switch ($var195[0]) {
              case 0:
                return [$var195[2].Node.Name, $var195[1].Symbol];

              case 1:
                return null;
            }
          }, $var194[1]));
          var lastSym = last($var194[1]).Entity.Symbol;
          var firstSym = $var194[1].head.Entity.Symbol;
          return {
            v: singleton(function (arg0_34) {
              return function (arg1_34) {
                return El.op_Dynamic(arg0_34, arg1_34);
              };
            }(h$$1)("ul")(new List$1())(toList(delay(function () {
              return append(!methods.has("take") ? function () {
                var op = methods.has("then") ? new PivotEditorAction("ReplaceElement", [methods.get("then"), "take", ofArray$1([new Expr("Number", [10])])]) : new PivotEditorAction("AddElement", [lastSym, "take", ofArray$1([new Expr("Number", [10])])]);
                return singleton(function (arg0_35) {
                  return function (arg1_35) {
                    return El.op_Dynamic(arg0_35, arg1_35);
                  };
                }(h$$1)("li")(new List$1())(ofArray$1([function (arg0_36) {
                  return function (arg1_36) {
                    return El.op_Dynamic(arg0_36, arg1_36);
                  };
                }(h$$1)("a")(ofArray$1([op_EqualsBangGreater("click", trigger(op))]))(ofArray$1([text("take")]))])));
              }() : empty(), delay(function () {
                if (!methods.has("skip")) {
                  var op_1 = new PivotEditorAction("AddElement", [firstSym, "skip", ofArray$1([new Expr("Number", [10])])]);
                  return singleton(function (arg0_37) {
                    return function (arg1_37) {
                      return El.op_Dynamic(arg0_37, arg1_37);
                    };
                  }(h$$1)("li")(new List$1())(ofArray$1([function (arg0_38) {
                    return function (arg1_38) {
                      return El.op_Dynamic(arg0_38, arg1_38);
                    };
                  }(h$$1)("a")(ofArray$1([op_EqualsBangGreater("click", trigger(op_1))]))(ofArray$1([text("skip")]))])));
                } else {
                  return empty();
                }
              }));
            }))))
          };

        case 1:
          return {
            v: renderAddPropertyMenu(trigger, function (n) {
              return (n !== "then" ? n !== "preview" : false) ? !(n.indexOf("and") === 0) : false;
            }, $var194[1])
          };

        case 2:
          return {
            v: renderAddPropertyMenu(trigger, function (n_1) {
              return n_1 !== "then" ? n_1 !== "preview" : false;
            }, $var194[1])
          };

        case 3:
          return {
            v: renderAddPropertyMenu(trigger, function (n_2) {
              return n_2 !== "then" ? n_2 !== "preview" : false;
            }, $var194[1])
          };

        case 4:
          return {
            v: empty()
          };
      }
    }();

    if ((typeof _ret9 === "undefined" ? "undefined" : _typeof(_ret9)) === "object") return _ret9.v;
  }))), function (arg0_39) {
    return function (arg1_39) {
      return El.op_Dynamic(arg0_39, arg1_39);
    };
  }(h$$1)("div")(ofArray$1([op_EqualsGreater("class", "preview-body")]))(toList(delay(function () {
    return singleton(state.State.Preview);
  })))]));

  var patternInput = state.Mapper.AbsoluteToLineCol(state.State.Body.Range.End);
  return new LiveEditorZone(patternInput[0], dom);
}
var preview = new LivePreview(function (trigger) {
  return function (state) {
    return function (event) {
      return updatePivotState(trigger, state, event);
    };
  };
}, function (triggerEvent) {
  return function (state_1) {
    return renderPivot(triggerEvent, state_1);
  };
}, function () {
  var Body = node(new _Range(0, 0), new Expr("Empty", []));
  var FirstNode = node(new _Range(0, 0), new Expr("Empty", []));
  var SelectedEntity = null;
  return new PivotEditorState(Body, FirstNode, text("not created"), new List$1(), SelectedEntity, new PivotEditorMenus("Hidden", []), null);
}());

function commandAtLocation$1(loc, program) {
  return tryFind(function (cmd) {
    return cmd.Range.Start <= loc ? cmd.Range.End + 1 >= loc : false;
  }, program.Body.Node);
}
var ShowableEditorState = function () {
  function ShowableEditorState(endLocation, preview, previewSymbol, previewID) {
    _classCallCheck(this, ShowableEditorState);

    this.EndLocation = endLocation;
    this.Preview = preview;
    this.PreviewSymbol = previewSymbol;
    this.PreviewID = previewID;
  }

  _createClass(ShowableEditorState, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Live.Showable.ShowableEditorState",
        interfaces: ["FSharpRecord"],
        properties: {
          EndLocation: "number",
          Preview: DomNode,
          PreviewSymbol: Interface("TheGamma.Common.Symbol"),
          PreviewID: "number"
        }
      };
    }
  }]);

  return ShowableEditorState;
}();
setType("TheGamma.Live.Showable.ShowableEditorState", ShowableEditorState);
function updateBody$1(trigger, state) {
  Log.trace("live", "Showable - updating body");
  var matchValue = commandAtLocation$1(state.Location, state.Program);
  var $var196 = matchValue != null ? matchValue.Node.Case === "Expr" ? matchValue.Entity != null ? matchValue.Entity.Kind.Case === "RunCommand" ? [0, matchValue, matchValue.Node.Fields[0], matchValue.Entity.Kind.Fields[0]] : [1] : [1] : [1] : [1];

  switch ($var196[0]) {
    case 0:
      var matchValue_1 = $var196[3].Type;

      if (matchValue_1.Case === "Object") {
        var hasShow = matchValue_1.Fields[0].Members.some(function (_arg1) {
          var $var197 = _arg1.Name === "show" ? _arg1.Type.Case === "Method" ? _arg1.Type.Fields[0].tail != null ? _arg1.Type.Fields[0].head[2].Case === "Primitive" ? _arg1.Type.Fields[0].head[2].Fields[0].Case === "String" ? _arg1.Type.Fields[0].tail.tail == null ? [0] : [1] : [1] : [1] : [1] : [1] : [1];

          switch ($var197[0]) {
            case 0:
              return true;

            case 1:
              return false;
          }
        });

        if (hasShow) {
          var _ret = function () {
            var res = evaluate(state.Globals, $var196[3]);

            if (res != null) {
              var _ret2 = function () {
                var id = !equals($var196[3].Symbol, state.State.PreviewSymbol) ? state.State.PreviewID + 1 : state.State.PreviewID;

                var placeholder = function (arg0) {
                  return function (arg1) {
                    return El.op_Dynamic(arg0, arg1);
                  };
                }(h$$1)("div")(ofArray$1([op_EqualsGreater("class", "placeholder")]))(ofArray$1([text("Loading preview...")]));

                var dom = function (arg0_1) {
                  return function (arg1_1) {
                    return El.op_Dynamic(arg0_1, arg1_1);
                  };
                }(h$$1)("div")(new List$1())(ofArray$1([function (arg00) {
                  return function (arg10) {
                    return function (arg20) {
                      return h$$1.delayed(arg00, arg10, arg20);
                    };
                  };
                }(String(id))(placeholder)(function (id_1) {
                  Log.trace("live", "Show: %O", res.Value);
                  res.Value.show(id_1);
                })]));

                return {
                  v: {
                    v: function () {
                      var State = new ShowableEditorState($var196[1].Range.End, dom, $var196[3].Symbol, id);
                      return new LiveState(state.Globals, state.Code, state.Program, state.Mapper, state.Location, state.Selection, State, state.CurrentPreview);
                    }()
                  }
                };
              }();

              if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
            } else {
              return {
                v: null
              };
            }
          }();

          if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
        } else {
          return null;
        }
      } else {
        return null;
      }

    case 1:
      return null;
  }
}
function updateShowableState(trigger, state, event) {
  var $var198 = event.Case === "UpdateLocation" ? [0] : event.Case === "InitializeGlobals" ? [1] : event.Case === "CustomEvent" ? [1] : [0];

  switch ($var198[0]) {
    case 0:
      return function (state_1) {
        return updateBody$1(trigger, state_1);
      }(state);

    case 1:
      return state;
  }
}
function renderShowable(trigger, state) {
  var patternInput = state.Mapper.AbsoluteToLineCol(state.State.EndLocation);

  var dom = function (arg0) {
    return function (arg1) {
      return El.op_Dynamic(arg0, arg1);
    };
  }(h$$1)("div")(ofArray$1([op_EqualsGreater("class", "pivot-preview")]))(ofArray$1([function (arg0_1) {
    return function (arg1_1) {
      return El.op_Dynamic(arg0_1, arg1_1);
    };
  }(h$$1)("ul")(ofArray$1([op_EqualsGreater("class", "tabs")]))(ofArray$1([function (arg0_2) {
    return function (arg1_2) {
      return El.op_Dynamic(arg0_2, arg1_2);
    };
  }(h$$1)("li")(ofArray$1([op_EqualsGreater("class", "selected")]))(ofArray$1([function (arg0_3) {
    return function (arg1_3) {
      return El.op_Dynamic(arg0_3, arg1_3);
    };
  }(h$$1)("a")(new List$1())(ofArray$1([text("preview")]))]))])), function (arg0_4) {
    return function (arg1_4) {
      return El.op_Dynamic(arg0_4, arg1_4);
    };
  }(h$$1)("div")(ofArray$1([op_EqualsGreater("class", "preview-body")]))(toList(delay(function () {
    return singleton(state.State.Preview);
  })))]));

  return new LiveEditorZone(patternInput[0], dom);
}
var preview$1 = new LivePreview(function (trigger) {
  return function (state) {
    return function (event) {
      return updateShowableState(trigger, state, event);
    };
  };
}, function (trigger_1) {
  return function (state_1) {
    return renderShowable(trigger_1, state_1);
  };
}, function () {
  var PreviewID = 0;

  var PreviewSymbol = _Symbol2();

  return new ShowableEditorState(0, text("not created"), PreviewSymbol, PreviewID);
}());

var i$2 = 1;
eval('monaco$' + i$2 + ' = monaco');
monaco = monaco;
var noState = _defineProperty({
  clone: function () {
    return this;
  },
  equals: function (other) {
    return true;
  }
}, _Symbol.reflection, function () {
  return {
    interfaces: ["Fable.Import.monaco.languages.IState"]
  };
});
function getColorClass(_arg1) {
  var $var203 = _arg1.Case === "String" ? [0] : _arg1.Case === "QIdent" ? [1] : _arg1.Case === "Ident" ? [1] : _arg1.Case === "Dot" ? [2] : _arg1.Case === "Let" ? [3] : _arg1.Case === "Boolean" ? [3] : _arg1.Case === "Fun" ? [3] : _arg1.Case === "Arrow" ? [3] : _arg1.Case === "Number" ? [4] : [5];

  switch ($var203[0]) {
    case 0:
      return "string";

    case 1:
      return "ident";

    case 2:
      return "operator";

    case 3:
      return "keyword";

    case 4:
      return "number";

    case 5:
      return "";
  }
}
var tokensProvider = _defineProperty({
  tokenize: function (line, state) {
    var tokens = {};
    tokens.endState = noState;
    tokens.tokens = [];

    var patternInput = tokenize(line);

    for (var idx = 0; idx <= patternInput[0].length - 1; idx++) {
      var t = patternInput[0][idx];
      var tok = {};
      tok.startIndex = t.Range.Start;
      tok.scopes = getColorClass(t.Token);
      tokens.tokens.push(tok);
    }

    return tokens;
  },
  getInitialState: function () {
    return noState;
  }
}, _Symbol.reflection, function () {
  return {
    interfaces: ["Fable.Import.monaco.languages.TokensProvider"]
  };
});
function createCompletionProvider(getService) {
  return _defineProperty({
    get triggerCharacters() {
      return _Array$from(ofArray$1(["."]));
    },

    provideCompletionItems: function (model, position, token) {
      return function (arg00) {
        return startAsPromise(arg00);
      }(function (builder_) {
        return builder_.Delay(function () {
          return builder_.TryWith(builder_.Delay(function () {
            var svc = getService(model.uri.toString());
            var input = model.getValue(1, false);
            Log.event("editor", "completions", "", {
              source: input,
              position: position
            });
            var conv = new LocationMapper(input);
            var loc = conv.LineColToAbsolute(~~position.lineNumber, ~~position.column);
            return builder_.Bind(svc.TypeCheck(input), function (_arg1) {
              var optMembers = tryPick(function (tupledArg) {
                var $var204 = tupledArg[1].Kind.Case === "Member" ? tupledArg[1].Kind.Fields[0].Type != null ? tupledArg[1].Kind.Fields[1].Kind.Case === "MemberName" ? function () {
                  var t = tupledArg[1].Kind.Fields[0].Type;
                  var n = tupledArg[1].Kind.Fields[1].Kind.Fields[0];

                  if (loc >= tupledArg[0].Start) {
                    return loc <= tupledArg[0].End + 1;
                  } else {
                    return false;
                  }
                }() ? [0, tupledArg[1].Kind.Fields[1].Kind.Fields[0], tupledArg[1].Kind.Fields[0].Type] : [1] : [1] : [1] : [1];

                switch ($var204[0]) {
                  case 0:
                    Log.trace("completions", "Antecedant at current location (member '%s'): %O", $var204[1].Name, $var204[2]);

                    if ($var204[2].Case === "Object") {
                      return [$var204[1].Name, tupledArg[0], $var204[2].Fields[0].Members];
                    } else {
                      return null;
                    }

                  case 1:
                    var $var205 = tupledArg[1].Kind.Case === "Member" ? tupledArg[1].Kind.Fields[0].Type != null ? tupledArg[1].Kind.Fields[1].Kind.Case === "MemberName" ? [0, tupledArg[1].Kind.Fields[1].Kind.Fields[0], tupledArg[1].Kind.Fields[0].Type] : [1] : [1] : [1];

                    switch ($var205[0]) {
                      case 0:
                        Log.trace("completions", "Ignoring '%s' at location %s-%s (current=%s)", $var205[1].Name, tupledArg[0].Start, tupledArg[0].End, loc);
                        return null;

                      case 1:
                        return null;
                    }

                }
              }, _arg1[1].Entities);

              var convertRange = function convertRange(rng) {
                var patternInput = conv.AbsoluteToLineCol(rng.Start);
                var patternInput_1 = conv.AbsoluteToLineCol(rng.End);
                var res = {};
                res.startColumn = patternInput[1];
                res.startLineNumber = patternInput[0];
                res.endColumn = patternInput_1[1] + 1;
                res.endLineNumber = patternInput_1[0];
                return res;
              };

              if (optMembers != null) {
                var _ret = function () {
                  var nameRange = optMembers[1];
                  var members = optMembers[2];
                  var currentName = optMembers[0];
                  var nameRange_1 = convertRange(nameRange);
                  Log.trace("completions", "providing %s members at %O", members.length, nameRange_1);
                  var completion = toList(delay(function () {
                    return map$3(function (m) {
                      var ci = {};
                      var k = m.Type.Case === "Method" ? 1 : 9;
                      ci.kind = k;
                      ci.label = m.Name;
                      ci.insertText = escapeIdent(m.Name);
                      ci.filterText = escapeIdent(currentName) + m.Name;

                      if (m.Type.Case === "Method") {
                        var patternInput_2 = function () {
                          var folder = function folder(tupledArg_1) {
                            return function (s) {
                              if (tupledArg_1[1].length > 100) {
                                return [new List$1(tupledArg_1[1], tupledArg_1[0]), s];
                              } else {
                                return [tupledArg_1[0], tupledArg_1[1] === "" ? s : tupledArg_1[1] + "," + s];
                              }
                            };
                          };

                          var arg = [new List$1(), ""];
                          return function (source) {
                            return fold(function ($var206, $var207) {
                              return folder($var206)($var207);
                            }, [arg[0], arg[1]], source);
                          };
                        }()(toList(delay(function () {
                          return collect(function (matchValue) {
                            return singleton((matchValue[1] ? "?" : "") + matchValue[0]);
                          }, m.Type.Fields[0]);
                        })));

                        var args = join(",\n", reverse$1(new List$1(patternInput_2[1], patternInput_2[0])));
                        ci.documentation = "(" + args + ")";
                      }

                      var eo = {};
                      eo.text = escapeIdent(m.Name);
                      eo.range = nameRange_1;
                      ci.textEdit = eo;
                      return ci;
                    }, members);
                  }));
                  Log.trace("completions", "returning %O", _Array$from(completion));
                  return {
                    v: builder_.Return(_Array$from(completion))
                  };
                }();

                if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
              } else {
                Log.trace("completions", "no members at %s", loc);
                return builder_.Return(_Array$from(new List$1()));
              }
            });
          }), function (_arg2) {
            Log.exn("completions", "completions failed %O", _arg2);
            return builder_.Return([]);
          });
        });
      }(singleton$2));
    },
    resolveCompletionItem: function (item$$1, token) {
      return item$$1;
    }
  }, _Symbol.reflection, function () {
    return {
      interfaces: ["Fable.Import.monaco.languages.CompletionItemProvider"]
    };
  });
}
var createdEditors = new _Map();
function getService(uri) {
  return createdEditors.get(uri);
}
function setupMonacoServices() {
  var lang = {};
  lang.id = "thegamma";
  monaco$1.languages.register(lang);
  monaco$1.languages.setTokensProvider("thegamma", tokensProvider);
  monaco$1.languages.registerCompletionItemProvider("thegamma", createCompletionProvider(function (uri) {
    return getService(uri);
  }));
}
function createMonacoEditor(id, code, svc, customize) {
  if (createdEditors.size === 0) {
    setupMonacoServices();
  }

  var services = {};
  var options = {};
  var scroll = {};
  scroll.vertical = "none";
  scroll.horizontal = "auto";
  options.scrollbar = scroll;
  options.value = code;
  options.language = "thegamma";
  options.lineNumbersMinChars = 3;
  options.contextmenu = false;
  options.scrollBeyondLastLine = false;
  options.overviewRulerLanes = 0;
  customize(options);
  var ed = monaco$1.editor.create(document.getElementById(id), options, services);
  createdEditors.set(ed.getModel().uri.toString(), svc);
  return ed;
}

function buildGlobalsTable(provideTypes) {
  return function (arg00) {
    return function (arg10) {
      return Async_StartAsNamedFuture_Static(arg00, arg10);
    };
  }("buildGlobalsTable")(function (builder_) {
    return builder_.Delay(function () {
      var named = create$6(null, new GenericComparer(compare));

      var lookupNamed = function lookupNamed(n) {
        var matchValue = tryFind$1(n, named);

        if (matchValue == null) {
          Log.error("typechecker", "Could not find named type '%s'", n);
          throw new Error(fsFormat("Could not find named type '%s'")(function (x) {
            return x;
          })(n));
        } else {
          return matchValue;
        }
      };

      return builder_.Bind(provideTypes(lookupNamed), function (_arg1) {
        var allTypes = toList(delay(function () {
          return append(singleton(new ProvidedType("NamedType", ["value", new Type("Any", [])])), delay(function () {
            return append(singleton(new ProvidedType("NamedType", ["object", new Type("Any", [])])), delay(function () {
              return append(singleton(new ProvidedType("NamedType", ["seq", new Type("Any", [])])), delay(function () {
                return append(singleton(new ProvidedType("NamedType", ["async", new Type("Any", [])])), delay(function () {
                  return _arg1;
                }));
              }));
            }));
          }));
        }));
        named = create$6(choose(function (_arg2) {
          return _arg2.Case === "NamedType" ? [_arg2.Fields[0], _arg2.Fields[1]] : null;
        }, allTypes), new GenericComparer(compare));
        var globalEntities = choose$1(function (_arg3) {
          return _arg3.Case === "GlobalValue" ? globalEntity(_arg3.Fields[0], _arg3.Fields[1], _arg3.Fields[3], _arg3.Fields[2]) : null;
        }, allTypes);
        return builder_.Return(globalEntities);
      });
    });
  }(singleton$2));
}
function resolveProvider(lookup, ignoreFilter, kind, endpoint) {
  var _ret = function () {
    switch (kind) {
      case "rest":
        var matchValue = provideRestType(lookup, function (kind_1) {
          return function (endpoint_1) {
            return resolveProvider(lookup, ignoreFilter, kind_1, endpoint_1);
          };
        }, "anonymous", endpoint, "");

        if (matchValue.Case === "GlobalValue") {
          return {
            v: [matchValue.Fields[3], new Emitter(function (_arg1) {
              return matchValue.Fields[2];
            })]
          };
        } else {
          throw new Error("resolveProvider: Expected global value");
        }

      case "pivot":
        var pivotType = function (builder_) {
          return builder_.Delay(function () {
            return builder_.Bind(providePivotType(endpoint, ignoreFilter, "anonymous", lookup), function (_arg1_1) {
              return _arg1_1.Case === "GlobalValue" ? builder_.Return(_arg1_1.Fields[3]) : builder_.Return(function () {
                throw new Error("resolveProvider: Expected global value");
              }());
            });
          });
        }(singleton$2);

        return {
          v: [new Type("Delayed", [function (arg00) {
            return function (arg10) {
              return Async_StartAsNamedFuture_Static(arg00, arg10);
            };
          }("pivotType:" + endpoint)(pivotType)]), new Emitter(function (_arg2) {
            return makePivotExpression(endpoint);
          })]
        };

      default:
        Log.error("providers", "Cannot resolve provider '%s' (%s)", kind, endpoint);
        throw new Error("resolveProvider: Cannot resolve type provider");
    }
  }();

  if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
}
var TheGammaProviders = function () {
  function TheGammaProviders(globals) {
    _classCallCheck(this, TheGammaProviders);

    this.globals = globals;
  }

  _createClass(TheGammaProviders, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Main.TheGammaProviders",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          globals: Interface("TheGamma.Common.Future")
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return TheGammaProviders;
}();
setType("TheGamma.Main.TheGammaProviders", TheGammaProviders);
var TheGammaContext = function () {
  function TheGammaContext(checkingService, providers) {
    _classCallCheck(this, TheGammaContext);

    this.checkingService = checkingService;
    this.providers = providers;
  }

  _createClass(TheGammaContext, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Main.TheGammaContext",
        interfaces: ["FSharpRecord", "System.IEquatable"],
        properties: {
          checkingService: CheckingService,
          providers: TheGammaProviders
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }]);

  return TheGammaContext;
}();
setType("TheGamma.Main.TheGammaContext", TheGammaContext);
function callShowMethod(outputId, cmd) {
  var $var208 = cmd.Node.Case === "Expr" ? cmd.Node.Fields[0].Entity != null ? cmd.Node.Fields[0].Entity.Type != null ? [0, cmd.Node.Fields[0], cmd.Node.Fields[0].Entity.Type] : [1] : [1] : [1];

  switch ($var208[0]) {
    case 0:
      if ($var208[2].Case === "Object") {
        var showTyp = tryPick(function (_arg1) {
          var $var209 = _arg1.Name === "show" ? _arg1.Type.Case === "Method" ? _arg1.Type.Fields[0].tail != null ? _arg1.Type.Fields[0].head[2].Case === "Primitive" ? _arg1.Type.Fields[0].head[2].Fields[0].Case === "String" ? _arg1.Type.Fields[0].tail.tail == null ? [0, _arg1.Type] : [1] : [1] : [1] : [1] : [1] : [1];

          switch ($var209[0]) {
            case 0:
              return $var209[1];

            case 1:
              return null;
          }
        }, $var208[2].Fields[0].Members);

        if (showTyp != null) {
          var _ret2 = function () {
            var rng = new _Range(cmd.Range.End, cmd.Range.End);
            var outExpr = node(rng, new Expr("String", [outputId]));
            var args = ofArray$1([new Argument(null, outExpr)]);

            var showMember = function (node$$1) {
              return node(rng, node$$1);
            }(new Expr("Member", [$var208[1], node(rng, new Expr("Variable", [node(rng, new Name("show"))]))]));

            var showEntity = new Entity(new EntityKind("Root", []), _Symbol2(), null, new List$1(), showTyp, new List$1());
            showMember.Entity = showEntity;
            var expr = node(rng, new Expr("Call", [showMember, node(rng, args)]));
            return {
              v: node(cmd.Range, new Command("Expr", [expr]))
            };
          }();

          if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
        } else {
          return cmd;
        }
      } else {
        return cmd;
      }

    case 1:
      return cmd;
  }
}

function _evaluate(ctx, code, outputId) {
  return function (builder_) {
    return builder_.Delay(function () {
      return builder_.Bind(ctx.checkingService.TypeCheck(code), function (_arg1) {
        var newBody = outputId != null ? map$5(function (cmd) {
          return callShowMethod(outputId, cmd);
        }, _arg1[2].Body.Node) : _arg1[2].Body.Node;
        var prog = new Program$$1(new _Node(_arg1[2].Body.WhiteBefore, _arg1[2].Body.WhiteAfter, _arg1[2].Body.Range, newBody, _arg1[2].Body.Entity));
        return builder_.Bind(compile(ctx.providers.globals, code, prog), function (_arg2) {
          var s = series.create(function (builder__1) {
            return builder__1.Delay(function () {
              return builder__1.Return([]);
            });
          }(singleton$2), "", "", "");
          new RuntimeContext("lol", "", "troll");

          (function (c) {
            return function (s_1) {
              return trimLeft(c, s_1);
            };
          });

          (function (arg00) {
            return chart.bar(arg00);
          });

          table.create(s);
          date$1.now();
          series.values(new Int32Array([1]));
          placeholder.create("");

          (function (arg00_1) {
            return youguess.line(arg00_1);
          });

          Log.trace("interpreter", "Main evaluating: %O", _arg2);
          return builder_.Return(eval(_arg2));
        });
      });
    });
  }(singleton$2);
}

var previews = ofArray$1([preview, preview$1]);
var editorOptions = function () {
  function editorOptions(width, height, maxHeight, autoHeight, enablePreview, monacoOptions) {
    _classCallCheck(this, editorOptions);

    this.width = width;
    this.height = height;
    this.maxHeight = maxHeight;
    this.autoHeight = autoHeight;
    this.enablePreview = enablePreview;
    this.monacoOptions = monacoOptions;
  }

  _createClass(editorOptions, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Main.editorOptions",
        interfaces: ["FSharpRecord"],
        properties: {
          width: Option("number"),
          height: Option("number"),
          maxHeight: Option("number"),
          autoHeight: Option("boolean"),
          enablePreview: Option("boolean"),
          monacoOptions: Option("function")
        }
      };
    }
  }]);

  return editorOptions;
}();
setType("TheGamma.Main.editorOptions", editorOptions);
var error = function () {
  function error(number, message, startLine, startColumn, endLine, endColumn) {
    _classCallCheck(this, error);

    this.number = number;
    this.message = message;
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.endLine = endLine;
    this.endColumn = endColumn;
  }

  _createClass(error, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Main.error",
        interfaces: ["FSharpRecord", "System.IEquatable", "System.IComparable"],
        properties: {
          number: "number",
          message: "string",
          startLine: "number",
          startColumn: "number",
          endLine: "number",
          endColumn: "number"
        }
      };
    }
  }, {
    key: "Equals",
    value: function (other) {
      return equalsRecords(this, other);
    }
  }, {
    key: "CompareTo",
    value: function (other) {
      return compareRecords(this, other);
    }
  }]);

  return error;
}();
setType("TheGamma.Main.error", error);
var defaultEditorOptions = function () {
  var width = null;
  var height = null;
  var maxHeight = null;
  var autoHeight = null;
  var monacoOptions = null;
  return new editorOptions(width, height, maxHeight, autoHeight, null, monacoOptions);
}();
var thenable = function () {
  _createClass(thenable, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Main.thenable",
        properties: {}
      };
    }
  }]);

  function thenable(work) {
    var _this = this;

    _classCallCheck(this, thenable);

    this.resCell = new Choice("Choice1Of3", [null]);

    this.trigger = function () {};

    (function (arg00) {
      startImmediate(arg00);
    })(function (builder_) {
      return builder_.Delay(function () {
        return builder_.TryWith(builder_.Delay(function () {
          return builder_.Bind(work, function (_arg1) {
            _this.resCell = new Choice("Choice2Of3", [_arg1]);

            _this.trigger(null);

            return builder_.Zero();
          });
        }), function (_arg2) {
          _this.resCell = new Choice("Choice3Of3", [_arg2]);

          _this.trigger(null);

          return builder_.Zero();
        });
      });
    }(singleton$2));
  }

  _createClass(thenable, [{
    key: "then",
    value: function (onValue, onError) {
      var _this2 = this;

      this.trigger = function () {
        var matchValue = _this2.resCell;

        if (matchValue.Case === "Choice2Of3") {
          _this2.trigger = function () {};

          onValue(matchValue.Fields[0]);
        } else if (matchValue.Case === "Choice3Of3") {
          _this2.trigger = function () {};

          if (function () {
            return onError != null;
          }(null)) {
            onError(matchValue.Fields[0]);
          }
        }
      };

      this.trigger(null);
    }
  }]);

  return thenable;
}();
setType("TheGamma.Main.thenable", thenable);
function serializeType(typ) {
  if (typ.Case === "Delayed") {
    return "delayed";
  } else if (typ.Case === "Primitive") {
    if (typ.Fields[0].Case === "Bool") {
      return "bool";
    } else if (typ.Fields[0].Case === "Date") {
      return "date";
    } else if (typ.Fields[0].Case === "Number") {
      return "number";
    } else if (typ.Fields[0].Case === "String") {
      return "string";
    } else {
      return "unit";
    }
  } else if (typ.Case === "Method") {
    return {
      kind: "function",
      arguments: _Array$from(map$5(function (tupledArg) {
        return serializeType(tupledArg[2]);
      }, typ.Fields[0])),
      result: serializeType(typ.Fields[1](toList(delay(function () {
        return collect(function (matchValue) {
          return singleton(matchValue[2]);
        }, typ.Fields[0]);
      }))))
    };
  } else if (typ.Case === "List") {
    return {
      kind: "array",
      type: serializeType(typ.Fields[0])
    };
  } else if (typ.Case === "Object") {
    return createObj(toList(delay(function () {
      return append(singleton(["kind", "object"]), delay(function () {
        return append(hasInterface(typ.Fields[0], "TheGamma.TypeProviders.FSharpProvider.GenericType") ? singleton(["generics", _Array$from(map$3(function (typ_1) {
          return serializeType(typ_1);
        }, typ.Fields[0].TypeArguments))]) : function () {
          return empty();
        }(), delay(function () {
          return singleton(["members", typ.Fields[0].Members.map(function (m) {
            return m.Name;
          })]);
        }));
      }));
    })));
  } else {
    return "any";
  }
}
function serializeEntity(rng, ent) {
  var patternInput = ent.Kind.Case === "Program" ? ["program", new List$1()] : ent.Kind.Case === "RunCommand" ? ["do", new List$1()] : ent.Kind.Case === "LetCommand" ? ["let", new List$1()] : ent.Kind.Case === "Operator" ? ["operator", new List$1()] : ent.Kind.Case === "List" ? ["list", new List$1()] : ent.Kind.Case === "Constant" ? ["constant", new List$1()] : ent.Kind.Case === "Function" ? ["function", new List$1()] : ent.Kind.Case === "GlobalValue" ? ["global", new List$1()] : ent.Kind.Case === "Variable" ? ["variable", new List$1()] : ent.Kind.Case === "Binding" ? ["binding", new List$1()] : ent.Kind.Case === "ArgumentList" ? ["args", new List$1()] : ent.Kind.Case === "CallSite" ? ["callsite", new List$1()] : ent.Kind.Case === "Member" ? ["member", new List$1()] : ent.Kind.Case === "MemberName" ? ["name", ofArray$1([["name", ent.Kind.Fields[0].Name]])] : ent.Kind.Case === "NamedParam" ? ["param", ofArray$1([["name", ent.Kind.Fields[0].Name]])] : ent.Kind.Case === "Placeholder" ? ["placeholder", ofArray$1([["name", ent.Kind.Fields[0].Name]])] : ent.Kind.Case === "Call" ? ["call", new List$1()] : ["root", new List$1()];
  return createObj(toList(delay(function () {
    return append(singleton(["kind", patternInput[0]]), delay(function () {
      return append(function () {
        return rng != null;
      }(null) ? singleton(["range", {
        start: rng.Start,
        end: rng.End
      }]) : empty(), delay(function () {
        return append(singleton(["getChildren", function () {
          return _Array$from(Entity_get_Antecedents.bind(ent)()).map(function () {
            var rng_1 = null;
            return function (ent_1) {
              return serializeEntity(rng_1, ent_1);
            };
          }());
        }]), delay(function () {
          return append(singleton(["type", function () {
            var matchValue = ent.Type;

            if (matchValue != null) {
              return serializeType(matchValue);
            } else {
              return "unknown";
            }
          }()]), delay(function () {
            return patternInput[1];
          }));
        }));
      }));
    }));
  })));
}
var checkingResult = function () {
  _createClass(checkingResult, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Main.checkingResult",
        properties: {
          wellTyped: "boolean"
        }
      };
    }
  }]);

  function checkingResult(_wellTyped, _bindingResult, _program) {
    _classCallCheck(this, checkingResult);

    this._wellTyped = _wellTyped;
    this._bindingResult = _bindingResult;
  }

  _createClass(checkingResult, [{
    key: "getEntities",
    value: function () {
      return this._bindingResult.Entities.map(function (tupledArg) {
        return serializeEntity(tupledArg[0], tupledArg[1]);
      });
    }
  }, {
    key: "wellTyped",
    get: function () {
      return this._wellTyped;
    }
  }]);

  return checkingResult;
}();
setType("TheGamma.Main.checkingResult", checkingResult);
var editor$1 = function () {
  _createClass(editor$$1, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Main.editor",
        properties: {}
      };
    }
  }]);

  function editor$$1(ed) {
    _classCallCheck(this, editor$$1);

    this.ed = ed;
  }

  _createClass(editor$$1, [{
    key: "getMonacoEditor",
    value: function () {
      return this.ed;
    }
  }, {
    key: "getValue",
    value: function () {
      return this.ed.getModel().getValue(1, false);
    }
  }, {
    key: "setValue",
    value: function (text) {
      this.ed.getModel().setValue(text);
    }
  }]);

  return editor$$1;
}();
setType("TheGamma.Main.editor", editor$1);
var gamma = function () {
  _createClass(gamma, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Main.gamma",
        properties: {}
      };
    }
  }]);

  function gamma(ctx) {
    _classCallCheck(this, gamma);

    this.ctx = ctx;
  }

  _createClass(gamma, [{
    key: "check",
    value: function (code) {
      var _this3 = this;

      return new thenable(function (builder_) {
        return builder_.Delay(function () {
          return builder_.Bind(_this3.ctx.checkingService.TypeCheck(code), function (_arg1) {
            return builder_.Return(function (tupledArg) {
              return new checkingResult(tupledArg[0], tupledArg[1], tupledArg[2]);
            }(_arg1));
          });
        });
      }(singleton$2));
    }
  }, {
    key: "evaluate",
    value: function (code, outputId) {
      var _this4 = this;

      return new thenable(function (builder_) {
        return builder_.Delay(function () {
          return builder_.TryWith(builder_.Delay(function () {
            return builder_.ReturnFrom(_evaluate(_this4.ctx, code, outputId));
          }), function (_arg2) {
            Log.exn("api", "Evaluating code '%O' failed with error '%O'.", code, _arg2);
            return builder_.ReturnFrom(function () {
              throw _arg2;
            }());
          });
        });
      }(singleton$2));
    }
  }, {
    key: "errorsReported",
    value: function (f) {
      add$5(function (tupledArg) {
        f(_Array$from(sortWith(function (x, y) {
          return compare(function (e_1) {
            return e_1.Range.Start;
          }(x), function (e_1) {
            return e_1.Range.Start;
          }(y));
        }, tupledArg[1])).map(function (e) {
          return new error(e.Number, e.Message, e.Range.Start.Line, e.Range.Start.Column, e.Range.End.Line, e.Range.End.Column);
        }));
      }, this.ctx.checkingService.ErrorsReported);
    }
  }, {
    key: "createEditor",
    value: function (id, source, options) {
      var lineHeight = 20;
      var options_1 = options != null ? options : defaultEditorOptions;
      var el = document.getElementById(id);
      var width = defaultArg(options_1.width, el.clientWidth);
      var height = defaultArg(options_1.height, el.clientHeight);
      var maxHeight = defaultArg(options_1.maxHeight, 2147483647);
      var ed = createMonacoEditor(id, source, this.ctx.checkingService, function (opts) {
        opts.fontSize = 15;
        opts.lineHeight = 20;
        defaultArg(options_1.monacoOptions, function (value) {
          value;
        })(opts);
        var matchValue = opts.lineHeight;

        if (matchValue != null) {
          lineHeight = matchValue;
        }
      });
      var dim = {};
      dim.width = width;
      dim.height = height;
      ed.layout(dim);
      var previewService = defaultArg(options_1.enablePreview, true) ? new PreviewService(this.ctx.checkingService, this.ctx.providers.globals, ed, previews) : null;
      var lastHeight = -1;

      var autosizeEditor = function autosizeEditor() {
        var text = ed.getModel().getValue(1, false);
        var lines = 1 + split$$1(text, "\n").length;
        var zoneHeight = previewService != null ? previewService.ZoneHeight : 0;
        var height_1 = maxHeight < (200 > lines * 20 + zoneHeight ? 200 : lines * 20 + zoneHeight) ? maxHeight : 200 > lines * 20 + zoneHeight ? 200 : lines * 20 + zoneHeight;

        if (height_1 !== lastHeight) {
          lastHeight = height_1;
          var dim_1 = {};
          dim_1.width = width;
          dim_1.height = height_1;
          ed.layout(dim_1);
          el.style.height = String(dim_1.height) + "px";
          el.style.width = String(dim_1.width) + "px";
        }
      };

      if (equals(options_1.autoHeight, true)) {
        ed.getModel().onDidChangeContent(function (_arg1) {
          autosizeEditor(null);
        });

        if (previewService != null) {
          add$5(function () {
            autosizeEditor(null);
          }, previewService.ZoneSizeChanged);
        }

        autosizeEditor(null);
      }

      return new editor$1(ed);
    }
  }], [{
    key: "createContext",
    value: function (providers) {
      var checkingSvc = new CheckingService("", providers.globals);
      return new gamma(new TheGammaContext(checkingSvc, providers));
    }
  }]);

  return gamma;
}();
setType("TheGamma.Main.gamma", gamma);
var providers = function () {
  function providers() {
    _classCallCheck(this, providers);
  }

  _createClass(providers, [{
    key: _Symbol.reflection,
    value: function () {
      return {
        type: "TheGamma.Main.providers",
        properties: {}
      };
    }
  }], [{
    key: "createProviders",
    value: function (providers_1) {
      var globals = buildGlobalsTable(function (lookup) {
        return function (builder_) {
          return builder_.Delay(function () {
            var providers_2 = function (o) {
              return _Object$keys(o).map(function (k) {
                return {
                  "key": k,
                  "value": o[k]
                };
              });
            }(providers_1).map(function (kv) {
              return kv.value(kv.key)(lookup);
            });

            return builder_.Bind(parallel(providers_2), function (_arg1) {
              return builder_.Return(concat(_arg1));
            });
          });
        }(singleton$2);
      });
      return new TheGammaProviders(globals);
    }
  }, {
    key: "rest",
    value: function (url, cookies, ignoreFilter) {
      return function (name) {
        return function (lookup) {
          return function (builder_) {
            return builder_.Delay(function () {
              var provider = provideRestType(lookup, function () {
                var ignoreFilter_1 = ignoreFilter != null ? ignoreFilter : false;
                return function (kind) {
                  return function (endpoint) {
                    return resolveProvider(lookup, ignoreFilter_1, kind, endpoint);
                  };
                };
              }(), name, url, cookies != null ? cookies : "");
              return builder_.Return(ofArray$1([provider]));
            });
          }(singleton$2);
        };
      };
    }
  }, {
    key: "library",
    value: function (url) {
      return function (_arg3) {
        return function (lookup) {
          return provideFSharpTypes(lookup, url);
        };
      };
    }
  }, {
    key: "pivot",
    value: function (url, ignoreFilter) {
      return function (name) {
        return function (lookup) {
          return function (builder_) {
            return builder_.Delay(function () {
              return builder_.Bind(providePivotType(url, ignoreFilter != null ? ignoreFilter : false, name, lookup), function (_arg2) {
                return builder_.Return(ofArray$1([_arg2]));
              });
            });
          }(singleton$2);
        };
      };
    }
  }]);

  return providers;
}();
setType("TheGamma.Main.providers", providers);

exports.evaluate = _evaluate;
exports.buildGlobalsTable = buildGlobalsTable;
exports.resolveProvider = resolveProvider;
exports.TheGammaProviders = TheGammaProviders;
exports.TheGammaContext = TheGammaContext;
exports.callShowMethod = callShowMethod;
exports.previews = previews;
exports.editorOptions = editorOptions;
exports.error = error;
exports.defaultEditorOptions = defaultEditorOptions;
exports.thenable = thenable;
exports.serializeType = serializeType;
exports.serializeEntity = serializeEntity;
exports.checkingResult = checkingResult;
exports.editor = editor$1;
exports.gamma = gamma;
exports.providers = providers;

Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=thegamma.js.map